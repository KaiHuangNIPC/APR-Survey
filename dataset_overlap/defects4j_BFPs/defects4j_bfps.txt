['Csv-1', 1, 1, 1, 1, ["@Override public int read() throws IOException { int current = super.read(); if (current == '\\n') { lineCounter++; } lastChar = current;"], ["@Override public int read() throws IOException { int current = super.read(); if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) { lineCounter++; } lastChar = current;"], ["if (current == '\\n') {"], ["if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {"], 'a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java', 'b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java']
['Csv-2', 1, 1, 1, 1, ['"No header mapping was specified, the record values can\'t be accessed by name"); } final Integer index = mapping.get(name); return index != null ? values[index.intValue()] : null; } /**'], ['"No header mapping was specified, the record values can\'t be accessed by name"); } final Integer index = mapping.get(name); try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( "Index for header \'%s\' is %d but CSVRecord only has %d values!", name, index.intValue(), values.length)); } } /**'], [''], ['try { } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( "Index for header \'%s\' is %d but CSVRecord only has %d values!", name, index.intValue(), values.length)); }'], 'a/src/main/java/org/apache/commons/csv/CSVRecord.java', 'b/src/main/java/org/apache/commons/csv/CSVRecord.java']
['Csv-3', 1, 1, 1, 1, ['throw new IOException("EOF whilst processing escape sequence"); default: // Now check for meta-characters return c; // indicate unexpected char - available from in.getLastChar() } }'], ['throw new IOException("EOF whilst processing escape sequence"); default: // Now check for meta-characters if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) { return c; } // indicate unexpected char - available from in.getLastChar() return END_OF_STREAM; } }'], [''], ['if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) { } return END_OF_STREAM;'], 'a/src/main/java/org/apache/commons/csv/Lexer.java', 'b/src/main/java/org/apache/commons/csv/Lexer.java']
['Csv-4', 1, 1, 1, 1, ['* @return a copy of the header map that iterates in column order. */ public Map<String, Integer> getHeaderMap() { return new LinkedHashMap<String, Integer>(this.headerMap); } /**'], ['* @return a copy of the header map that iterates in column order. */ public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } /**'], ['return new LinkedHashMap<String, Integer>(this.headerMap);'], ['return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);'], 'a/src/main/java/org/apache/commons/csv/CSVParser.java', 'b/src/main/java/org/apache/commons/csv/CSVParser.java']
['Csv-5', 1, 1, 1, 1, ['*/ public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); out.append(recordSeparator); newRecord = true; }'], ['*/ public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; }'], [''], ['if (recordSeparator != null) { }'], 'a/src/main/java/org/apache/commons/csv/CSVPrinter.java', 'b/src/main/java/org/apache/commons/csv/CSVPrinter.java']
['Csv-6', 1, 1, 1, 1, ['<M extends Map<String, String>> M putIn(final M map) { for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); map.put(entry.getKey(), values[col]); } return map; }'], ['<M extends Map<String, String>> M putIn(final M map) { for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); if (col < values.length) { map.put(entry.getKey(), values[col]); } } return map; }'], [''], ['if (col < values.length) { }'], 'a/src/main/java/org/apache/commons/csv/CSVRecord.java', 'b/src/main/java/org/apache/commons/csv/CSVRecord.java']
['Csv-7', 2, 2, 2, 2, ['import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap;', '// build the name to index mappings if (header != null) { for (int i = 0; i < header.length; i++) { hdrMap.put(header[i], Integer.valueOf(i)); } }'], ['import java.net.URL; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap;', '// build the name to index mappings if (header != null) { for (int i = 0; i < header.length; i++) { if (hdrMap.containsKey(header[i])) { throw new IllegalStateException("The header contains duplicate names: " + Arrays.toString(header)); } hdrMap.put(header[i], Integer.valueOf(i)); } }'], ['', ''], ['import java.util.Arrays;', 'if (hdrMap.containsKey(header[i])) { throw new IllegalStateException("The header contains duplicate names: " + Arrays.toString(header)); }'], 'a/src/main/java/org/apache/commons/csv/CSVParser.java', 'b/src/main/java/org/apache/commons/csv/CSVParser.java']
['Csv-8', 2, 2, 2, 2, ['if (header == null) { this.header = null; } else { this.header = header.clone(); } this.skipHeaderRecord = skipHeaderRecord;', 'throw new IllegalStateException("No quotes mode set but no escape character is set"); } if (header != null) { final Set<String> set = new HashSet<String>(header.length); set.addAll(Arrays.asList(header)); if (set.size() != header.length) { throw new IllegalStateException("The header contains duplicate names: " + Arrays.toString(header)); } } } /**'], ['if (header == null) { this.header = null; } else { Set<String> dupCheck = new HashSet<String>(); for(String hdr : header) { if (!dupCheck.add(hdr)) { throw new IllegalArgumentException("The header contains a duplicate entry: \'" + hdr + "\' in " + Arrays.toString(header)); } } this.header = header.clone(); } this.skipHeaderRecord = skipHeaderRecord;', 'throw new IllegalStateException("No quotes mode set but no escape character is set"); } } /**'], ['', 'if (header != null) { final Set<String> set = new HashSet<String>(header.length); set.addAll(Arrays.asList(header)); if (set.size() != header.length) { throw new IllegalStateException("The header contains duplicate names: " + Arrays.toString(header)); } }'], ['Set<String> dupCheck = new HashSet<String>(); for(String hdr : header) { if (!dupCheck.add(hdr)) { throw new IllegalArgumentException("The header contains a duplicate entry: \'" + hdr + "\' in " + Arrays.toString(header)); } }', ''], 'a/src/main/java/org/apache/commons/csv/CSVFormat.java', 'b/src/main/java/org/apache/commons/csv/CSVFormat.java']
['Csv-9', 1, 1, 1, 1, ['* @return the given map. */ <M extends Map<String, String>> M putIn(final M map) { for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); if (col < values.length) {'], ['* @return the given map. */ <M extends Map<String, String>> M putIn(final M map) { if (mapping == null) { return map; } for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); if (col < values.length) {'], [''], ['if (mapping == null) { return map; }'], 'a/src/main/java/org/apache/commons/csv/CSVRecord.java', 'b/src/main/java/org/apache/commons/csv/CSVRecord.java']
['Csv-10', 1, 1, 1, 1, ['this.format.validate(); // TODO: Is it a good idea to do this here instead of on the first call to a print method? // It seems a pain to have to track whether the header has already been printed or not. } // ======================================================'], ['this.format.validate(); // TODO: Is it a good idea to do this here instead of on the first call to a print method? // It seems a pain to have to track whether the header has already been printed or not. if (format.getHeader() != null) { this.printRecord((Object[]) format.getHeader()); } } // ======================================================'], [''], ['if (format.getHeader() != null) { this.printRecord((Object[]) format.getHeader()); }'], 'a/src/main/java/org/apache/commons/csv/CSVPrinter.java', 'b/src/main/java/org/apache/commons/csv/CSVPrinter.java']
['Csv-11', 1, 1, 1, 1, ['for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException("The header contains a duplicate name: \\"" + header + "\\" in " + Arrays.toString(headerRecord));'], ['for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header == null || header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException("The header contains a duplicate name: \\"" + header + "\\" in " + Arrays.toString(headerRecord));'], ['final boolean emptyHeader = header.trim().isEmpty();'], ['final boolean emptyHeader = header == null || header.trim().isEmpty();'], 'a/src/main/java/org/apache/commons/csv/CSVParser.java', 'b/src/main/java/org/apache/commons/csv/CSVParser.java']
['Csv-12', 1, 1, 1, 1, ['* Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}. * </p> */ public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); /** * Tab-delimited format.'], ['* Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}. * </p> */ public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); /** * Tab-delimited format.'], ['public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);'], ['public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);'], 'a/src/main/java/org/apache/commons/csv/CSVFormat.java', 'b/src/main/java/org/apache/commons/csv/CSVFormat.java']
['Csv-13', 2, 2, 2, 2, ['* http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a> */ public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF); /** * Returns true if the given character is a line break character.', 'if (!newRecord) { out.append(format.getDelimiter()); } if (format.isQuoteCharacterSet()) { // the original object is needed so can check for Number printAndQuote(object, value, offset, len); } else if (format.isEscapeCharacterSet()) {'], ['* http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a> */ public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString("\\\\N"); /** * Returns true if the given character is a line break character.', 'if (!newRecord) { out.append(format.getDelimiter()); } if (object == null) { out.append(value); } else if (format.isQuoteCharacterSet()) { // the original object is needed so can check for Number printAndQuote(object, value, offset, len); } else if (format.isEscapeCharacterSet()) {'], ['.withQuote(null).withRecordSeparator(LF);', 'if (format.isQuoteCharacterSet()) {'], ['.withQuote(null).withRecordSeparator(LF).withNullString("\\\\N");', 'if (object == null) { out.append(value); } else if (format.isQuoteCharacterSet()) {'], 'a/src/main/java/org/apache/commons/csv/CSVPrinter.java', 'b/src/main/java/org/apache/commons/csv/CSVPrinter.java']
['Csv-14', 1, 1, 1, 1, ["char c = value.charAt(pos); // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA = %x20-21 / %x23-2B / %x2D-7E if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { quote = true; } else if (c <= COMMENT) { // Some other chars at the start of a value caused the parser to fail, so for now"], ['char c = value.charAt(pos); // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA = %x20-21 / %x23-2B / %x2D-7E if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { // Some other chars at the start of a value caused the parser to fail, so for now'], ["if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {"], ['if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {'], 'a/src/main/java/org/apache/commons/csv/CSVFormat.java', 'b/src/main/java/org/apache/commons/csv/CSVFormat.java']
['Csv-15', 1, 1, 1, 1, ["} else { char c = value.charAt(pos); if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { // Some other chars at the start of a value caused the parser to fail, so for now // encapsulate if we start in anything less than '#'. We are being conservative // by including the default comment char too."], ["} else { char c = value.charAt(pos); if (c <= COMMENT) { // Some other chars at the start of a value caused the parser to fail, so for now // encapsulate if we start in anything less than '#'. We are being conservative // by including the default comment char too."], ['if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) {'], ['if (c <= COMMENT) {'], 'a/src/main/java/org/apache/commons/csv/CSVFormat.java', 'b/src/main/java/org/apache/commons/csv/CSVFormat.java']
['Csv-16', 4, 4, 4, 4, [' private final Lexer lexer; /** A record buffer for getRecord(). Grows as necessary and is reused. */ private final List<String> recordList = new ArrayList<>();', ' this.format = format; this.lexer = new Lexer(format, new ExtendedBufferedReader(reader)); this.headerMap = this.initializeHeader(); this.characterOffset = characterOffset; this.recordNumber = recordNumber - 1;', '*/ @Override public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() {', 'throw new UnsupportedOperationException(); } }; } /** * Parses the next record from the current point in the stream.'], [' private final Lexer lexer; private final CSVRecordIterator csvRecordIterator; /** A record buffer for getRecord(). Grows as necessary and is reused. */ private final List<String> recordList = new ArrayList<>();', ' this.format = format; this.lexer = new Lexer(format, new ExtendedBufferedReader(reader)); this.csvRecordIterator = new CSVRecordIterator(); this.headerMap = this.initializeHeader(); this.characterOffset = characterOffset; this.recordNumber = recordNumber - 1;', '*/ @Override public Iterator<CSVRecord> iterator() { return csvRecordIterator; } class CSVRecordIterator implements Iterator<CSVRecord> { private CSVRecord current; private CSVRecord getNextRecord() {', 'throw new UnsupportedOperationException(); } }; /** * Parses the next record from the current point in the stream.'], ['', '', 'return new Iterator<CSVRecord>() {', '}'], ['private final CSVRecordIterator csvRecordIterator;', 'this.csvRecordIterator = new CSVRecordIterator();', 'return csvRecordIterator; } class CSVRecordIterator implements Iterator<CSVRecord> {', ''], 'a/src/main/java/org/apache/commons/csv/CSVParser.java', 'b/src/main/java/org/apache/commons/csv/CSVParser.java']
['JacksonXml-1', 2, 2, 2, 2, ['// Simple, except that if this is a leaf, need to suppress end: if (_mayBeLeaf) { _mayBeLeaf = false; // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to // expose as empty Object, not null return (_currToken = JsonToken.VALUE_NULL); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;', '// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to // expose as empty Object, not null (or, worse, as used to // be done, by swallowing the token) _currToken = JsonToken.END_ARRAY; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken; } } return (_currToken = JsonToken.VALUE_STRING);'], ['// Simple, except that if this is a leaf, need to suppress end: if (_mayBeLeaf) { _mayBeLeaf = false; if (_parsingContext.inArray()) { // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to // expose as empty Object, not null _nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } return (_currToken = JsonToken.VALUE_NULL); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;', '// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to // expose as empty Object, not null (or, worse, as used to // be done, by swallowing the token) _nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } } return (_currToken = JsonToken.VALUE_STRING);'], ['', '_currToken = JsonToken.END_ARRAY; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken;'], ['if (_parsingContext.inArray()) { _nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); }', '_nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT);'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java']
['JacksonXml-2', 4, 4, 4, 4, ['* * @since 2.8 */ /** * Index of the next attribute of the current START_ELEMENT', '} // otherwise need to find START/END_ELEMENT or text String text = _collectUntilTag(); // If we have no/all-whitespace text followed by START_ELEMENT, ignore text if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) { return _initStartElement(); } // For END_ELEMENT we will return text, if any if (text != null) { _textValue = text; return (_currentState = XML_TEXT); } return _handleEndElement(); case XML_ATTRIBUTE_NAME:', 'return (_currentState = XML_ATTRIBUTE_VALUE); case XML_TEXT: // mixed text with other elements // text followed by END_ELEMENT return _handleEndElement(); case XML_END:', '} // for DEBUGGING @Override'], ['* * @since 2.8 */ protected boolean _mixedText; /** * Index of the next attribute of the current START_ELEMENT', '} // otherwise need to find START/END_ELEMENT or text String text = _collectUntilTag(); final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT; // If we have no/all-whitespace text followed by START_ELEMENT, ignore text if (startElementNext) { if (text == null || _allWs(text)) { _mixedText = false; return _initStartElement(); } _mixedText = true; _textValue = text; return (_currentState = XML_TEXT); } // For END_ELEMENT we will return text, if any if (text != null) { _mixedText = false; _textValue = text; return (_currentState = XML_TEXT); } _mixedText = false; return _handleEndElement(); case XML_ATTRIBUTE_NAME:', 'return (_currentState = XML_ATTRIBUTE_VALUE); case XML_TEXT: // mixed text with other elements if (_mixedText){ _mixedText = false; return _initStartElement(); } // text followed by END_ELEMENT return _handleEndElement(); case XML_END:', "} protected boolean _allWs(String str) { final int len = (str == null) ? 0 : str.length(); if (len > 0) { for (int i = 0; i < len; ++i) { if (str.charAt(i) > ' ') { return false; } } } return true; } // for DEBUGGING @Override"], ['', 'if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {', '', ''], ['protected boolean _mixedText;', 'final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT; if (startElementNext) { if (text == null || _allWs(text)) { _mixedText = false; } _mixedText = true; _textValue = text; return (_currentState = XML_TEXT); _mixedText = false; _mixedText = false;', 'if (_mixedText){ _mixedText = false; return _initStartElement(); }', "protected boolean _allWs(String str) { final int len = (str == null) ? 0 : str.length(); if (len > 0) { for (int i = 0; i < len; ++i) { if (str.charAt(i) > ' ') { return false; } } } return true; }"], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java']
['JacksonXml-3', 1, 1, 1, 1, ['} break; case XmlTokenStream.XML_ATTRIBUTE_VALUE: _currText = _xmlTokens.getText(); _currToken = JsonToken.VALUE_STRING; break; case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) {'], ['} break; case XmlTokenStream.XML_ATTRIBUTE_VALUE: _currToken = JsonToken.VALUE_STRING; return (_currText = _xmlTokens.getText()); case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) {'], ['_currText = _xmlTokens.getText(); break;'], ['return (_currText = _xmlTokens.getText());'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java']
['JacksonXml-4', 1, 1, 1, 1, ['{ // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly // configured root name... if (jgen instanceof ToXmlGenerator) { _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); } super.serializeValue(jgen, null); }'], ['{ // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly // configured root name... QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = ROOT_NAME_FOR_NULL; } if (jgen instanceof ToXmlGenerator) { _initWithRootName((ToXmlGenerator) jgen, rootName); } super.serializeValue(jgen, null); }'], ['_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);'], ['QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = ROOT_NAME_FOR_NULL; } _initWithRootName((ToXmlGenerator) jgen, rootName);'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java']
['JacksonXml-5', 1, 1, 1, 1, ['super(src); // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy // root name lookup as that may link back to diff version, configuration _rootNameLookup = src._rootNameLookup; } /*'], ['super(src); // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy // root name lookup as that may link back to diff version, configuration _rootNameLookup = new XmlRootNameLookup(); } /*'], ['_rootNameLookup = src._rootNameLookup;'], ['_rootNameLookup = new XmlRootNameLookup();'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java']
['JacksonXml-6', 2, 2, 2, 2, ["} } // Stax2 API only has 'full buffer' write method: // should we consider pretty-printing or not? // base64 encodes up to 3 bytes into a 4 bytes string // we still have < 3 bytes in the buffer private byte[] toFullBuffer(byte[] data, int offset, int len)", 'return result; } /* /**********************************************************'], ['} } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { if (data == null) { writeNull(); return 0; } _verifyValueWrite("write Binary value"); if (_nextName == null) { handleMissingName(); } try { if (_nextIsAttribute) { // Stax2 API only has \'full buffer\' write method: byte[] fullBuffer = toFullBuffer(data, dataLength); _xmlWriter.writeBinaryAttribute("", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer); } else if (checkNextIsUnwrapped()) { // should we consider pretty-printing or not? writeStreamAsBinary(data, dataLength); } else { if (_xmlPrettyPrinter != null) { _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), toFullBuffer(data, dataLength), 0, dataLength); } else { _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart()); writeStreamAsBinary(data, dataLength); _xmlWriter.writeEndElement(); } } } catch (XMLStreamException e) { StaxUtil.throwAsGenerationException(e, this); } return dataLength; } private void writeStreamAsBinary(InputStream data, int len) throws IOException, XMLStreamException { // base64 encodes up to 3 bytes into a 4 bytes string byte[] tmp = new byte[3]; int offset = 0; int read; while((read = data.read(tmp, offset, Math.min(3 - offset, len))) != -1) { offset += read; len -= read; if(offset == 3) { offset = 0; _xmlWriter.writeBinary(tmp, 0, 3); } if (len == 0) { break; } } // we still have < 3 bytes in the buffer if(offset > 0) { _xmlWriter.writeBinary(tmp, 0, offset); } } private byte[] toFullBuffer(byte[] data, int offset, int len)', 'return result; } private byte[] toFullBuffer(InputStream data, final int len) throws IOException { byte[] result = new byte[len]; int offset = 0; for (; offset < len; ) { int count = data.read(result, offset, len - offset); if (count < 0) { _reportError("Too few bytes available: missing "+(len - offset)+" bytes (out of "+len+")"); } offset += count; } return result; } /* /**********************************************************'], ['', ''], ['@Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { if (data == null) { writeNull(); return 0; } _verifyValueWrite("write Binary value"); if (_nextName == null) { handleMissingName(); } try { if (_nextIsAttribute) { byte[] fullBuffer = toFullBuffer(data, dataLength); _xmlWriter.writeBinaryAttribute("", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer); } else if (checkNextIsUnwrapped()) { writeStreamAsBinary(data, dataLength); } else { if (_xmlPrettyPrinter != null) { _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), toFullBuffer(data, dataLength), 0, dataLength); } else { _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart()); writeStreamAsBinary(data, dataLength); _xmlWriter.writeEndElement(); } } } catch (XMLStreamException e) { StaxUtil.throwAsGenerationException(e, this); } return dataLength; } private void writeStreamAsBinary(InputStream data, int len) throws IOException, XMLStreamException { byte[] tmp = new byte[3]; int offset = 0; int read; while((read = data.read(tmp, offset, Math.min(3 - offset, len))) != -1) { offset += read; len -= read; if(offset == 3) { offset = 0; _xmlWriter.writeBinary(tmp, 0, 3); } if (len == 0) { break; } } if(offset > 0) { _xmlWriter.writeBinary(tmp, 0, offset); } }', 'private byte[] toFullBuffer(InputStream data, final int len) throws IOException { byte[] result = new byte[len]; int offset = 0; for (; offset < len; ) { int count = data.read(result, offset, len - offset); if (count < 0) { _reportError("Too few bytes available: missing "+(len - offset)+" bytes (out of "+len+")"); } offset += count; } return result; }'], 'a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java', 'b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java']
['Math-1', 2, 2, 2, 2, ['if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. throw new FractionConversionException(value, p2, q2); }', 'if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. throw new FractionConversionException(value, p2, q2); }'], ['if ((p2 > overflow) || (q2 > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; } throw new FractionConversionException(value, p2, q2); }', 'if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { // in maxDenominator mode, if the last fraction was very close to the actual value // q2 may overflow in the next iteration; in this case return the last one. if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; } throw new FractionConversionException(value, p2, q2); }'], ['', ''], ['if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; }', 'if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; }'], 'a/src/main/java/org/apache/commons/math3/fraction/Fraction.java', 'b/src/main/java/org/apache/commons/math3/fraction/Fraction.java']
['Math-2', 1, 1, 1, 1, ['* size {@code n}, the mean is {@code n * m / N}. */ public double getNumericalMean() { return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); } /**'], ['* size {@code n}, the mean is {@code n * m / N}. */ public double getNumericalMean() { return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize()); } /**'], ['return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();'], ['return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());'], 'a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java', 'b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java']
['Math-3', 1, 1, 1, 1, ['throw new DimensionMismatchException(len, b.length); } // Revert to scalar multiplication. final double[] prodHigh = new double[len]; double prodLowSum = 0;'], ['throw new DimensionMismatchException(len, b.length); } if (len == 1) { // Revert to scalar multiplication. return a[0] * b[0]; } final double[] prodHigh = new double[len]; double prodLowSum = 0;'], [''], ['if (len == 1) { return a[0] * b[0]; }'], 'a/src/main/java/org/apache/commons/math3/util/MathArrays.java', 'b/src/main/java/org/apache/commons/math3/util/MathArrays.java']
['Math-4', 2, 2, 2, 2, [' // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));', ' // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));'], [' // compute the intersection on infinite line Vector3D v1D = line.intersection(subLine.line); if (v1D == null) { return null; } // check location of point with respect to first sub-line Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));', ' // compute the intersection on infinite line Vector2D v2D = line1.intersection(line2); if (v2D == null) { return null; } // check location of point with respect to first sub-line Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));'], ['', ''], ['if (v1D == null) { return null; }', 'if (v2D == null) { return null; }'], 'a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java', 'b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java']
['Math-5', 1, 1, 1, 1, ['} if (real == 0.0 && imaginary == 0.0) { return NaN; } if (isInfinite) {'], ['} if (real == 0.0 && imaginary == 0.0) { return INF; } if (isInfinite) {'], ['return NaN;'], ['return INF;'], 'a/src/main/java/org/apache/commons/math3/complex/Complex.java', 'b/src/main/java/org/apache/commons/math3/complex/Complex.java']
['Math-6', 12, 12, 12, 12, ['this.checker = checker; evaluations = new Incrementor(0, new MaxEvalCallback()); iterations = new Incrementor(0, new MaxIterCallback()); } /**', '} PointValuePair current = null; int iter = 0; int maxEval = getMaxEvaluations(); while (true) { ++iter; final double objective = computeObjectiveValue(point); PointValuePair previous = current; current = new PointValuePair(point, objective); if (previous != null) { if (checker.converged(iter, previous, current)) { // We have found an optimum. return current; }', 'steepestDescent = newSteepestDescent; // Compute conjugate search direction. if (iter % n == 0 || beta < 0) { // Break conjugation: reset search direction. searchDirection = steepestDescent.clone();', ' generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { // Generate and evaluate lambda offspring final RealMatrix arz = randn1(dimension, lambda);', 'double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); int iter = 0; while (true) { ++iter; double fX = fVal; double fX2 = 0;', 'final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { // User-defined stopping criteria. if (checker != null) { stop = checker.converged(iter, previous, current); } } if (stop) {', 'int iteration = 0; final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); while (true) { if (iteration > 0) { boolean converged = true; for (int i = 0; i < simplex.getSize(); i++) { PointValuePair prev = previous[i];', 'previous = simplex.getPoints(); simplex.iterate(evalFunc, comparator); ++iteration; } }', ' // iterate until convergence is reached PointVectorValuePair current = null; int iter = 0; for (boolean converged = false; !converged;) { ++iter; // evaluate the objective function and its jacobian PointVectorValuePair previous = current;', ' // Check convergence. if (previous != null) { converged = checker.converged(iter, previous, current); if (converged) { setCost(computeCost(currentResiduals)); return current;', '// Outer loop. lmPar = 0; boolean firstIteration = true; int iter = 0; final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) { ++iter; final PointVectorValuePair previous = current; // QR decomposition of the jacobian matrix', '// tests for convergence. if (checker != null) { // we use the vectorial convergence checker if (checker.converged(iter, previous, current)) { setCost(currentCost); return current; }'], ['this.checker = checker; evaluations = new Incrementor(0, new MaxEvalCallback()); iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback()); } /**', '} PointValuePair current = null; int maxEval = getMaxEvaluations(); while (true) { incrementIterationCount(); final double objective = computeObjectiveValue(point); PointValuePair previous = current; current = new PointValuePair(point, objective); if (previous != null) { if (checker.converged(getIterations(), previous, current)) { // We have found an optimum. return current; }', 'steepestDescent = newSteepestDescent; // Compute conjugate search direction. if (getIterations() % n == 0 || beta < 0) { // Break conjugation: reset search direction. searchDirection = steepestDescent.clone();', ' generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) { incrementIterationCount(); // Generate and evaluate lambda offspring final RealMatrix arz = randn1(dimension, lambda);', 'double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); while (true) { incrementIterationCount(); double fX = fVal; double fX2 = 0;', 'final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { // User-defined stopping criteria. if (checker != null) { stop = checker.converged(getIterations(), previous, current); } } if (stop) {', 'int iteration = 0; final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); while (true) { if (getIterations() > 0) { boolean converged = true; for (int i = 0; i < simplex.getSize(); i++) { PointValuePair prev = previous[i];', 'previous = simplex.getPoints(); simplex.iterate(evalFunc, comparator); incrementIterationCount(); } }', ' // iterate until convergence is reached PointVectorValuePair current = null; for (boolean converged = false; !converged;) { incrementIterationCount(); // evaluate the objective function and its jacobian PointVectorValuePair previous = current;', ' // Check convergence. if (previous != null) { converged = checker.converged(getIterations(), previous, current); if (converged) { setCost(computeCost(currentResiduals)); return current;', '// Outer loop. lmPar = 0; boolean firstIteration = true; final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); while (true) { incrementIterationCount(); final PointVectorValuePair previous = current; // QR decomposition of the jacobian matrix', '// tests for convergence. if (checker != null) { // we use the vectorial convergence checker if (checker.converged(getIterations(), previous, current)) { setCost(currentCost); return current; }'], ['iterations = new Incrementor(0, new MaxIterCallback());', 'int iter = 0; ++iter; if (checker.converged(iter, previous, current)) {', 'if (iter % n == 0 ||', '', 'int iter = 0; ++iter;', 'stop = checker.converged(iter, previous, current);', 'if (iteration > 0) {', '++iteration;', 'int iter = 0; ++iter;', 'converged = checker.converged(iter, previous, current);', 'int iter = 0; ++iter;', 'if (checker.converged(iter, previous, current)) {'], ['iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());', 'incrementIterationCount(); if (checker.converged(getIterations(), previous, current)) {', 'if (getIterations() % n == 0 ||', 'incrementIterationCount();', 'incrementIterationCount();', 'stop = checker.converged(getIterations(), previous, current);', 'if (getIterations() > 0) {', 'incrementIterationCount();', 'incrementIterationCount();', 'converged = checker.converged(getIterations(), previous, current);', 'incrementIterationCount();', 'if (checker.converged(getIterations(), previous, current)) {'], 'a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java']
['Math-7', 2, 2, 2, 2, ['final double[] eventY = interpolator.getInterpolatedState().clone(); // advance all event states to current time currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop(); // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) {', 'if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } boolean needReset = currentEvent.reset(eventT, eventY); if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; }'], ['final double[] eventY = interpolator.getInterpolatedState().clone(); // advance all event states to current time for (final EventState state : eventsStates) { state.stepAccepted(eventT, eventY); isLastStep = isLastStep || state.stop(); } // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) {', 'if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); return eventT; } boolean needReset = false; for (final EventState state : eventsStates) { needReset = needReset || state.reset(eventT, eventY); } if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; return eventT; }'], ['currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop();', 'for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } boolean needReset = currentEvent.reset(eventT, eventY); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }'], ['for (final EventState state : eventsStates) { state.stepAccepted(eventT, eventY); isLastStep = isLastStep || state.stop(); }', 'boolean needReset = false; for (final EventState state : eventsStates) { needReset = needReset || state.reset(eventT, eventY); }'], 'a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java', 'b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java']
['Math-8', 1, 1, 1, 1, ['* @throws NotStrictlyPositiveException if {@code sampleSize} is not * positive. */ public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { out[i] = sample();'], ['* @throws NotStrictlyPositiveException if {@code sampleSize} is not * positive. */ public Object[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final Object[] out = new Object[sampleSize]; for (int i = 0; i < sampleSize; i++) { out[i] = sample();'], ['public T[] sample(int sampleSize) throws NotStrictlyPositiveException { final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);'], ['public Object[] sample(int sampleSize) throws NotStrictlyPositiveException { final Object[] out = new Object[sampleSize];'], 'a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java', 'b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java']
['Math-9', 1, 1, 1, 1, ['* @return a new instance, with reversed direction */ public Line revert() { final Line reverted = new Line(zero, zero.subtract(direction)); return reverted; }'], ['* @return a new instance, with reversed direction */ public Line revert() { final Line reverted = new Line(this); reverted.direction = reverted.direction.negate(); return reverted; }'], ['final Line reverted = new Line(zero, zero.subtract(direction));'], ['final Line reverted = new Line(this); reverted.direction = reverted.direction.negate();'], 'a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java', 'b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java']
['Math-10', 1, 1, 1, 1, ['} // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly }'], ['} // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]); }'], [''], ['result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);'], 'a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java', 'b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java']
['Math-11', 1, 1, 1, 1, ['throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }'], ['throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -0.5 * dim) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }'], ['return FastMath.pow(2 * FastMath.PI, -dim / 2) *'], ['return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *'], 'a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java', 'b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java']
['Math-12', 2, 2, 2, 2, ['*/ package org.apache.commons.math3.random; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath;', '* @since 2.0 */ public abstract class BitsStreamGenerator implements RandomGenerator { /** Serializable version identifier */ /** Next gaussian. */ private double nextGaussian;'], ['*/ package org.apache.commons.math3.random; import java.io.Serializable; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath;', '* @since 2.0 */ public abstract class BitsStreamGenerator implements RandomGenerator, Serializable { /** Serializable version identifier */ private static final long serialVersionUID = 20130104L; /** Next gaussian. */ private double nextGaussian;'], ['', 'implements RandomGenerator {'], ['import java.io.Serializable;', 'implements RandomGenerator, Serializable { private static final long serialVersionUID = 20130104L;'], 'a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java', 'b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java']
['Math-13', 1, 1, 1, 1, ['* @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } }'], ['* @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } } }'], [''], ['if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { }'], 'a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java']
['Math-14', 2, 2, 2, 2, ['*/ public Weight(double[] weight) { final int dim = weight.length; weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); for (int i = 0; i < dim; i++) { weightMatrix.setEntry(i, i, weight[i]); } } /**', '* @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } }'], ['*/ public Weight(double[] weight) { final int dim = weight.length; weightMatrix = new DiagonalMatrix(weight); } /**', '* @return the square-root of the weight matrix. */ private RealMatrix squareRoot(RealMatrix m) { if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } } }'], ['weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim); for (int i = 0; i < dim; i++) { weightMatrix.setEntry(i, i, weight[i]); }', ''], ['weightMatrix = new DiagonalMatrix(weight);', 'if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { }'], 'a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java']
['Math-15', 2, 2, 2, 2, ['/** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */ private static final double TWO_POWER_52 = 4503599627370496.0; /** 2^53 - double numbers this large must be even. */ /** Constant: {@value}. */ private static final double F_1_3 = 1d / 3d;', '/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); }'], ['/** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */ private static final double TWO_POWER_52 = 4503599627370496.0; /** 2^53 - double numbers this large must be even. */ private static final double TWO_POWER_53 = 2 * TWO_POWER_52; /** Constant: {@value}. */ private static final double F_1_3 = 1d / 3d;', '/* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) { return pow(-x, y); }'], ['', 'if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {'], ['private static final double TWO_POWER_53 = 2 * TWO_POWER_52;', 'if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {'], 'a/src/main/java/org/apache/commons/math3/util/FastMath.java', 'b/src/main/java/org/apache/commons/math3/util/FastMath.java']
['Math-16', 3, 3, 3, 3, ["*/ public class FastMath { /** StrictMath.log(Double.MAX_VALUE): {@value} */ /** Archimede's constant PI, ratio of circle circumference to diameter. */ public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", '// exp(-z) can be ignored in comparison with exp(z) if (x > 20) { // Avoid overflow (MATH-905). return 0.5 * exp(x); } if (x < -20) { // Avoid overflow (MATH-905). return 0.5 * exp(-x); } final double hiPrec[] = new double[2];', '// exp(-z) can be ignored in comparison with exp(z) if (x > 20) { // Avoid overflow (MATH-905). return 0.5 * exp(x); } if (x < -20) { // Avoid overflow (MATH-905). return -0.5 * exp(-x); } if (x == 0) {'], ["*/ public class FastMath { /** StrictMath.log(Double.MAX_VALUE): {@value} */ private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE); /** Archimede's constant PI, ratio of circle circumference to diameter. */ public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", '// exp(-z) can be ignored in comparison with exp(z) if (x > 20) { if (x >= LOG_MAX_VALUE) { // Avoid overflow (MATH-905). final double t = exp(0.5 * x); return (0.5 * t) * t; } else { return 0.5 * exp(x); } } else if (x < -20) { if (x <= -LOG_MAX_VALUE) { // Avoid overflow (MATH-905). final double t = exp(-0.5 * x); return (0.5 * t) * t; } else { return 0.5 * exp(-x); } } final double hiPrec[] = new double[2];', '// exp(-z) can be ignored in comparison with exp(z) if (x > 20) { if (x >= LOG_MAX_VALUE) { // Avoid overflow (MATH-905). final double t = exp(0.5 * x); return (0.5 * t) * t; } else { return 0.5 * exp(x); } } else if (x < -20) { if (x <= -LOG_MAX_VALUE) { // Avoid overflow (MATH-905). final double t = exp(-0.5 * x); return (-0.5 * t) * t; } else { return -0.5 * exp(-x); } } if (x == 0) {'], ['', 'if (x < -20) {', 'if (x < -20) {'], ['private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);', 'if (x >= LOG_MAX_VALUE) { final double t = exp(0.5 * x); return (0.5 * t) * t; } else { } else if (x < -20) { if (x <= -LOG_MAX_VALUE) { final double t = exp(-0.5 * x); return (0.5 * t) * t; } else { }', 'if (x >= LOG_MAX_VALUE) { final double t = exp(0.5 * x); return (0.5 * t) * t; } else { } else if (x < -20) { if (x <= -LOG_MAX_VALUE) { final double t = exp(-0.5 * x); return (-0.5 * t) * t; } else { }'], 'a/src/main/java/org/apache/commons/math3/util/FastMath.java', 'b/src/main/java/org/apache/commons/math3/util/FastMath.java']
['Math-17', 1, 1, 1, 1, ['* @return product of this and x */ public Dfp multiply(final int x) { return multiplyFast(x); } /** Multiply this by a single digit 0&lt;=x&lt;radix.'], ['* @return product of this and x */ public Dfp multiply(final int x) { if (x >= 0 && x < RADIX) { return multiplyFast(x); } else { return multiply(newInstance(x)); } } /** Multiply this by a single digit 0&lt;=x&lt;radix.'], [''], ['if (x >= 0 && x < RADIX) { } else { return multiply(newInstance(x)); }'], 'a/src/main/java/org/apache/commons/math3/dfp/Dfp.java', 'b/src/main/java/org/apache/commons/math3/dfp/Dfp.java']
['Math-18', 3, 3, 3, 3, ['double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = (x[i] - boundaries[0][i]) / diff; } return res; }', 'double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = diff * x[i] + boundaries[0][i]; } return res; }', 'return true; } for (int i = 0; i < x.length; i++) { if (x[i] < 0) { return false; } if (x[i] > 1.0) { return false; } }'], ['double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = x[i] / diff; } return res; }', 'double[] res = new double[x.length]; for (int i = 0; i < x.length; i++) { double diff = boundaries[1][i] - boundaries[0][i]; res[i] = diff * x[i]; } return res; }', 'return true; } final double[] bLoEnc = encode(boundaries[0]); final double[] bHiEnc = encode(boundaries[1]); for (int i = 0; i < x.length; i++) { if (x[i] < bLoEnc[i]) { return false; } if (x[i] > bHiEnc[i]) { return false; } }'], ['res[i] = (x[i] - boundaries[0][i]) / diff;', 'res[i] = diff * x[i] + boundaries[0][i];', 'if (x[i] < 0) { if (x[i] > 1.0) {'], ['res[i] = x[i] / diff;', 'res[i] = diff * x[i];', 'final double[] bLoEnc = encode(boundaries[0]); final double[] bHiEnc = encode(boundaries[1]); if (x[i] < bLoEnc[i]) { if (x[i] > bHiEnc[i]) {'], 'a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java']
['Math-19', 1, 1, 1, 1, ['boundaries[1] = uB; // Abort early if the normalization will overflow (cf. "encode" method). } } else { // Convert API to internal handling of boundaries.'], ['boundaries[1] = uB; // Abort early if the normalization will overflow (cf. "encode" method). for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } } } } else { // Convert API to internal handling of boundaries.'], [''], ['for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } }'], 'a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java']
['Math-20', 1, 1, 1, 1, ['* @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { return decode(x); }'], ['* @return the original objective variables, possibly repaired. */ public double[] repairAndDecode(final double[] x) { return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x); }'], ['return'], ['return boundaries != null && isRepairMode ? decode(repair(x)) :'], 'a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java']
['Math-21', 3, 3, 3, 3, ['final double[][] c = matrix.getData(); final double[][] b = new double[order][order]; int[] swap = new int[order]; int[] index = new int[order]; for (int i = 0; i < order; ++i) { index[i] = i;', 'for (boolean loop = true; loop;) { // find maximal diagonal element swap[r] = r; for (int i = r + 1; i < order; ++i) { int ii = index[i]; int isi = index[swap[i]]; if (c[ii][ii] > c[isi][isi]) { swap[r] = i; } } // swap elements if (swap[r] != r) { int tmp = index[r]; index[r] = index[swap[r]]; index[swap[r]] = tmp; } // check diagonal element', 'final double sqrt = FastMath.sqrt(c[ir][ir]); b[r][r] = sqrt; final double inverse = 1 / sqrt; for (int i = r + 1; i < order; ++i) { final int ii = index[i]; final double e = inverse * c[ii][ir]; b[i][r] = e; c[ii][ii] -= e * e; for (int j = r + 1; j < i; ++j) { final int ij = index[j]; final double f = c[ii][ij] - e * b[j][r];'], ['final double[][] c = matrix.getData(); final double[][] b = new double[order][order]; int[] index = new int[order]; for (int i = 0; i < order; ++i) { index[i] = i;', 'for (boolean loop = true; loop;) { // find maximal diagonal element int swapR = r; for (int i = r + 1; i < order; ++i) { int ii = index[i]; int isr = index[swapR]; if (c[ii][ii] > c[isr][isr]) { swapR = i; } } // swap elements if (swapR != r) { final int tmpIndex = index[r]; index[r] = index[swapR]; index[swapR] = tmpIndex; final double[] tmpRow = b[r]; b[r] = b[swapR]; b[swapR] = tmpRow; } // check diagonal element', 'final double sqrt = FastMath.sqrt(c[ir][ir]); b[r][r] = sqrt; final double inverse = 1 / sqrt; final double inverse2 = 1 / c[ir][ir]; for (int i = r + 1; i < order; ++i) { final int ii = index[i]; final double e = inverse * c[ii][ir]; b[i][r] = e; c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2; for (int j = r + 1; j < i; ++j) { final int ij = index[j]; final double f = c[ii][ij] - e * b[j][r];'], ['int[] swap = new int[order];', 'swap[r] = r; int isi = index[swap[i]]; if (c[ii][ii] > c[isi][isi]) { swap[r] = i; if (swap[r] != r) { int tmp = index[r]; index[r] = index[swap[r]]; index[swap[r]] = tmp;', 'c[ii][ii] -= e * e;'], ['', 'int swapR = r; int isr = index[swapR]; if (c[ii][ii] > c[isr][isr]) { swapR = i; if (swapR != r) { final int tmpIndex = index[r]; index[r] = index[swapR]; index[swapR] = tmpIndex; final double[] tmpRow = b[r]; b[r] = b[swapR]; b[swapR] = tmpRow;', 'final double inverse2 = 1 / c[ir][ir]; c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;'], 'a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java', 'b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java']
['Math-22', 2, 2, 2, 2, [' /** {@inheritDoc} */ public boolean isSupportLowerBoundInclusive() { return true; } /** {@inheritDoc} */', ' /** {@inheritDoc} */ public boolean isSupportUpperBoundInclusive() { return false; } /**'], [' /** {@inheritDoc} */ public boolean isSupportLowerBoundInclusive() { return false; } /** {@inheritDoc} */', ' /** {@inheritDoc} */ public boolean isSupportUpperBoundInclusive() { return true; } /**'], ['return true;', 'return false;'], ['return false;', 'return true;'], 'a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java', 'b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java']
['Math-23', 3, 3, 3, 3, ['UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx); // Best point encountered so far (which is the initial guess). int iter = 0; while (true) {', '// User-defined convergence checker. previous = current; current = new UnivariatePointValuePair(u, isMinim ? fu : -fu); if (checker != null) { if (checker.converged(iter, previous, current)) { return best(current, previous, isMinim); } }', "} } } else { // Default termination (Brent's criterion). return best(current, previous, isMinim); } ++iter;"], ['UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx); // Best point encountered so far (which is the initial guess). UnivariatePointValuePair best = current; int iter = 0; while (true) {', '// User-defined convergence checker. previous = current; current = new UnivariatePointValuePair(u, isMinim ? fu : -fu); best = best(best, best(current, previous, isMinim), isMinim); if (checker != null) { if (checker.converged(iter, previous, current)) { return best; } }', "} } } else { // Default termination (Brent's criterion). return best(best, best(current, previous, isMinim), isMinim); } ++iter;"], ['', 'return best(current, previous, isMinim);', 'return'], ['UnivariatePointValuePair best = current;', 'best = best(best, best(current, previous, isMinim), isMinim); return best;', 'return best(best, isMinim),'], 'a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java']
['Math-24', 2, 2, 2, 2, [' if (checker != null) { if (checker.converged(iter, previous, current)) { return current; } }', "} } } else { // Default termination (Brent's criterion). return current; } ++iter; }"], [' if (checker != null) { if (checker.converged(iter, previous, current)) { return best(current, previous, isMinim); } }', "} } } else { // Default termination (Brent's criterion). return best(current, previous, isMinim); } ++iter; }"], ['return current;', 'return current;'], ['return best(current, previous, isMinim);', 'return best(current, previous, isMinim);'], 'a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java', 'b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java']
['Math-25', 1, 1, 1, 1, ['} a = 0.5 * (yMax - yMin); } else { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. a = FastMath.sqrt(c1 / c2); omega = FastMath.sqrt(c2 / c3);'], ['} a = 0.5 * (yMax - yMin); } else { if (c2 == 0) { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); } a = FastMath.sqrt(c1 / c2); omega = FastMath.sqrt(c2 / c3);'], [''], ['if (c2 == 0) { throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); }'], 'a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java', 'b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java']
['Math-26', 2, 2, 2, 2, ['long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (a0 > overflow) { throw new FractionConversionException(value, a0, 1l); }', 'long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; if ((p2 > overflow) || (q2 > overflow)) { throw new FractionConversionException(value, p2, q2); }'], ['long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (FastMath.abs(a0) > overflow) { throw new FractionConversionException(value, a0, 1l); }', 'long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { throw new FractionConversionException(value, p2, q2); }'], ['if (a0 > overflow) {', 'if ((p2 > overflow) || (q2 > overflow)) {'], ['if (FastMath.abs(a0) > overflow) {', 'if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {'], 'a/src/main/java/org/apache/commons/math3/fraction/Fraction.java', 'b/src/main/java/org/apache/commons/math3/fraction/Fraction.java']
['Math-27', 1, 1, 1, 1, ['* @return the fraction percentage as a <tt>double</tt>. */ public double percentageValue() { return multiply(100).doubleValue(); } /**'], ['* @return the fraction percentage as a <tt>double</tt>. */ public double percentageValue() { return 100 * doubleValue(); } /**'], ['return multiply(100).doubleValue();'], ['return 100 * doubleValue();'], 'a/src/main/java/org/apache/commons/math3/fraction/Fraction.java', 'b/src/main/java/org/apache/commons/math3/fraction/Fraction.java']
['Math-28', 4, 4, 4, 4, ["// there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset();", "} } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index", '// Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) {', '} } return minRow; } return minRatioPositions.get(0); }'], ["// there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis if (tableau.getNumArtificialVariables() > 0) { for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset();", "} } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index", '// Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. if (getIterations() < getMaxIterations() / 2) { Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) {', '} } return minRow; } } return minRatioPositions.get(0); }'], ['', '', '', ''], ['if (tableau.getNumArtificialVariables() > 0) {', '}', 'if (getIterations() < getMaxIterations() / 2) {', '}'], 'a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java', 'b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java']
['Math-29', 2, 2, 2, 2, ['* this only. Indeed, if this[i] = 0d and v[i] = 0d, then * this[i] / v[i] = NaN, and not 0d. */ Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); } return res; }', '* * These special cases are handled below. */ return res; }'], ['* this only. Indeed, if this[i] = 0d and v[i] = 0d, then * this[i] / v[i] = NaN, and not 0d. */ final int n = getDimension(); for (int i = 0; i < n; i++) { res.setEntry(i, this.getEntry(i) / v.getEntry(i)); } return res; }', '* * These special cases are handled below. */ if (v.isNaN() || v.isInfinite()) { final int n = getDimension(); for (int i = 0; i < n; i++) { final double y = v.getEntry(i); if (Double.isNaN(y)) { res.setEntry(i, Double.NaN); } else if (Double.isInfinite(y)) { final double x = this.getEntry(i); res.setEntry(i, x * y); } } } return res; }'], ['Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));', ''], ['final int n = getDimension(); for (int i = 0; i < n; i++) { res.setEntry(i, this.getEntry(i) / v.getEntry(i));', 'if (v.isNaN() || v.isInfinite()) { final int n = getDimension(); for (int i = 0; i < n; i++) { final double y = v.getEntry(i); if (Double.isNaN(y)) { res.setEntry(i, Double.NaN); } else if (Double.isInfinite(y)) { final double x = this.getEntry(i); res.setEntry(i, x * y); } } }'], 'a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java', 'b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java']
['Math-30', 1, 1, 1, 1, ['final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0;'], ['final int n2) throws ConvergenceException, MaxCountExceededException { final double n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0;'], ['final int n1n2prod = n1 * n2;'], ['final double n1n2prod = n1 * n2;'], 'a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java', 'b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java']
['Math-31', 3, 3, 3, 3, [' int n = 1; double dPrev = 0.0; double p0 = 1.0; double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;', "final double a = getA(n, x); final double b = getB(n, x); double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) { // Can't scale throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); } for (int i = 0; i < maxPower; i++) { lastScaleFactor = scaleFactor; scaleFactor *= scale; if (a != 0.0 && a > b) { cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); } else if (b != 0) { cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; } if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { break; } } } final double deltaN = cN / q2 / cPrev; hN = cPrev * deltaN; if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,", 'break; } dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2; n++; }'], [' int n = 1; double dPrev = 0.0; double cPrev = hPrev; double hN = hPrev;', 'final double a = getA(n, x); final double b = getB(n, x); double dN = a + b * dPrev; if (Precision.equals(dN, 0.0, small)) { dN = small; } double cN = a + b / cPrev; if (Precision.equals(cN, 0.0, small)) { cN = small; } dN = 1 / dN; final double deltaN = cN * dN; hN = hPrev * deltaN; if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,', 'break; } dPrev = dN; cPrev = cN; hPrev = hN; n++; }'], ['double p0 = 1.0; double q1 = 1.0;', "double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) { // Can't scale throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); } for (int i = 0; i < maxPower; i++) { lastScaleFactor = scaleFactor; scaleFactor *= scale; if (a != 0.0 && a > b) { cN = hPrev / lastScaleFactor + (b / scaleFactor * p0); q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev); } else if (b != 0) { cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor; q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor; } if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) { break; } } final double deltaN = cN / q2 / cPrev; hN = cPrev * deltaN;", 'dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2;'], ['', 'double dN = a + b * dPrev; if (Precision.equals(dN, 0.0, small)) { dN = small; } double cN = a + b / cPrev; if (Precision.equals(cN, 0.0, small)) { cN = small; dN = 1 / dN; final double deltaN = cN * dN; hN = hPrev * deltaN;', 'dPrev = dN; cPrev = cN; hPrev = hN;'], 'a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java', 'b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java']
['Math-32', 1, 1, 1, 1, [' if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);'], [' if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); if (tree.getCut() == null && (Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN);'], ['if ((Boolean) tree.getAttribute()) {'], ['if (tree.getCut() == null && (Boolean) tree.getAttribute()) {'], 'a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java', 'b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java']
['Math-33', 1, 1, 1, 1, ['// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } }'], ['// positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, epsilon) > 0) { columnsToDrop.add(i); } }'], ['if (Precision.compareTo(entry, 0d, maxUlps) > 0) {'], ['if (Precision.compareTo(entry, 0d, epsilon) > 0) {'], 'a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java', 'b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java']
['Math-34', 1, 1, 1, 1, ['* @return chromosome iterator */ public Iterator<Chromosome> iterator() { return chromosomes.iterator(); } }'], ['* @return chromosome iterator */ public Iterator<Chromosome> iterator() { return getChromosomes().iterator(); } }'], ['return chromosomes.iterator();'], ['return getChromosomes().iterator();'], 'a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java', 'b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java']
['Math-35', 2, 2, 2, 2, ['final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); this.elitismRate = elitismRate; } /**', '*/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); this.elitismRate = elitismRate; } /**'], ['final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); setElitismRate(elitismRate); } /**', '*/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); setElitismRate(elitismRate); } /**'], ['this.elitismRate = elitismRate;', 'this.elitismRate = elitismRate;'], ['setElitismRate(elitismRate);', 'setElitismRate(elitismRate);'], 'a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java', 'b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java']
['Math-36', 2, 2, 2, 2, ['@Override public double doubleValue() { double result = numerator.doubleValue() / denominator.doubleValue(); // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. return result; }', '@Override public float floatValue() { float result = numerator.floatValue() / denominator.floatValue(); // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. return result; }'], ['@Override public double doubleValue() { double result = numerator.doubleValue() / denominator.doubleValue(); if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Double.MAX_EXPONENT; result = numerator.shiftRight(shift).doubleValue() / denominator.shiftRight(shift).doubleValue(); } return result; }', '@Override public float floatValue() { float result = numerator.floatValue() / denominator.floatValue(); if (Double.isNaN(result)) { // Numerator and/or denominator must be out of range: // Calculate how far to shift them to put them in range. int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Float.MAX_EXPONENT; result = numerator.shiftRight(shift).floatValue() / denominator.shiftRight(shift).floatValue(); } return result; }'], ['', ''], ['if (Double.isNaN(result)) { int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Double.MAX_EXPONENT; result = numerator.shiftRight(shift).doubleValue() / denominator.shiftRight(shift).doubleValue(); }', 'if (Double.isNaN(result)) { int shift = Math.max(numerator.bitLength(), denominator.bitLength()) - Float.MAX_EXPONENT; result = numerator.shiftRight(shift).floatValue() / denominator.shiftRight(shift).floatValue(); }'], 'a/src/main/java/org/apache/commons/math/fraction/BigFraction.java', 'b/src/main/java/org/apache/commons/math/fraction/BigFraction.java']
['Math-37', 2, 2, 2, 2, ['* @since 1.2 */ public Complex tan() { if (isNaN) { return NaN; } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary;', '* @since 1.2 */ public Complex tanh() { if (isNaN) { return NaN; } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);'], ['* @since 1.2 */ public Complex tan() { if (isNaN || Double.isInfinite(real)) { return NaN; } if (imaginary > 20.0) { return createComplex(0.0, 1.0); } if (imaginary < -20.0) { return createComplex(0.0, -1.0); } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary;', '* @since 1.2 */ public Complex tanh() { if (isNaN || Double.isInfinite(imaginary)) { return NaN; } if (real > 20.0) { return createComplex(1.0, 0.0); } if (real < -20.0) { return createComplex(-1.0, 0.0); } double real2 = 2.0 * real; double imaginary2 = 2.0 * imaginary; double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);'], ['if (isNaN) {', 'if (isNaN) {'], ['if (isNaN || Double.isInfinite(real)) { if (imaginary > 20.0) { return createComplex(0.0, 1.0); } if (imaginary < -20.0) { return createComplex(0.0, -1.0); }', 'if (isNaN || Double.isInfinite(imaginary)) { if (real > 20.0) { return createComplex(1.0, 0.0); } if (real < -20.0) { return createComplex(-1.0, 0.0); }'], 'a/src/main/java/org/apache/commons/math/complex/Complex.java', 'b/src/main/java/org/apache/commons/math/complex/Complex.java']
['Math-38', 2, 2, 2, 2, ['final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; throw new PathIsExploredException(); // XXX } final int iptMinus1 = ipt; final int jptMinus1 = jpt; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); }', 'final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim'], ['final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; // throw new PathIsExploredException(); // XXX } final int iptMinus1 = ipt - 1; final int jptMinus1 = jpt - 1; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); }', 'final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); // throw new PathIsExploredException(); // XXX } } while (getEvaluations() < npt); } // prelim'], ['throw new PathIsExploredException(); // XXX final int iptMinus1 = ipt; final int jptMinus1 = jpt;', 'throw new PathIsExploredException(); // XXX'], ['// throw new PathIsExploredException(); // XXX final int iptMinus1 = ipt - 1; final int jptMinus1 = jpt - 1;', '// throw new PathIsExploredException(); // XXX'], 'a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java']
['Math-39', 1, 1, 1, 1, ['} stepSize = hNew; // next stages for (int k = 1; k < stages; ++k) {'], ['} stepSize = hNew; if (forward) { if (stepStart + stepSize >= t) { stepSize = t - stepStart; } } else { if (stepStart + stepSize <= t) { stepSize = t - stepStart; } } // next stages for (int k = 1; k < stages; ++k) {'], [''], ['if (forward) { if (stepStart + stepSize >= t) { stepSize = t - stepStart; } } else { if (stepStart + stepSize <= t) { stepSize = t - stepStart; } }'], 'a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java', 'b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java']
['Math-40', 1, 1, 1, 1, ['double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this targetY = -REDUCTION_FACTOR * yA; } else { // bracketing is balanced, try to find the root itself targetY = 0;'], ['double targetY; if (agingA >= MAXIMAL_AGING) { // we keep updating the high bracket, try to compensate this final int p = agingA - MAXIMAL_AGING; final double weightA = (1 << p) - 1; final double weightB = p + 1; targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this final int p = agingB - MAXIMAL_AGING; final double weightA = p + 1; final double weightB = (1 << p) - 1; targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB); } else { // bracketing is balanced, try to find the root itself targetY = 0;'], ['targetY = -REDUCTION_FACTOR * yB; targetY = -REDUCTION_FACTOR * yA;'], ['final int p = agingA - MAXIMAL_AGING; final double weightA = (1 << p) - 1; final double weightB = p + 1; targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); final int p = agingB - MAXIMAL_AGING; final double weightA = p + 1; final double weightB = (1 << p) - 1; targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java']
['Math-41', 1, 1, 1, 1, ['} double sumWts = 0; for (int i = 0; i < weights.length; i++) { sumWts += weights[i]; }'], ['} double sumWts = 0; for (int i = begin; i < begin + length; i++) { sumWts += weights[i]; }'], ['for (int i = 0; i < weights.length; i++) {'], ['for (int i = begin; i < begin + length; i++) {'], 'a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java', 'b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java']
['Math-42', 1, 1, 1, 1, ['continue; } Integer basicRow = getBasicRow(colIndex); // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);'], ['continue; } Integer basicRow = getBasicRow(colIndex); if (basicRow != null && basicRow == 0) { // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function coefficients[i] = 0; } else if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);'], ['if (basicRows.contains(basicRow)) {'], ['if (basicRow != null && basicRow == 0) { coefficients[i] = 0; } else if (basicRows.contains(basicRow)) {'], 'a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java', 'b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java']
['Math-43', 1, 1, 1, 1, ['secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these if (!(meanImpl instanceof Mean)) { meanImpl.increment(value); } if (!(varianceImpl instanceof Variance)) { varianceImpl.increment(value); } if (!(geoMeanImpl instanceof GeometricMean)) { geoMeanImpl.increment(value); } n++;'], ['secondMoment.increment(value); // If mean, variance or geomean have been overridden, // need to increment these if (meanImpl != mean) { meanImpl.increment(value); } if (varianceImpl != variance) { varianceImpl.increment(value); } if (geoMeanImpl != geoMean) { geoMeanImpl.increment(value); } n++;'], ['if (!(meanImpl instanceof Mean)) { if (!(varianceImpl instanceof Variance)) { if (!(geoMeanImpl instanceof GeometricMean)) {'], ['if (meanImpl != mean) { if (varianceImpl != variance) { if (geoMeanImpl != geoMean) {'], 'a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java', 'b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java']
['Math-44', 3, 3, 3, 3, [' double previousT = interpolator.getGlobalPreviousTime(); final double currentT = interpolator.getGlobalCurrentTime(); resetOccurred = false; // initialize the events states if needed if (! statesInitialized) {', 'if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); return eventT; }', 'System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; return eventT; }'], [' double previousT = interpolator.getGlobalPreviousTime(); final double currentT = interpolator.getGlobalCurrentTime(); // initialize the events states if needed if (! statesInitialized) {', 'if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; }', 'System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; }'], ['resetOccurred = false;', '', ''], ['', 'for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }', 'for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }'], 'a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java', 'b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java']
['Math-45', 1, 1, 1, 1, ['*/ public OpenMapRealMatrix(int rowDimension, int columnDimension) { super(rowDimension, columnDimension); this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0);'], ['*/ public OpenMapRealMatrix(int rowDimension, int columnDimension) { super(rowDimension, columnDimension); long lRow = (long) rowDimension; long lCol = (long) columnDimension; if (lRow * lCol >= (long) Integer.MAX_VALUE) { throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); } this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0);'], [''], ['long lRow = (long) rowDimension; long lCol = (long) columnDimension; if (lRow * lCol >= (long) Integer.MAX_VALUE) { throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); }'], 'a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java', 'b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java']
['Math-46', 2, 2, 2, 2, [' if (divisor.isZero) { // return isZero ? NaN : INF; // See MATH-657 return isZero ? NaN : INF; } if (divisor.isInfinite() && !isInfinite()) {', '} if (divisor == 0d) { // return isZero ? NaN : INF; // See MATH-657 return isZero ? NaN : INF; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;'], [' if (divisor.isZero) { // return isZero ? NaN : INF; // See MATH-657 return NaN; } if (divisor.isInfinite() && !isInfinite()) {', '} if (divisor == 0d) { // return isZero ? NaN : INF; // See MATH-657 return NaN; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;'], ['return isZero ? NaN : INF;', 'return isZero ? NaN : INF;'], ['return NaN;', 'return NaN;'], 'a/src/main/java/org/apache/commons/math/complex/Complex.java', 'b/src/main/java/org/apache/commons/math/complex/Complex.java']
['Math-47', 4, 4, 4, 4, ['/** Record whether this complex number is infinite. */ private final transient boolean isInfinite; /** Record whether this complex number is zero. */ /** * Create a complex number given only the real part.', 'isNaN = Double.isNaN(real) || Double.isNaN(imaginary); isInfinite = !isNaN && (Double.isInfinite(real) || Double.isInfinite(imaginary)); } /**', 'return NaN; } if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) { return NaN; } if (divisor.isInfinite() && !isInfinite()) {', 'return NaN; } if (divisor == 0d) { return NaN; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;'], ['/** Record whether this complex number is infinite. */ private final transient boolean isInfinite; /** Record whether this complex number is zero. */ private final transient boolean isZero; /** * Create a complex number given only the real part.', 'isNaN = Double.isNaN(real) || Double.isNaN(imaginary); isInfinite = !isNaN && (Double.isInfinite(real) || Double.isInfinite(imaginary)); isZero = real == 0 && imaginary == 0; } /**', 'return NaN; } if (divisor.isZero) { return isZero ? NaN : INF; } if (divisor.isInfinite() && !isInfinite()) {', 'return NaN; } if (divisor == 0d) { return isZero ? NaN : INF; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN;'], ['', '', 'if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) { return NaN;', 'return NaN;'], ['private final transient boolean isZero;', 'isZero = real == 0 && imaginary == 0;', 'if (divisor.isZero) { return isZero ? NaN : INF;', 'return isZero ? NaN : INF;'], 'a/src/main/java/org/apache/commons/math/complex/Complex.java', 'b/src/main/java/org/apache/commons/math/complex/Complex.java']
['Math-48', 1, 1, 1, 1, ['case REGULA_FALSI: // Detect early that algorithm is stuck, instead of waiting // for the maximum number of iterations to be exceeded. break; default: // Should never happen.'], ['case REGULA_FALSI: // Detect early that algorithm is stuck, instead of waiting // for the maximum number of iterations to be exceeded. if (x == x1) { throw new ConvergenceException(); } break; default: // Should never happen.'], [''], ['if (x == x1) { throw new ConvergenceException(); }'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java']
['Math-49', 4, 4, 4, 4, ['public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));', 'public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]);', 'public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));', 'public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]);'], ['public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));', 'public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]);', 'public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));', 'public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]);'], ['Iterator iter = res.entries.iterator();', 'Iterator iter = res.entries.iterator();', 'Iterator iter = res.entries.iterator();', 'Iterator iter = res.entries.iterator();'], ['Iterator iter = entries.iterator();', 'Iterator iter = entries.iterator();', 'Iterator iter = entries.iterator();', 'Iterator iter = entries.iterator();'], 'a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java', 'b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java']
['Math-50', 1, 1, 1, 1, ['break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen.'], ['break; case REGULA_FALSI: // Nothing. break; default: // Should never happen.'], ['if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }'], [''], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java']
['Math-51', 1, 1, 1, 1, ['case PEGASUS: f0 *= f1 / (f1 + fx); break; // Update formula cannot make any progress: Update the // search interval. default: // Should never happen. } } // Update from [x0, x1] to [x0, x].'], ['case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: if (x == x1) { final double delta = FastMath.max(rtol * FastMath.abs(x1), atol); // Update formula cannot make any progress: Update the // search interval. x0 = 0.5 * (x0 + x1 - delta); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x].'], [''], ['case REGULA_FALSI: if (x == x1) { final double delta = FastMath.max(rtol * FastMath.abs(x1), atol); x0 = 0.5 * (x0 + x1 - delta); f0 = computeObjectiveValue(x0); } break; throw new MathInternalError();'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java']
['Math-52', 2, 2, 2, 2, ['Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3 = u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2);', 'Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c == 0) { // the (q1, q2, q3) vector is aligned with everything // this is really the identity rotation q0 = 1.0;'], ['Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3 = u1.crossProduct(u2); double c = k.dotProduct(u3); final double inPlaneThreshold = 0.001; if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2);', 'Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c <= 0) { // the (q1, q2, q3) vector is aligned with everything // this is really the identity rotation q0 = 1.0;'], ['if (c == 0) {', 'if (c == 0) { if (c == 0) {'], ['final double inPlaneThreshold = 0.001; if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {', 'if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { if (c <= 0) {'], 'a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java', 'b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java']
['Math-53', 1, 1, 1, 1, ['public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }'], ['public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); if (isNaN || rhs.isNaN) { return NaN; } return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }'], [''], ['if (isNaN || rhs.isNaN) { return NaN; }'], 'a/src/main/java/org/apache/commons/math/complex/Complex.java', 'b/src/main/java/org/apache/commons/math/complex/Complex.java']
['Math-54', 2, 2, 2, 2, ['// Zero or sub-normal if (x == 0) { // make sure 0 has the right sign return; }', ' Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; }'], ['// Zero or sub-normal if (x == 0) { // make sure 0 has the right sign if ((bits & 0x8000000000000000L) != 0) { sign = -1; } return; }', ' Dfp y = this; boolean negate = false; int cmp0 = compare(this, getZero()); if (cmp0 == 0) { return sign < 0 ? -0.0 : +0.0; } else if (cmp0 < 0) { y = negate(); negate = true; }'], ['', 'if (lessThan(getZero())) {'], ['if ((bits & 0x8000000000000000L) != 0) { sign = -1; }', 'int cmp0 = compare(this, getZero()); if (cmp0 == 0) { return sign < 0 ? -0.0 : +0.0; } else if (cmp0 < 0) {'], 'a/src/main/java/org/apache/commons/math/dfp/Dfp.java', 'b/src/main/java/org/apache/commons/math/dfp/Dfp.java']
['Math-55', 2, 2, 2, 2, ['*/ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) { // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute', '// available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf // compute rho as an 8 bits approximation of v1.v2 / v2.v2 // compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); }'], ['*/ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) { final double n1 = v1.getNormSq(); final double n2 = v2.getNormSq(); if ((n1 * n2) < MathUtils.SAFE_MIN) { return ZERO; } // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; final double x1 = FastMath.scalb(v1.x, -deltaExp); final double y1 = FastMath.scalb(v1.y, -deltaExp); final double z1 = FastMath.scalb(v1.z, -deltaExp); final double x2 = FastMath.scalb(v2.x, deltaExp); final double y2 = FastMath.scalb(v2.y, deltaExp); final double z2 = FastMath.scalb(v2.z, deltaExp); // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute', '// available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf // compute rho as an 8 bits approximation of v1.v2 / v2.v2 final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); final double rho = FastMath.rint(256 * ratio) / 256; final double x3 = x1 - rho * x2; final double y3 = y1 - rho * y2; final double z3 = z1 - rho * z2; // compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2); }'], ['', 'return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);'], ['final double n1 = v1.getNormSq(); final double n2 = v2.getNormSq(); if ((n1 * n2) < MathUtils.SAFE_MIN) { return ZERO; } final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; final double x1 = FastMath.scalb(v1.x, -deltaExp); final double y1 = FastMath.scalb(v1.y, -deltaExp); final double z1 = FastMath.scalb(v1.z, -deltaExp); final double x2 = FastMath.scalb(v2.x, deltaExp); final double y2 = FastMath.scalb(v2.y, deltaExp); final double z2 = FastMath.scalb(v2.z, deltaExp);', 'final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); final double rho = FastMath.rint(256 * ratio) / 256; final double x3 = x1 - rho * x2; final double y3 = y1 - rho * y2; final double z3 = z1 - rho * z2; return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);'], 'a/src/main/java/org/apache/commons/math/geometry/Vector3D.java', 'b/src/main/java/org/apache/commons/math/geometry/Vector3D.java']
['Math-56', 1, 1, 1, 1, ['indices[i] = idx; } int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; return indices; }'], ['indices[i] = idx; } indices[last] = index - count; return indices; }'], ['int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;'], ['indices[last] = index - count;'], 'a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java', 'b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java']
['Math-57', 1, 1, 1, 1, ['while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. int sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p);'], ['while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p);'], ['int sum = 0;'], ['double sum = 0;'], 'a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java', 'b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java']
['Math-58', 1, 1, 1, 1, ['*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); return fit(new Gaussian.Parametric(), guess); } /**'], ['*/ public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); return fit(guess); } /**'], ['return fit(new Gaussian.Parametric(), guess);'], ['return fit(guess);'], 'a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java', 'b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java']
['Math-59', 1, 1, 1, 1, ['* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); } /** Compute the maximum of two values'], ['* @return b if a is lesser or equal to b, a otherwise */ public static float max(final float a, final float b) { return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); } /** Compute the maximum of two values'], ['return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);'], ['return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);'], 'a/src/main/java/org/apache/commons/math/util/FastMath.java', 'b/src/main/java/org/apache/commons/math/util/FastMath.java']
['Math-60', 1, 1, 1, 1, ['*/ public double cumulativeProbability(double x) throws MathException { final double dev = x - mean; try { return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } } } /**'], ['*/ public double cumulativeProbability(double x) throws MathException { final double dev = x - mean; if (FastMath.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; } return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } /**'], ['try { } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } }'], ['if (FastMath.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; }'], 'a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java', 'b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java']
['Math-61', 2, 2, 2, 2, ['import java.io.Serializable; import org.apache.commons.math.MathException; import org.apache.commons.math.MathRuntimeException; import org.apache.commons.math.exception.util.LocalizedFormats; import org.apache.commons.math.special.Gamma; import org.apache.commons.math.util.MathUtils;', '*/ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p));'], ['import java.io.Serializable; import org.apache.commons.math.MathException; import org.apache.commons.math.exception.NotStrictlyPositiveException; import org.apache.commons.math.exception.util.LocalizedFormats; import org.apache.commons.math.special.Gamma; import org.apache.commons.math.util.MathUtils;', '*/ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p));'], ['import org.apache.commons.math.MathRuntimeException;', 'throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);'], ['import org.apache.commons.math.exception.NotStrictlyPositiveException;', 'throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);'], 'a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java', 'b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java']
['Math-62', 2, 2, 2, 2, ['final GoalType goal, final double min, final double max) throws FunctionEvaluationException { return optimize(f, goal, min, max, 0); } /** {@inheritDoc} */', '// Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {'], ['final GoalType goal, final double min, final double max) throws FunctionEvaluationException { return optimize(f, goal, min, max, min + 0.5 * (max - min)); } /** {@inheritDoc} */', '// Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, min, max, s); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) {'], ['return optimize(f, goal, min, max, 0);', 'final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));'], ['return optimize(f, goal, min, max, min + 0.5 * (max - min));', 'final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, min, max, s);'], 'a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java']
['Math-63', 1, 1, 1, 1, ['* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { return (Double.isNaN(x) && Double.isNaN(y)) || x == y; } /**'], ['* @return {@code true} if the values are equal. */ public static boolean equals(double x, double y) { return equals(x, y, 1); } /**'], ['return (Double.isNaN(x) && Double.isNaN(y)) || x == y;'], ['return equals(x, y, 1);'], 'a/src/main/java/org/apache/commons/math/util/MathUtils.java', 'b/src/main/java/org/apache/commons/math/util/MathUtils.java']
['Math-64', 10, 10, 10, 10, ['double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols];', 'boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix', "qrDecomposition(); // compute Qt.res qTy(residuals); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) {", 'if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); }', '} if (maxCosine <= orthoTolerance) { // convergence has been reached return current; }', 'double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; // determine the Levenberg-Marquardt parameter determineLMParameter(oldRes, delta, diag, work1, work2, work3); // compute the new point and the norm of the evolution direction double lmNorm = 0;', ' // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); // compute the scaled actual reduction double actRed = -1.0;', 'xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); // tests for convergence. // we use the vectorial convergence checker } else { // failed iteration, reset the previous values cost = previousCost;', 'tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) &&', '(delta <= parRelativeTolerance * xNorm)) { return current; } } else { if (checker.converged(getIterations(), previous, current)) { return current; } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)'], ['double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] oldObj = new double[rows]; double[] qtf = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols];', 'boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { for (int i=0;i<rows;i++) { qtf[i]=residuals[i]; } incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix', "qrDecomposition(); // compute Qt.res qTy(qtf); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) {", 'if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qtf[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); }', '} if (maxCosine <= orthoTolerance) { // convergence has been reached updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); return current; }', 'double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; tmpVec = objective; objective = oldObj; oldObj = tmpVec; // determine the Levenberg-Marquardt parameter determineLMParameter(qtf, delta, diag, work1, work2, work3); // compute the new point and the norm of the evolution direction double lmNorm = 0;', ' // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); // compute the scaled actual reduction double actRed = -1.0;', 'xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); current = new VectorialPointValuePair(point, objective); // tests for convergence. if (checker != null) { // we use the vectorial convergence checker if (checker.converged(getIterations(), previous, current)) { return current; } } } else { // failed iteration, reset the previous values cost = previousCost;', 'tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; tmpVec = objective; objective = oldObj; oldObj = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) &&', '(delta <= parRelativeTolerance * xNorm)) { return current; } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)'], ['', '', 'qTy(residuals);', 'sum += jacobian[i][pj] * residuals[i];', '', 'determineLMParameter(oldRes, delta, diag, work1, work2, work3);', 'current = new VectorialPointValuePair(point, objective);', '', '', '} else { if (checker.converged(getIterations(), previous, current)) { return current; }'], ['double[] oldObj = new double[rows]; double[] qtf = new double[rows];', 'for (int i=0;i<rows;i++) { qtf[i]=residuals[i]; }', 'qTy(qtf);', 'sum += jacobian[i][pj] * qtf[i];', 'updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective);', 'tmpVec = objective; objective = oldObj; oldObj = tmpVec; determineLMParameter(qtf, delta, diag, work1, work2, work3);', '', 'current = new VectorialPointValuePair(point, objective); if (checker != null) { if (checker.converged(getIterations(), previous, current)) { return current; } }', 'tmpVec = objective; objective = oldObj; oldObj = tmpVec;', ''], 'a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java']
['Math-65', 2, 2, 2, 2, ['* @return RMS value */ public double getRMS() { double criterion = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; criterion += residual * residual * residualsWeights[i]; } return Math.sqrt(criterion / rows); } /**', 'double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; chiSquare += residual * residual / residualsWeights[i]; } return chiSquare; }'], ['* @return RMS value */ public double getRMS() { return Math.sqrt(getChiSquare() / rows); } /**', 'double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; }'], ['double criterion = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; criterion += residual * residual * residualsWeights[i]; } return Math.sqrt(criterion / rows);', 'chiSquare += residual * residual / residualsWeights[i];'], ['return Math.sqrt(getChiSquare() / rows);', 'chiSquare += residual * residual * residualsWeights[i];'], 'a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java']
['Math-66', 6, 6, 6, 6, ['* Construct a solver. */ public BrentOptimizer() { setMaxEvaluations(Integer.MAX_VALUE); setMaximalIterationCount(100); setAbsoluteAccuracy(1E-10); setRelativeAccuracy(1.0e-14); } /**', '*/ protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException { throw new UnsupportedOperationException(); } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); return localMin(getGoalType() == GoalType.MINIMIZE, f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy()); } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException { return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min)); } /** * Find the minimum of the function within the interval {@code (lo, hi)}.', '* the function. */ private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {', 'double w = x; double d = 0; double e = 0; double fx = computeObjectiveValue(f, x); if (goalType == GoalType.MAXIMIZE) { fx = -fx; } double fv = fx; double fw = fx; int count = 0; while (count < maximalIterationCount) { double m = 0.5 * (a + b); final double tol1 = eps * Math.abs(x) + t; final double tol2 = 2 * tol1;', 'u = x + d; } double fu = computeObjectiveValue(f, u); if (goalType == GoalType.MAXIMIZE) { fu = -fu; }', '} } } else { // termination setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count); return x; } ++count; } throw new MaxIterationsExceededException(maximalIterationCount); } }'], ['* Construct a solver. */ public BrentOptimizer() { setMaxEvaluations(1000); setMaximalIterationCount(100); setAbsoluteAccuracy(1e-11); setRelativeAccuracy(1e-9); } /**', '*/ protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException { return localMin(getGoalType() == GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy()); } /** * Find the minimum of the function within the interval {@code (lo, hi)}.', '* the function. */ private double localMin(boolean isMinim, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {', 'double w = x; double d = 0; double e = 0; double fx = computeObjectiveValue(x); if (!isMinim) { fx = -fx; } double fv = fx; double fw = fx; while (true) { double m = 0.5 * (a + b); final double tol1 = eps * Math.abs(x) + t; final double tol2 = 2 * tol1;', 'u = x + d; } double fu = computeObjectiveValue(u); if (!isMinim) { fu = -fu; }', '} } } else { // termination setFunctionValue(isMinim ? fx : -fx); return x; } incrementIterationsCounter(); } } }'], ['setMaxEvaluations(Integer.MAX_VALUE); setAbsoluteAccuracy(1E-10); setRelativeAccuracy(1.0e-14);', 'throw new UnsupportedOperationException(); } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); f, goalType, min, startValue, max, public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException { return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min)); }', 'UnivariateRealFunction f, GoalType goalType,', 'double fx = computeObjectiveValue(f, x); if (goalType == GoalType.MAXIMIZE) { int count = 0; while (count < maximalIterationCount) {', 'double fu = computeObjectiveValue(f, u); if (goalType == GoalType.MAXIMIZE) {', 'setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count); ++count; throw new MaxIterationsExceededException(maximalIterationCount);'], ['setMaxEvaluations(1000); setAbsoluteAccuracy(1e-11); setRelativeAccuracy(1e-9);', 'getMin(), getStartValue(), getMax(),', '', 'double fx = computeObjectiveValue(x); if (!isMinim) { while (true) {', 'double fu = computeObjectiveValue(u); if (!isMinim) {', 'setFunctionValue(isMinim ? fx : -fx); incrementIterationsCounter();'], 'a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java']
['Math-67', 1, 1, 1, 1, [' /** {@inheritDoc} */ public double getFunctionValue() { return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return optimizer.getResult(); } /** {@inheritDoc} */'], [' /** {@inheritDoc} */ public double getFunctionValue() { return optimaValues[0]; } /** {@inheritDoc} */ public double getResult() { return optima[0]; } /** {@inheritDoc} */'], ['return optimizer.getFunctionValue(); return optimizer.getResult();'], ['return optimaValues[0]; return optima[0];'], 'a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java']
['Math-68', 5, 5, 5, 5, ['setMaxIterations(1000); // default values for the tuning parameters setInitialStepBoundFactor(100.0); setCostRelativeTolerance(1.0e-10); setParRelativeTolerance(1.0e-10);', '// outer loop lmPar = 0; boolean firstIteration = true; while (true) { incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix updateJacobian(); qrDecomposition();', '} if (maxCosine <= orthoTolerance) { // convergence has been reached return new VectorialPointValuePair(point, objective); } // rescale if necessary', ' // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); // compute the scaled actual reduction double actRed = -1.0;', '} // tests for convergence. // we use the vectorial convergence checker // we use the Levenberg-Marquardt specific convergence parameters if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return new VectorialPointValuePair(point, objective); } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)'], ['setMaxIterations(1000); // default values for the tuning parameters setConvergenceChecker(null); setInitialStepBoundFactor(100.0); setCostRelativeTolerance(1.0e-10); setParRelativeTolerance(1.0e-10);', '// outer loop lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition();', '} if (maxCosine <= orthoTolerance) { // convergence has been reached return current; } // rescale if necessary', ' // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); // compute the scaled actual reduction double actRed = -1.0;', '} // tests for convergence. if (checker != null) { // we use the vectorial convergence checker if (checker.converged(getIterations(), previous, current)) { return current; } } else { // we use the Levenberg-Marquardt specific convergence parameters if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return current; } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754)'], ['', '', 'return new VectorialPointValuePair(point, objective);', '', 'return new VectorialPointValuePair(point, objective);'], ['setConvergenceChecker(null);', 'VectorialPointValuePair current = new VectorialPointValuePair(point, objective); VectorialPointValuePair previous = current;', 'return current;', 'current = new VectorialPointValuePair(point, objective);', 'if (checker != null) { if (checker.converged(getIterations(), previous, current)) { return current; } } else { return current; }'], 'a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java', 'b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java']
['Math-69', 1, 1, 1, 1, ['} else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); } } }'], ['} else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); out[i][j] = 2 * tDistribution.cumulativeProbability(-t); } } }'], ['out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));'], ['out[i][j] = 2 * tDistribution.cumulativeProbability(-t);'], 'a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java', 'b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java']
['Math-70', 1, 1, 1, 1, ['/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); } /** {@inheritDoc} */'], ['/** {@inheritDoc} */ public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(f, min, max); } /** {@inheritDoc} */'], ['return solve(min, max);'], ['return solve(f, min, max);'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java']
['Math-71', 2, 2, 2, 2, ['// it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states loop = false; } else { // reject the step to match exactly the next switch time', '// it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states loop = false; } else { // reject the step to match exactly the next switch time'], ['// it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { // reject the step to match exactly the next switch time', '// it is so small (much probably exactly 0 due to limited accuracy) // that the code above would fail handling it. // So we set up an artificial 0 size step by copying states interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); stepSize = 0; loop = false; } else { // reject the step to match exactly the next switch time'], ['', ''], ['interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0;', 'interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); stepSize = 0;'], 'a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java', 'b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java']
['Math-72', 2, 2, 2, 2, ['// return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; }', '// return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; }'], ['// return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); return result; }', '// return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); return result; }'], ['setResult(yMin, 0);', 'setResult(yMax, 0);'], ['setResult(min, 0);', 'setResult(max, 0);'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java']
['Math-73', 1, 1, 1, 1, ['return solve(f, initial, yInitial, max, yMax, initial, yInitial); } // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);'], ['return solve(f, initial, yInitial, max, yMax, initial, yInitial); } if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( NON_BRACKETING_MESSAGE, min, max, yMin, yMax); } // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial);'], [''], ['if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( NON_BRACKETING_MESSAGE, min, max, yMin, yMax); }'], 'a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java', 'b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java']
['Math-74', 1, 1, 1, 1, ['} if (firstTime) { final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance; } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);'], ['} if (firstTime) { final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);'], ['final double[] scale; scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); scale = vecAbsoluteTolerance;'], ['final double[] scale = new double[y0.length]; for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); }'], 'a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java', 'b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java']
['Math-75', 1, 1, 1, 1, ['*/ @Deprecated public double getPct(Object v) { return getCumPct((Comparable<?>) v); } /**'], ['*/ @Deprecated public double getPct(Object v) { return getPct((Comparable<?>) v); } /**'], ['return getCumPct((Comparable<?>) v);'], ['return getPct((Comparable<?>) v);'], 'a/src/main/java/org/apache/commons/math/stat/Frequency.java', 'b/src/main/java/org/apache/commons/math/stat/Frequency.java']
['Math-76', 2, 2, 2, 2, ['if (m >= n) { // the tridiagonal matrix is Bt.B, where B is upper bidiagonal final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[m][p]; double[] ei1 = eData[0]; for (int i = 0; i < p - 1; ++i) { // compute W = B.E.S^(-1) where E is the eigenvectors matrix final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi = wData[i]; ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } } for (int j = 0; j < p; ++j) { wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; } for (int i = p; i < m; ++i) { wData[i] = new double[p];', '// the tridiagonal matrix is B.Bt, where B is lower bidiagonal // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[n][p]; double[] ei1 = eData[0]; for (int i = 0; i < p - 1; ++i) { final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi = wData[i]; ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } } for (int j = 0; j < p; ++j) { wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j]; } for (int i = p; i < n; ++i) { wData[i] = new double[p]; }'], ['if (m >= n) { // the tridiagonal matrix is Bt.B, where B is upper bidiagonal final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[m][p]; double[] ei1 = eData[0]; for (int i = 0; i < p; ++i) { // compute W = B.E.S^(-1) where E is the eigenvectors matrix final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi = wData[i]; if (i < n - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } } else { for (int j = 0; j < p; ++j) { wi[j] = mi * ei0[j] / singularValues[j]; } } } for (int i = p; i < m; ++i) { wData[i] = new double[p];', '// the tridiagonal matrix is B.Bt, where B is lower bidiagonal // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[n][p]; double[] ei1 = eData[0]; for (int i = 0; i < p; ++i) { final double mi = mainBidiagonal[i]; final double[] ei0 = ei1; final double[] wi = wData[i]; if (i < m - 1) { ei1 = eData[i + 1]; final double si = secondaryBidiagonal[i]; for (int j = 0; j < p; ++j) { wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j]; } } else { for (int j = 0; j < p; ++j) { wi[j] = mi * ei0[j] / singularValues[j]; } } } for (int i = p; i < n; ++i) { wData[i] = new double[p]; }'], ['eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); for (int i = 0; i < p - 1; ++i) { } wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];', 'eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); for (int i = 0; i < p - 1; ++i) { } wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];'], ['eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1); for (int i = 0; i < p; ++i) { if (i < n - 1) { } else { wi[j] = mi * ei0[j] / singularValues[j]; } }', 'eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1); for (int i = 0; i < p; ++i) { if (i < m - 1) { } else { wi[j] = mi * ei0[j] / singularValues[j]; } }'], 'a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java', 'b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java']
['Math-77', 2, 2, 2, 2, ['public double getLInfNorm() { double max = 0; for (double a : data) { max += Math.max(max, Math.abs(a)); } return max; }', 'return max; } public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; } /** * Optimized method to compute LInfDistance. * @param v The vector to compute from'], ['public double getLInfNorm() { double max = 0; for (double a : data) { max = Math.max(max, Math.abs(a)); } return max; }', 'return max; } /** * Optimized method to compute LInfDistance. * @param v The vector to compute from'], ['max += Math.max(max, Math.abs(a));', 'public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; }'], ['max = Math.max(max, Math.abs(a));', ''], 'a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java', 'b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java']
['Math-78', 2, 2, 2, 2, ['if (g0Positive ^ (gb >= 0)) { // there is a sign change: an event is expected during this step // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb', "// this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing // this should never happen // variation direction, with respect to the integration direction increasing = gb >= ga;"], ['if (g0Positive ^ (gb >= 0)) { // there is a sign change: an event is expected during this step if (ga * gb > 0) { // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb', "// this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing final double epsilon = (forward ? 0.25 : -0.25) * convergence; for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { ta += epsilon; interpolator.setInterpolatedTime(ta); ga = handler.g(ta, interpolator.getInterpolatedState()); } if (ga * gb > 0) { // this should never happen throw MathRuntimeException.createInternalError(null); } } // variation direction, with respect to the integration direction increasing = gb >= ga;"], ['', ''], ['if (ga * gb > 0) {', 'final double epsilon = (forward ? 0.25 : -0.25) * convergence; for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { ta += epsilon; interpolator.setInterpolatedTime(ta); ga = handler.g(ta, interpolator.getInterpolatedState()); } if (ga * gb > 0) { throw MathRuntimeException.createInternalError(null); } }'], 'a/src/main/java/org/apache/commons/math/ode/events/EventState.java', 'b/src/main/java/org/apache/commons/math/ode/events/EventState.java']
['Math-79', 1, 1, 1, 1, ['* @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);'], ['* @return the L<sub>2</sub> distance between the two points */ public static double distance(int[] p1, int[] p2) { double sum = 0; for (int i = 0; i < p1.length; i++) { final double dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum);'], ['int sum = 0; final int dp = p1[i] - p2[i];'], ['double sum = 0; final double dp = p1[i] - p2[i];'], 'a/src/main/java/org/apache/commons/math/util/MathUtils.java', 'b/src/main/java/org/apache/commons/math/util/MathUtils.java']
['Math-80', 1, 1, 1, 1, ['private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];'], ['private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];'], ['int j = 4 * n - 1;'], ['int j = 4 * (n - 1);'], 'a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java', 'b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java']
['Math-81', 3, 3, 3, 3, ['lowerSpectra = Math.min(lowerSpectra, lower); final double upper = dCurrent + eCurrent; work[upperStart + m - 1] = upper; minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax); }', 'diagMax = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) && (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2] = -sigma;', 'double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {'], ['lowerSpectra = Math.min(lowerSpectra, lower); final double upper = dCurrent + eCurrent; work[upperStart + m - 1] = upper; upperSpectra = Math.max(upperSpectra, upper); minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax); }', 'diagMax = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2] = -sigma;', 'double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 3) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {'], ['', 'for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&', 'if (end - start > 2) {'], ['upperSpectra = Math.max(upperSpectra, upper);', 'for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||', 'if (end - start > 3) {'], 'a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java', 'b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java']
['Math-82', 1, 1, 1, 1, ['for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;'], ['for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) > 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio;'], ['if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {'], ['if (MathUtils.compareTo(entry, 0, epsilon) > 0) {'], 'a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java', 'b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java']
['Math-83', 2, 2, 2, 2, ['*/ private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) { Integer row = null; int start = getNumObjectiveFunctions(); for (int i = start; i < getHeight(); i++) { if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i;', '*/ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0'], ['*/ private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) { Integer row = null; int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0; for (int i = start; i < getHeight(); i++) { if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i;', '*/ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0'], ['int start = getNumObjectiveFunctions();', 'Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);'], ['int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;', 'Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset()); Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);'], 'a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java', 'b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java']
['Math-84', 2, 2, 2, 2, ['protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { while (true) { incrementIterationsCounter();', 'final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex // check convergence return; }'], ['protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { final RealConvergenceChecker checker = getConvergenceChecker(); while (true) { incrementIterationsCounter();', 'final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex return; } // check convergence final int iter = getIterations(); boolean converged = true; for (int i = 0; i < simplex.length; ++i) { converged &= checker.converged(iter, original[i], simplex[i]); } if (converged) { return; }'], ['', ''], ['final RealConvergenceChecker checker = getConvergenceChecker();', 'return; } final int iter = getIterations(); boolean converged = true; for (int i = 0; i < simplex.length; ++i) { converged &= checker.converged(iter, original[i], simplex[i]); } if (converged) {'], 'a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java', 'b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java']
['Math-85', 1, 1, 1, 1, ['} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( "number of iterations={0}, maximum iterations={1}, " + "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +'], ['} while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb > 0.0 ) { throw new ConvergenceException( "number of iterations={0}, maximum iterations={1}, " + "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +'], ['if (fa * fb >= 0.0 ) {'], ['if (fa * fb > 0.0 ) {'], 'a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java', 'b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java']
['Math-86', 2, 2, 2, 2, [' final double[] lI = lTData[i]; if (lTData[i][i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); } // check off-diagonal elements (and reset them to 0) for (int j = i + 1; j < order; ++j) { final double[] lJ = lTData[j];', 'final double[] ltI = lTData[i]; // check diagonal element ltI[i] = Math.sqrt(ltI[i]); final double inverse = 1.0 / ltI[i];'], [' final double[] lI = lTData[i]; // check off-diagonal elements (and reset them to 0) for (int j = i + 1; j < order; ++j) { final double[] lJ = lTData[j];', 'final double[] ltI = lTData[i]; // check diagonal element if (ltI[i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); } ltI[i] = Math.sqrt(ltI[i]); final double inverse = 1.0 / ltI[i];'], ['if (lTData[i][i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); }', ''], ['', 'if (ltI[i] < absolutePositivityThreshold) { throw new NotPositiveDefiniteMatrixException(); }'], 'a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java', 'b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java']
['Math-87', 1, 1, 1, 1, ['private Integer getBasicRow(final int col) { Integer row = null; for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) { if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { row = i; } else { return null; } } } return row;'], ['private Integer getBasicRow(final int col) { Integer row = null; for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) { if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { return null; } } return row;'], ['if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { } else { }'], ['if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {'], 'a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java', 'b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java']
['Math-88', 1, 1, 1, 1, ['Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables()); double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } } } } return new RealPointValuePair(coefficients, f.getValue(coefficients));'], ['Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables()); double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0; } else { basicRows.add(basicRow); coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); } } return new RealPointValuePair(coefficients, f.getValue(coefficients));'], ['if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } }'], ['Set<Integer> basicRows = new HashSet<Integer>(); if (basicRows.contains(basicRow)) { coefficients[i] = 0; } else { basicRows.add(basicRow);'], 'a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java', 'b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java']
['Math-89', 1, 1, 1, 1, ['*/ @Deprecated public void addValue(Object v) { addValue((Comparable<?>) v); } /**'], ['*/ @Deprecated public void addValue(Object v) { if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); } else { throw new IllegalArgumentException("Object must implement Comparable"); } } /**'], [''], ['if (v instanceof Comparable<?>){ } else { throw new IllegalArgumentException("Object must implement Comparable"); }'], 'a/src/java/org/apache/commons/math/stat/Frequency.java', 'b/src/java/org/apache/commons/math/stat/Frequency.java']
['Math-90', 2, 2, 2, 2, ['*/ @Deprecated public void addValue(Object v) { /** * Adds 1 to the frequency count for v.', '* @param v the value to add. * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries */ Object obj = v; if (v instanceof Integer) { obj = Long.valueOf(((Integer) v).longValue());'], ['*/ @Deprecated public void addValue(Object v) { addValue((Comparable<?>) v); } /** * Adds 1 to the frequency count for v.', '* @param v the value to add. * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries */ public void addValue(Comparable<?>v){ Object obj = v; if (v instanceof Integer) { obj = Long.valueOf(((Integer) v).longValue());'], ['', ''], ['addValue((Comparable<?>) v); }', 'public void addValue(Comparable<?>v){'], 'a/src/java/org/apache/commons/math/stat/Frequency.java', 'b/src/java/org/apache/commons/math/stat/Frequency.java']
['Math-91', 1, 1, 1, 1, ['* than <tt>object</tt>, 0 if they are equal. */ public int compareTo(Fraction object) { double nOd = doubleValue(); double dOn = object.doubleValue(); return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); }'], ['* than <tt>object</tt>, 0 if they are equal. */ public int compareTo(Fraction object) { long nOd = ((long) numerator) * object.denominator; long dOn = ((long) denominator) * object.numerator; return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); }'], ['double nOd = doubleValue(); double dOn = object.doubleValue();'], ['long nOd = ((long) numerator) * object.denominator; long dOn = ((long) denominator) * object.numerator;'], 'a/src/java/org/apache/commons/math/fraction/Fraction.java', 'b/src/java/org/apache/commons/math/fraction/Fraction.java']
['Math-92', 3, 3, 3, 3, ['if ((k == 1) || (k == n - 1)) { return n; } long result = Math.round(binomialCoefficientDouble(n, k)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "result too large to represent in a long integer"); } // Use symmetry for large k // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k // For n <= 61, the naive implementation cannot overflow. // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. return result; }', '* @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5); } /**', '* For values small enough to do exact integer computation, * return the log of the exact value */ /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ /* * Sum logs for values that could overflow'], ['if ((k == 1) || (k == n - 1)) { return n; } // Use symmetry for large k if (k > n / 2) return binomialCoefficient(n, n - k); // We use the formula // (n choose k) = n! / (n-k)! / k! // (n choose k) == ((n-k+1)*...*n) / (1*...*k) // which could be written // (n choose k) == (n-1 choose k-1) * n / k long result = 1; if (n <= 61) { // For n <= 61, the naive implementation cannot overflow. for (int j = 1, i = n - k + 1; j <= k; i++, j++) { result = result * i / j; } } else if (n <= 66) { // For n > 61 but n <= 66, the result cannot overflow, // but we must take care not to overflow intermediate values. for (int j = 1, i = n - k + 1; j <= k; i++, j++) { // We know that (result * i) is divisible by j, // but (result * i) may overflow, so we split j: // Filter out the gcd, d, so j/d and i/d are integer. // result is divisible by (j/d) because (j/d) // is relative prime to (i/d) and is a divisor of // result * (i/d). long d = gcd(i, j); result = (result / (j / d)) * (i / d); } } else { // For n > 66, a result overflow might occur, so we check // the multiplication, taking care to not overflow // unnecessary. for (int j = 1, i = n - k + 1; j <= k; i++, j++) { long d = gcd(i, j); result = mulAndCheck((result / (j / d)), (i / d)); } } return result; }', '* @throws IllegalArgumentException if preconditions are not met. */ public static double binomialCoefficientDouble(final int n, final int k) { if (n < k) { throw new IllegalArgumentException( "must have n >= k for binomial coefficient (n,k)"); } if (n < 0) { throw new IllegalArgumentException( "must have n >= 0 for binomial coefficient (n,k)"); } if ((n == k) || (k == 0)) { return 1d; } if ((k == 1) || (k == n - 1)) { return n; } if (k > n/2) { return binomialCoefficientDouble(n, n - k); } if (n < 67) { return binomialCoefficient(n,k); } double result = 1d; for (int i = 1; i <= k; i++) { result *= (double)(n - k + i) / (double)i; } return Math.floor(result + 0.5); } /**', '* For values small enough to do exact integer computation, * return the log of the exact value */ if (n < 67) { return Math.log(binomialCoefficient(n,k)); } /* * Return the log of binomialCoefficientDouble for values that will not * overflow binomialCoefficientDouble */ if (n < 1030) { return Math.log(binomialCoefficientDouble(n, k)); } /* * Sum logs for values that could overflow'], ['long result = Math.round(binomialCoefficientDouble(n, k)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "result too large to represent in a long integer"); }', 'return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);', ''], ['if (k > n / 2) return binomialCoefficient(n, n - k); long result = 1; if (n <= 61) { for (int j = 1, i = n - k + 1; j <= k; i++, j++) { result = result * i / j; } } else if (n <= 66) { for (int j = 1, i = n - k + 1; j <= k; i++, j++) { long d = gcd(i, j); result = (result / (j / d)) * (i / d); } } else { for (int j = 1, i = n - k + 1; j <= k; i++, j++) { long d = gcd(i, j); result = mulAndCheck((result / (j / d)), (i / d)); } }', 'if (n < k) { throw new IllegalArgumentException( "must have n >= k for binomial coefficient (n,k)"); } if (n < 0) { throw new IllegalArgumentException( "must have n >= 0 for binomial coefficient (n,k)"); } if ((n == k) || (k == 0)) { return 1d; } if ((k == 1) || (k == n - 1)) { return n; } if (k > n/2) { return binomialCoefficientDouble(n, n - k); } if (n < 67) { return binomialCoefficient(n,k); } double result = 1d; for (int i = 1; i <= k; i++) { result *= (double)(n - k + i) / (double)i; } return Math.floor(result + 0.5);', 'if (n < 67) { return Math.log(binomialCoefficient(n,k)); } if (n < 1030) { return Math.log(binomialCoefficientDouble(n, k)); }'], 'a/src/java/org/apache/commons/math/util/MathUtils.java', 'b/src/java/org/apache/commons/math/util/MathUtils.java']
['Math-93', 3, 3, 3, 3, ['* @throws IllegalArgumentException if n < 0 */ public static long factorial(final int n) { long result = Math.round(factorialDouble(n)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "factorial value is too large to fit in a long"); }', 'if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }', 'if (n < 0) { throw new IllegalArgumentException("must have n > 0 for n!"); } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i);'], ['* @throws IllegalArgumentException if n < 0 */ public static long factorial(final int n) { if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } if (n > 20) { throw new ArithmeticException( "factorial value is too large to fit in a long"); }', 'if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } if (n < 21) { return factorial(n); } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }', 'if (n < 0) { throw new IllegalArgumentException("must have n > 0 for n!"); } if (n < 21) { return Math.log(factorial(n)); } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i);'], ['long result = Math.round(factorialDouble(n)); if (result == Long.MAX_VALUE) {', '', ''], ['if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } if (n > 20) {', 'if (n < 21) { return factorial(n); }', 'if (n < 21) { return Math.log(factorial(n)); }'], 'a/src/java/org/apache/commons/math/util/MathUtils.java', 'b/src/java/org/apache/commons/math/util/MathUtils.java']
['Math-94', 1, 1, 1, 1, ['* @since 1.1 */ public static int gcd(int u, int v) { if (u * v == 0) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to'], ['* @since 1.1 */ public static int gcd(int u, int v) { if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to'], ['if (u * v == 0) {'], ['if ((u == 0) || (v == 0)) {'], 'a/src/java/org/apache/commons/math/util/MathUtils.java', 'b/src/java/org/apache/commons/math/util/MathUtils.java']
['Math-95', 1, 1, 1, 1, ['* @return initial domain value */ protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return ret; }'], ['* @return initial domain value */ protected double getInitialDomain(double p) { double ret = 1.0; double d = getDenominatorDegreesOfFreedom(); if (d > 2.0) { // use mean ret = d / (d - 2.0); } return ret; }'], ['double ret;'], ['double ret = 1.0; if (d > 2.0) { }'], 'a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java', 'b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java']
['Math-96', 1, 1, 1, 1, ['if (rhs.isNaN()) { ret = this.isNaN(); } else { ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { // ignore exception'], ['if (rhs.isNaN()) { ret = this.isNaN(); } else { ret = (real == rhs.real) && (imaginary == rhs.imaginary); } } catch (ClassCastException ex) { // ignore exception'], ['ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));'], ['ret = (real == rhs.real) && (imaginary == rhs.imaginary);'], 'a/src/java/org/apache/commons/math/complex/Complex.java', 'b/src/java/org/apache/commons/math/complex/Complex.java']
['Math-97', 1, 1, 1, 1, [' // Verify bracketing double sign = yMin * yMax; if (sign >= 0) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException ("Function values at endpoints do not have different signs." + " Endpoints: [" + min + "," + max + "]" + " Values: [" + yMin + "," + yMax + "]"); } else { // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); // either min or max is a root } return ret;'], [' // Verify bracketing double sign = yMin * yMax; if (sign > 0) { // check if either value is close to a zero if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException ("Function values at endpoints do not have different signs." + " Endpoints: [" + min + "," + max + "]" + " Values: [" + yMin + "," + yMax + "]"); } } else if (sign < 0){ // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); } else { // either min or max is a root if (yMin == 0.0) { ret = min; } else { ret = max; } } return ret;'], ['if (sign >= 0) { } else {'], ['if (sign > 0) { if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { } } else if (sign < 0){ } else { if (yMin == 0.0) { ret = min; } else { ret = max; }'], 'a/src/java/org/apache/commons/math/analysis/BrentSolver.java', 'b/src/java/org/apache/commons/math/analysis/BrentSolver.java']
['Math-98', 2, 2, 2, 2, ['} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); final BigDecimal[] out = new BigDecimal[v.length]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) {', 'if (v.length != nCols) { throw new IllegalArgumentException("vector has wrong length"); } final double[] out = new double[v.length]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;'], ['} final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); final BigDecimal[] out = new BigDecimal[nRows]; for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) {', 'if (v.length != nCols) { throw new IllegalArgumentException("vector has wrong length"); } final double[] out = new double[nRows]; for (int row = 0; row < nRows; row++) { final double[] dataRow = data[row]; double sum = 0;'], ['final BigDecimal[] out = new BigDecimal[v.length];', 'final double[] out = new double[v.length];'], ['final BigDecimal[] out = new BigDecimal[nRows];', 'final double[] out = new double[nRows];'], 'a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java', 'b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java']
['Math-99', 2, 2, 2, 2, ['int u = p; int v = q; if ((u == 0) || (v == 0)) { return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to', 'return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); return lcm; }'], ['int u = p; int v = q; if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw MathRuntimeException.createArithmeticException( "overflow: gcd({0}, {1}) is 2^31", new Object[] { p, q }); } return (Math.abs(u) + Math.abs(v)); } // keep u and v negative, as negative integers range down to', 'return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); if (lcm == Integer.MIN_VALUE){ throw new ArithmeticException("overflow: lcm is 2^31"); } return lcm; }'], ['', ''], ['if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw MathRuntimeException.createArithmeticException( "overflow: gcd({0}, {1}) is 2^31", new Object[] { p, q }); }', 'if (lcm == Integer.MIN_VALUE){ throw new ArithmeticException("overflow: lcm is 2^31"); }'], 'a/src/java/org/apache/commons/math/util/MathUtils.java', 'b/src/java/org/apache/commons/math/util/MathUtils.java']
['Math-100', 2, 2, 2, 2, [' // compute transpose(J).J, avoiding building big intermediate matrices final int rows = problem.getMeasurements().length; final int cols = problem.getAllParameters().length; final int max = cols * rows; double[][] jTj = new double[cols][cols]; for (int i = 0; i < cols; ++i) {', 'public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException { int m = problem.getMeasurements().length; int p = problem.getAllParameters().length; if (m <= p) { throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(m), new Integer(p)}); } double[] errors = new double[problem.getAllParameters().length]; final double c = Math.sqrt(getChiSquare(problem) / (m - p)); double[][] covar = getCovariances(problem); for (int i = 0; i < errors.length; ++i) {'], [' // compute transpose(J).J, avoiding building big intermediate matrices final int rows = problem.getMeasurements().length; final int cols = problem.getUnboundParameters().length; final int max = cols * rows; double[][] jTj = new double[cols][cols]; for (int i = 0; i < cols; ++i) {', 'public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException { int m = problem.getMeasurements().length; int p = problem.getUnboundParameters().length; if (m <= p) { throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(m), new Integer(p)}); } double[] errors = new double[problem.getUnboundParameters().length]; final double c = Math.sqrt(getChiSquare(problem) / (m - p)); double[][] covar = getCovariances(problem); for (int i = 0; i < errors.length; ++i) {'], ['final int cols = problem.getAllParameters().length;', 'int p = problem.getAllParameters().length; double[] errors = new double[problem.getAllParameters().length];'], ['final int cols = problem.getUnboundParameters().length;', 'int p = problem.getUnboundParameters().length; double[] errors = new double[problem.getUnboundParameters().length];'], 'a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java', 'b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java']
['Math-101', 1, 1, 1, 1, ['int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { // set index back to initial, error index should be the start index'], ['int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; if ((startIndex >= source.length()) || (endIndex > source.length()) || source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { // set index back to initial, error index should be the start index'], ['if ('], ['if ((startIndex >= source.length()) || (endIndex > source.length()) ||'], 'a/src/java/org/apache/commons/math/complex/ComplexFormat.java', 'b/src/java/org/apache/commons/math/complex/ComplexFormat.java']
['Math-102', 1, 1, 1, 1, ['throw new IllegalArgumentException( "observed counts must be non-negative and expected counts must be postive"); } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; } return sumSq; }'], ['throw new IllegalArgumentException( "observed counts must be non-negative and expected counts must be postive"); } double sumExpected = 0d; double sumObserved = 0d; for (int i = 0; i < observed.length; i++) { sumExpected += expected[i]; sumObserved += observed[i]; } double ratio = 1.0d; boolean rescale = false; if (Math.abs(sumExpected - sumObserved) > 10E-6) { ratio = sumObserved / sumExpected; rescale = true; } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { if (rescale) { dev = ((double) observed[i] - ratio * expected[i]); sumSq += dev * dev / (ratio * expected[i]); } else { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; } } return sumSq; }'], [''], ['double sumExpected = 0d; double sumObserved = 0d; for (int i = 0; i < observed.length; i++) { sumExpected += expected[i]; sumObserved += observed[i]; } double ratio = 1.0d; boolean rescale = false; if (Math.abs(sumExpected - sumObserved) > 10E-6) { ratio = sumObserved / sumExpected; rescale = true; } if (rescale) { dev = ((double) observed[i] - ratio * expected[i]); sumSq += dev * dev / (ratio * expected[i]); } else { }'], 'a/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java', 'b/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java']
['Math-103', 1, 1, 1, 1, ['* convergence exception is caught and 0 or 1 is returned. */ public double cumulativeProbability(double x) throws MathException { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); } /**'], ['* convergence exception is caught and 0 or 1 is returned. */ public double cumulativeProbability(double x) throws MathException { try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0.0d; } else if (x > (mean + 20 * standardDeviation)) { return 1.0d; } else { throw ex; } } } /**'], [''], ['try { } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0.0d; } else if (x > (mean + 20 * standardDeviation)) { return 1.0d; } else { throw ex; } }'], 'a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java', 'b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java']
['Math-104', 1, 1, 1, 1, ['private static final long serialVersionUID = -6587513359895466954L; /** Maximum allowed numerical error. */ private static final double DEFAULT_EPSILON = 10e-9; /** Lanczos coefficients */ private static double[] lanczos ='], ['private static final long serialVersionUID = -6587513359895466954L; /** Maximum allowed numerical error. */ private static final double DEFAULT_EPSILON = 10e-15; /** Lanczos coefficients */ private static double[] lanczos ='], ['private static final double DEFAULT_EPSILON = 10e-9;'], ['private static final double DEFAULT_EPSILON = 10e-15;'], 'a/src/java/org/apache/commons/math/special/Gamma.java', 'b/src/java/org/apache/commons/math/special/Gamma.java']
['Math-105', 1, 1, 1, 1, ['* @return sum of squared errors associated with the regression model */ public double getSumSquaredErrors() { return sumYY - sumXY * sumXY / sumXX; } /**'], ['* @return sum of squared errors associated with the regression model */ public double getSumSquaredErrors() { return Math.max(0d, sumYY - sumXY * sumXY / sumXX); } /**'], ['return sumYY - sumXY * sumXY / sumXX;'], ['return Math.max(0d, sumYY - sumXY * sumXY / sumXX);'], 'a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java', 'b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java']
['Math-106', 2, 2, 2, 2, ["return null; } // minus signs should be leading, invalid expression // parse '/' int startIndex = pos.getIndex();", 'return null; } // minus signs must be leading, invalid int w = whole.intValue(); int n = num.intValue();'], ["return null; } if (num.intValue() < 0) { // minus signs should be leading, invalid expression pos.setIndex(initialIndex); return null; } // parse '/' int startIndex = pos.getIndex();", 'return null; } if (den.intValue() < 0) { // minus signs must be leading, invalid pos.setIndex(initialIndex); return null; } int w = whole.intValue(); int n = num.intValue();'], ['', ''], ['if (num.intValue() < 0) { pos.setIndex(initialIndex); return null; }', 'if (den.intValue() < 0) { pos.setIndex(initialIndex); return null; }'], 'a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java', 'b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java']
['Cli-1', 10, 10, 10, 10, ['package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; /** * <p>Represents list of arguments parsed against', 'private List args = new LinkedList(); /** the processed options */ private Map options = new HashMap(); private Map names = new HashMap(); /** Map of unique options for ease to get complete list of options */ // private Set allOptions = new HashSet(); private Map hashcodeMap = new HashMap(); /** * Creates a command line.', '*/ public boolean hasOption(String opt) { return options.containsKey(opt); } /**', '{ String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); }', '*/ public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; }', '* @param opt short or long name of the option * @return Canonicalized option */ /** * Retrieves the array of values, if any, of an option.', '*/ void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } /**', '*/ public Iterator iterator() { return hashcodeMap.values().iterator(); } /**', '*/ public Option[] getOptions() { Collection processed = options.values(); // reinitialise array Option[] optionsArray = new Option[processed.size()];', '// return the array return (Option[]) processed.toArray(optionsArray); } No newline at end of file }'], ['package org.apache.commons.cli; import java.util.Collection; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Set; import java.util.HashSet; /** * <p>Represents list of arguments parsed against', 'private List args = new LinkedList(); /** the processed options */ private Set options = new HashSet(); /** Map of unique options for ease to get complete list of options */ // private Set allOptions = new HashSet(); /** * Creates a command line.', '*/ public boolean hasOption(String opt) { return options.contains( resolveOption(opt)); } /**', '{ String res = getOptionValue(opt); Option option = resolveOption(opt); if (option == null) { return null; } Object type = option.getType(); return (res == null) ? null : TypeHandler.createValue(res, type); }', '*/ public String[] getOptionValues(String opt) { Option key = resolveOption( opt ); if (options.contains(key)) { return key.getValues(); } return null; }', '* @param opt short or long name of the option * @return Canonicalized option */ private Option resolveOption( String opt ) { opt = Util.stripLeadingHyphens(opt); for ( Iterator it = options.iterator(); it.hasNext(); ) { Option option = (Option) it.next(); if (opt.equals(option.getOpt())) { return option; } if (opt.equals( option.getLongOpt())) { return option; } } return null; } /** * Retrieves the array of values, if any, of an option.', '*/ void addOption(Option opt) { options.add(opt); } /**', '*/ public Iterator iterator() { return options.iterator(); } /**', '*/ public Option[] getOptions() { Collection processed = options; // reinitialise array Option[] optionsArray = new Option[processed.size()];', '// return the array return (Option[]) processed.toArray(optionsArray); } } No newline at end of file'], ['import java.util.HashMap; import java.util.Map;', 'private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap();', 'return options.containsKey(opt);', 'if (!options.containsKey(opt)) Object type = ((Option) options.get(opt)).getType();', 'opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) key = (String) names.get(opt); if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); }', '', 'hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt);', 'return hashcodeMap.values().iterator();', 'Collection processed = options.values();', '}'], ['import java.util.Set; import java.util.HashSet;', 'private Set options = new HashSet();', 'return options.contains( resolveOption(opt));', 'Option option = resolveOption(opt); if (option == null) Object type = option.getType();', 'Option key = resolveOption( opt ); if (options.contains(key)) return key.getValues();', 'private Option resolveOption( String opt ) { opt = Util.stripLeadingHyphens(opt); for ( Iterator it = options.iterator(); it.hasNext(); ) { Option option = (Option) it.next(); if (opt.equals(option.getOpt())) { return option; } if (opt.equals( option.getLongOpt())) { return option; } } return null; }', 'options.add(opt);', 'return options.iterator();', 'Collection processed = options;', '}'], 'a/src/java/org/apache/commons/cli/CommandLine.java', 'b/src/java/org/apache/commons/cli/CommandLine.java']
['Cli-2', 1, 1, 1, 1, ['} else { tokens.add("-" + ch); } } } No newline at end of file }'], ['} else { tokens.add(token); break; } } } } No newline at end of file'], ['tokens.add("-" + ch); }'], ['tokens.add(token); break; }'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-3', 2, 2, 2, 2, [' import java.util.Date; import org.apache.commons.lang.math.NumberUtils; /** * This is a temporary implementation. TypeHandler will handle the * pluggableness of OptionTypes and it will direct all of these types', '{ try { return NumberUtils.createNumber(str); } catch (NumberFormatException nfe) {'], [' import java.util.Date; /** * This is a temporary implementation. TypeHandler will handle the * pluggableness of OptionTypes and it will direct all of these types', "{ try { if( str != null ) { if( str.indexOf('.') != -1 ) { return Double.valueOf(str); } else { return Long.valueOf(str); } } } catch (NumberFormatException nfe) {"], ['import org.apache.commons.lang.math.NumberUtils;', 'return NumberUtils.createNumber(str);'], ['', "if( str != null ) { if( str.indexOf('.') != -1 ) { return Double.valueOf(str); } else { return Long.valueOf(str); } }"], 'a/src/java/org/apache/commons/cli/TypeHandler.java', 'b/src/java/org/apache/commons/cli/TypeHandler.java']
['Cli-4', 1, 1, 1, 1, ['if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); StringBuffer buff = new StringBuffer(); // loop through the required options'], ['if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); StringBuffer buff = new StringBuffer("Missing required option"); buff.append(requiredOptions.size() == 1 ? "" : "s"); buff.append(": "); // loop through the required options'], ['StringBuffer buff = new StringBuffer();'], ['StringBuffer buff = new StringBuffer("Missing required option"); buff.append(requiredOptions.size() == 1 ? "" : "s"); buff.append(": ");'], 'a/src/java/org/apache/commons/cli/Parser.java', 'b/src/java/org/apache/commons/cli/Parser.java']
['Cli-5', 1, 1, 1, 1, ['*/ static String stripLeadingHyphens(String str) { if (str.startsWith("--")) { return str.substring(2, str.length());'], ['*/ static String stripLeadingHyphens(String str) { if (str == null) { return null; } if (str.startsWith("--")) { return str.substring(2, str.length());'], [''], ['if (str == null) { return null; }'], 'a/src/java/org/apache/commons/cli/Util.java', 'b/src/java/org/apache/commons/cli/Util.java']
['Cli-6', 2, 2, 2, 2, ['// temp variable Option option; // iterate over the options for (Iterator i = options.getOptions().iterator(); i.hasNext();) { // get the next Option option = (Option) i.next();', 'buff.append("["); } // for each option in the OptionGroup for (Iterator i = group.getOptions().iterator(); i.hasNext();) { // whether the option is required or not is handled at group level appendOption(buff, (Option) i.next(), true);'], ['// temp variable Option option; List optList = new ArrayList(options.getOptions()); Collections.sort(optList, new OptionComparator()); // iterate over the options for (Iterator i = optList.iterator(); i.hasNext();) { // get the next Option option = (Option) i.next();', 'buff.append("["); } List optList = new ArrayList(group.getOptions()); Collections.sort(optList, new OptionComparator()); // for each option in the OptionGroup for (Iterator i = optList.iterator(); i.hasNext();) { // whether the option is required or not is handled at group level appendOption(buff, (Option) i.next(), true);'], ['for (Iterator i = options.getOptions().iterator(); i.hasNext();)', 'for (Iterator i = group.getOptions().iterator(); i.hasNext();)'], ['List optList = new ArrayList(options.getOptions()); Collections.sort(optList, new OptionComparator()); for (Iterator i = optList.iterator(); i.hasNext();)', 'List optList = new ArrayList(group.getOptions()); Collections.sort(optList, new OptionComparator()); for (Iterator i = optList.iterator(); i.hasNext();)'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-7', 2, 2, 2, 2, ['*/ package org.apache.commons.cli2.builder; import java.util.HashSet; import java.util.Iterator; import java.util.Set; import org.apache.commons.cli2.Argument;', 'this.abuilder = abuilder; } private final Set options = new HashSet(); /** * Creates a new Option instance.'], ['*/ package org.apache.commons.cli2.builder; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.Set; import org.apache.commons.cli2.Argument;', 'this.abuilder = abuilder; } private final Set options = new LinkedHashSet(); /** * Creates a new Option instance.'], ['import java.util.HashSet;', 'private final Set options = new HashSet();'], ['import java.util.LinkedHashSet;', 'private final Set options = new LinkedHashSet();'], 'a/src/java/org/apache/commons/cli2/builder/PatternBuilder.java', 'b/src/java/org/apache/commons/cli2/builder/PatternBuilder.java']
['Cli-8', 1, 1, 1, 1, ['while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, nextLineTabStop); if (pos == -1) {'], ['while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) {'], ['pos = findWrapPos(text, width, nextLineTabStop);'], ['pos = findWrapPos(text, width, 0);'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-9', 1, 1, 1, 1, ['while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }'], ['while (iter.hasNext()) { buff.append(iter.next()); buff.append(", "); } throw new MissingOptionException(buff.substring(0, buff.length() - 2)); } }'], ['throw new MissingOptionException(buff.toString());'], ['buff.append(", "); throw new MissingOptionException(buff.substring(0, buff.length() - 2));'], 'a/src/java/org/apache/commons/cli/Parser.java', 'b/src/java/org/apache/commons/cli/Parser.java']
['Cli-10', 2, 2, 2, 2, ['*/ package org.apache.commons.cli; import java.util.Arrays; import java.util.Enumeration; import java.util.Iterator;', ' protected void setOptions(final Options options) { this.options = options; this.requiredOptions = options.getRequiredOptions(); } protected Options getOptions() {'], ['*/ package org.apache.commons.cli; import java.util.ArrayList; import java.util.Arrays; import java.util.Enumeration; import java.util.Iterator;', ' protected void setOptions(final Options options) { this.options = options; this.requiredOptions = new ArrayList(options.getRequiredOptions()); } protected Options getOptions() {'], ['', 'this.requiredOptions = options.getRequiredOptions();'], ['import java.util.ArrayList;', 'this.requiredOptions = new ArrayList(options.getRequiredOptions());'], 'a/src/java/org/apache/commons/cli/Parser.java', 'b/src/java/org/apache/commons/cli/Parser.java']
['Cli-11', 1, 1, 1, 1, ['} // if the Option has a value if (option.hasArg() && (option.getArgName() != null)) { buff.append(" <").append(option.getArgName()).append(">"); }'], ['} // if the Option has a value if (option.hasArg() && option.hasArgName()) { buff.append(" <").append(option.getArgName()).append(">"); }'], ['if (option.hasArg() && (option.getArgName() != null))'], ['if (option.hasArg() && option.hasArgName())'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-12', 1, 1, 1, 1, ['} else { if (options.hasOption(arg.substring(0, 2))) { // the format is --foo=value or -foo=value // the format is a special properties option (-Dproperty=value) tokens.add(arg.substring(0, 2)); // -D tokens.add(arg.substring(2)); // property=value'], ["} else { if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) { // the format is --foo=value or -foo=value tokens.add(arg.substring(0, arg.indexOf('='))); // --foo tokens.add(arg.substring(arg.indexOf('=') + 1)); // value } else if (options.hasOption(arg.substring(0, 2))) { // the format is a special properties option (-Dproperty=value) tokens.add(arg.substring(0, 2)); // -D tokens.add(arg.substring(2)); // property=value"], ['if (options.hasOption(arg.substring(0, 2)))'], ["if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) tokens.add(arg.substring(0, arg.indexOf('='))); // --foo tokens.add(arg.substring(arg.indexOf('=') + 1)); // value } else if (options.hasOption(arg.substring(0, 2))) {"], 'a/src/java/org/apache/commons/cli/GnuParser.java', 'b/src/java/org/apache/commons/cli/GnuParser.java']
['Cli-13', 3, 3, 3, 3, ['* @param option the Option associated with the values * @return a list of values or an empty List if none are found */ /** * Sets the default values for an Option in the CommandLine', 'return valueList; } // First grab the command line values // Finally use an empty list public Boolean getSwitch(final Option option, final Boolean defaultValue) {', 'final Option option) throws OptionException { // count of arguments processed for this option. int argumentCount = 0; while (arguments.hasNext() && (argumentCount < maximum)) { final String allValuesQuoted = (String) arguments.next();'], ['* @param option the Option associated with the values * @return a list of values or an empty List if none are found */ List getUndefaultedValues(final Option option); /** * Sets the default values for an Option in the CommandLine', 'return valueList; } public List getUndefaultedValues(Option option) { // First grab the command line values List valueList = (List) values.get(option); // Finally use an empty list if (valueList == null) { valueList = Collections.EMPTY_LIST; } return valueList; } public Boolean getSwitch(final Option option, final Boolean defaultValue) {', 'final Option option) throws OptionException { // count of arguments processed for this option. int argumentCount = commandLine.getUndefaultedValues(option).size(); while (arguments.hasNext() && (argumentCount < maximum)) { final String allValuesQuoted = (String) arguments.next();'], ['', '', 'int argumentCount = 0;'], ['List getUndefaultedValues(final Option option);', 'public List getUndefaultedValues(Option option) { List valueList = (List) values.get(option); if (valueList == null) { valueList = Collections.EMPTY_LIST; } return valueList; }', 'int argumentCount = commandLine.getUndefaultedValues(option).size();'], 'a/src/java/org/apache/commons/cli2/option/ArgumentImpl.java', 'b/src/java/org/apache/commons/cli2/option/ArgumentImpl.java']
['Cli-14', 2, 2, 2, 2, [' // needs validation? boolean validate = option.isRequired() || option instanceof Group; if (validate) { option.validate(commandLine); } // if the child option is present then validate it if (commandLine.hasOption(option)) {', ' break; } option.validate(commandLine); } }'], [' // needs validation? boolean validate = option.isRequired() || option instanceof Group; // if the child option is present then validate it if (commandLine.hasOption(option)) {', ' break; } validate = true; } if (validate) { option.validate(commandLine); } }'], ['if (validate) { option.validate(commandLine); }', ''], ['', 'validate = true; } if (validate) {'], 'a/src/java/org/apache/commons/cli2/option/GroupImpl.java', 'b/src/java/org/apache/commons/cli2/option/GroupImpl.java']
['Cli-15', 1, 1, 1, 1, ['List valueList = (List) values.get(option); // grab the correct default values if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.isEmpty()) { valueList = (List) this.defaultValues.get(option); } // if there are more default values as specified, add them to // the list. // copy the list first return valueList == null ? Collections.EMPTY_LIST : valueList; }'], ['List valueList = (List) values.get(option); // grab the correct default values if (defaultValues == null || defaultValues.isEmpty()) { defaultValues = (List) this.defaultValues.get(option); } // augment the list with the default values if (defaultValues != null && !defaultValues.isEmpty()) { if (valueList == null || valueList.isEmpty()) { valueList = defaultValues; } else { // if there are more default values as specified, add them to // the list. if (defaultValues.size() > valueList.size()) { // copy the list first valueList = new ArrayList(valueList); for (int i=valueList.size(); i<defaultValues.size(); i++) { valueList.add(defaultValues.get(i)); } } } } return valueList == null ? Collections.EMPTY_LIST : valueList; }'], ['if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; if ((valueList == null) || valueList.isEmpty()) { valueList = (List) this.defaultValues.get(option); }'], ['if (defaultValues == null || defaultValues.isEmpty()) { defaultValues = (List) this.defaultValues.get(option); if (defaultValues != null && !defaultValues.isEmpty()) { if (valueList == null || valueList.isEmpty()) { valueList = defaultValues; } else { if (defaultValues.size() > valueList.size()) { valueList = new ArrayList(valueList); for (int i=valueList.size(); i<defaultValues.size(); i++) { valueList.add(defaultValues.get(i)); } } } }'], 'a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java', 'b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java']
['Cli-16', 6, 6, 6, 6, ['* * @return the parent of this option */ /** * Sets the parent of this option. This method is called when the option is', '* * @param parent the parent option */ }', '} // ensure that all parent options are also added } public void addValue(final Option option,', '// process the options for (final Iterator i = options.iterator(); i.hasNext();) { final Option option = (Option) i.next(); if (option instanceof Argument) { i.remove();', 'public abstract class OptionImpl implements Option { private final int id; private final boolean required; /** * Creates an OptionImpl with the specified id', '// nothing to do normally } protected void checkPrefixes(final Set prefixes) { // nothing to do if empty prefix list'], ['* * @return the parent of this option */ Option getParent(); /** * Sets the parent of this option. This method is called when the option is', '* * @param parent the parent option */ void setParent(Option parent); }', '} // ensure that all parent options are also added Option parent = option.getParent(); while (parent != null && !options.contains(parent)) { options.add(parent); parent = parent.getParent(); } } public void addValue(final Option option,', '// process the options for (final Iterator i = options.iterator(); i.hasNext();) { final Option option = (Option) i.next(); option.setParent(this); if (option instanceof Argument) { i.remove();', 'public abstract class OptionImpl implements Option { private final int id; private final boolean required; private Option parent; /** * Creates an OptionImpl with the specified id', '// nothing to do normally } public Option getParent() { return parent; } public void setParent(Option parent) { this.parent = parent; } protected void checkPrefixes(final Set prefixes) { // nothing to do if empty prefix list'], ['', '', '', '', '', ''], ['Option getParent();', 'void setParent(Option parent);', 'Option parent = option.getParent(); while (parent != null && !options.contains(parent)) { options.add(parent); parent = parent.getParent(); }', 'option.setParent(this);', 'private Option parent;', 'public Option getParent() { return parent; } public void setParent(Option parent) { this.parent = parent; }'], 'a/src/java/org/apache/commons/cli2/option/OptionImpl.java', 'b/src/java/org/apache/commons/cli2/option/OptionImpl.java']
['Cli-17', 1, 1, 1, 1, ['else if (stopAtNonOption) { process(token.substring(i)); } else {'], ['else if (stopAtNonOption) { process(token.substring(i)); break; } else {'], [''], ['break;'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-18', 3, 3, 3, 3, ['// single hyphen else if ("-".equals(token)) { processSingleHyphen(token); } else if (token.startsWith("-")) {', 'tokens.add(value); } } private void processSingleHyphen(String hyphen) { tokens.add(hyphen); } /** * <p>If an {@link Option} exists for <code>token</code> then', 'else if (stopAtNonOption) { eatTheRest = true; } }'], ['// single hyphen else if ("-".equals(token)) { tokens.add(token); } else if (token.startsWith("-")) {', 'tokens.add(value); } } /** * <p>If an {@link Option} exists for <code>token</code> then', 'else if (stopAtNonOption) { eatTheRest = true; tokens.add(token); } }'], ['processSingleHyphen(token);', 'private void processSingleHyphen(String hyphen) { tokens.add(hyphen); }', ''], ['tokens.add(token);', '', 'tokens.add(token);'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-19', 1, 1, 1, 1, ['if (options.hasOption(token)) { currentOption = options.getOption(token); tokens.add(token); } else if (stopAtNonOption) { eatTheRest = true; tokens.add(token); } } /**'], ['if (options.hasOption(token)) { currentOption = options.getOption(token); } else if (stopAtNonOption) { eatTheRest = true; } tokens.add(token); } /**'], ['tokens.add(token); tokens.add(token);'], [' tokens.add(token);'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-20', 1, 1, 1, 1, ['// handle long option --foo or --foo=bar if (token.startsWith("--")) { if (token.indexOf(\'=\') != -1) { tokens.add(token.substring(0, token.indexOf(\'=\'))); tokens.add(token.substring(token.indexOf(\'=\') + 1, token.length())); } else { tokens.add(token); } }'], ['// handle long option --foo or --foo=bar if (token.startsWith("--")) { int pos = token.indexOf(\'=\'); String opt = pos == -1 ? token : token.substring(0, pos); // --foo if (!options.hasOption(opt) && stopAtNonOption) { process(token); } else { tokens.add(opt); if (pos != -1) { tokens.add(token.substring(pos + 1)); } } }'], ["if (token.indexOf('=') != -1) tokens.add(token.substring(0, token.indexOf('='))); tokens.add(token.substring(token.indexOf('=') + 1, token.length())); tokens.add(token);"], ["int pos = token.indexOf('='); String opt = pos == -1 ? token : token.substring(0, pos); // --foo if (!options.hasOption(opt) && stopAtNonOption) process(token); tokens.add(opt); if (pos != -1) { tokens.add(token.substring(pos + 1)); }"], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-21', 6, 6, 6, 6, ['* * @return the current option */ /** * Sets the current option. This method is called by concrete option', '* * @param currentOption the new current option */ }', 'private final Map defaultSwitches = new HashMap(); private final List normalised; private final Set prefixes; /** * Creates a new WriteableCommandLineImpl rooted on the specified Option, to', 'final List arguments) { this.prefixes = rootOption.getPrefixes(); this.normalised = arguments; } public void addOption(Option option) { options.add(option);', '*/ public boolean looksLikeOption(final String trigger) { // this is a reentrant call for (final Iterator i = prefixes.iterator(); i.hasNext();) { final String prefix = (String) i.next(); if (trigger.startsWith(prefix)) { return true; } } return false; } public String toString() {', '*/ private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) { return commandLine.looksLikeOption(trigger); } }'], ['* * @return the current option */ Option getCurrentOption(); /** * Sets the current option. This method is called by concrete option', '* * @param currentOption the new current option */ void setCurrentOption(Option currentOption); }', 'private final Map defaultSwitches = new HashMap(); private final List normalised; private final Set prefixes; private Option currentOption; private String checkForOption; /** * Creates a new WriteableCommandLineImpl rooted on the specified Option, to', 'final List arguments) { this.prefixes = rootOption.getPrefixes(); this.normalised = arguments; setCurrentOption(rootOption); } public Option getCurrentOption() { return currentOption; } public void setCurrentOption(Option currentOption) { this.currentOption = currentOption; } public void addOption(Option option) { options.add(option);', '*/ public boolean looksLikeOption(final String trigger) { if (checkForOption != null) { // this is a reentrant call return !checkForOption.equals(trigger); } checkForOption = trigger; try { for (final Iterator i = prefixes.iterator(); i.hasNext();) { final String prefix = (String) i.next(); if (trigger.startsWith(prefix)) { if (getCurrentOption().canProcess(this, trigger) || getCurrentOption().findOption(trigger) != null) { return true; } } } return false; } finally { checkForOption = null; } } public String toString() {', '*/ private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) { Option oldOption = commandLine.getCurrentOption(); try { commandLine.setCurrentOption(this); return commandLine.looksLikeOption(trigger); } finally { commandLine.setCurrentOption(oldOption); } } }'], ['', '', '', '', '', ''], ['Option getCurrentOption();', 'void setCurrentOption(Option currentOption);', 'private Option currentOption; private String checkForOption;', 'setCurrentOption(rootOption); public Option getCurrentOption() { return currentOption; } public void setCurrentOption(Option currentOption) { this.currentOption = currentOption; }', 'if (checkForOption != null) { return !checkForOption.equals(trigger); } checkForOption = trigger; try { if (getCurrentOption().canProcess(this, trigger) || getCurrentOption().findOption(trigger) != null) { } } finally { checkForOption = null; }', 'Option oldOption = commandLine.getCurrentOption(); try { commandLine.setCurrentOption(this); } finally { commandLine.setCurrentOption(oldOption); }'], 'a/src/java/org/apache/commons/cli2/option/GroupImpl.java', 'b/src/java/org/apache/commons/cli2/option/GroupImpl.java']
['Cli-22', 7, 7, 7, 7, ['private boolean eatTheRest; /** holder for the current option */ /** the command line Options */ private Options options;', ' if (!options.hasOption(opt)) { processNonOptionToken(token); } else { tokens.add(opt); if (pos != -1)', 'burstToken(token, stopAtNonOption); } } else if (stopAtNonOption) { processNonOptionToken(token); } else { tokens.add(token); } gobble(iter);', '* * @param value The current token */ private void processNonOptionToken(String value) { eatTheRest = true; tokens.add("--"); tokens.add(value); }', 'eatTheRest = true; } tokens.add(token); }', '*/ protected void burstToken(String token, boolean stopAtNonOption) { Option currentOption; for (int i = 1; i < token.length(); i++) { String ch = String.valueOf(token.charAt(i));', '} else if (stopAtNonOption) { processNonOptionToken(token.substring(i)); break; } else'], ['private boolean eatTheRest; /** holder for the current option */ private Option currentOption; /** the command line Options */ private Options options;', ' if (!options.hasOption(opt)) { processNonOptionToken(token, stopAtNonOption); } else { currentOption = options.getOption(opt); tokens.add(opt); if (pos != -1)', 'burstToken(token, stopAtNonOption); } } else { processNonOptionToken(token, stopAtNonOption); } gobble(iter);', '* * @param value The current token */ private void processNonOptionToken(String value, boolean stopAtNonOption) { if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) { eatTheRest = true; tokens.add("--"); } tokens.add(value); }', 'eatTheRest = true; } if (options.hasOption(token)) { currentOption = options.getOption(token); } tokens.add(token); }', '*/ protected void burstToken(String token, boolean stopAtNonOption) { for (int i = 1; i < token.length(); i++) { String ch = String.valueOf(token.charAt(i));', '} else if (stopAtNonOption) { processNonOptionToken(token.substring(i), true); break; } else'], ['', 'processNonOptionToken(token);', 'else if (stopAtNonOption) { processNonOptionToken(token); } tokens.add(token);', 'private void processNonOptionToken(String value)', '', 'Option currentOption;', 'processNonOptionToken(token.substring(i));'], ['private Option currentOption;', 'processNonOptionToken(token, stopAtNonOption); currentOption = options.getOption(opt);', 'processNonOptionToken(token, stopAtNonOption);', 'private void processNonOptionToken(String value, boolean stopAtNonOption) if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) { }', 'if (options.hasOption(token)) { currentOption = options.getOption(token); }', '', 'processNonOptionToken(token.substring(i), true);'], 'a/src/java/org/apache/commons/cli/PosixParser.java', 'b/src/java/org/apache/commons/cli/PosixParser.java']
['Cli-23', 2, 2, 2, 2, [' while (true) { int lastPos = pos; text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0);', 'sb.append(text); return sb; } else if (pos == lastPos) { throw new RuntimeException("Text too long for line - throwing exception to avoid infinite loop [CLI-162]: " + text); } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);'], [' while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0);', 'sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);'], ['int lastPos = pos;', '} else if (pos == lastPos) { throw new RuntimeException("Text too long for line - throwing exception to avoid infinite loop [CLI-162]: " + text);'], ['', '} if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { sb.append(text); return sb;'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-24', 1, 1, 1, 1, ['if (nextLineTabStop >= width) { // stops infinite loop happening throw new IllegalStateException("Total width is less than the width of the argument and indent " + "- no room for the description"); } // all following lines must be padded with nextLineTabStop space'], ['if (nextLineTabStop >= width) { // stops infinite loop happening nextLineTabStop = width - 1; } // all following lines must be padded with nextLineTabStop space'], ['throw new IllegalStateException("Total width is less than the width of the argument and indent " + "- no room for the description");'], ['nextLineTabStop = width - 1;'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-25', 1, 1, 1, 1, ['if (nextLineTabStop >= width) { // stops infinite loop happening nextLineTabStop = width - 1; } // all following lines must be padded with nextLineTabStop space'], ['if (nextLineTabStop >= width) { // stops infinite loop happening nextLineTabStop = 1; } // all following lines must be padded with nextLineTabStop space'], ['nextLineTabStop = width - 1;'], ['nextLineTabStop = 1;'], 'a/src/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-26', 2, 2, 2, 2, ['*/ public static Option create(String opt) throws IllegalArgumentException { // create the option Option option = new Option(opt, description); // set the option properties option.setLongOpt(longopt);', 'option.setType(type); option.setValueSeparator(valuesep); option.setArgName(argName); // reset the OptionBuilder properties OptionBuilder.reset(); // return the Option instance return option;'], ['*/ public static Option create(String opt) throws IllegalArgumentException { Option option = null; try { // create the option option = new Option(opt, description); // set the option properties option.setLongOpt(longopt);', 'option.setType(type); option.setValueSeparator(valuesep); option.setArgName(argName); } finally { // reset the OptionBuilder properties OptionBuilder.reset(); } // return the Option instance return option;'], ['Option option = new Option(opt, description);', ''], ['Option option = null; try { option = new Option(opt, description);', '} finally { }'], 'a/src/java/org/apache/commons/cli/OptionBuilder.java', 'b/src/java/org/apache/commons/cli/OptionBuilder.java']
['Cli-27', 1, 1, 1, 1, ['// if no option has already been selected or the // same option is being reselected then set the // selected member variable if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt(); } else {'], ['// if no option has already been selected or the // same option is being reselected then set the // selected member variable if (selected == null || selected.equals(option.getKey())) { selected = option.getKey(); } else {'], ['if (selected == null || selected.equals(option.getOpt())) selected = option.getOpt();'], ['if (selected == null || selected.equals(option.getKey())) selected = option.getKey();'], 'a/src/java/org/apache/commons/cli/OptionGroup.java', 'b/src/java/org/apache/commons/cli/OptionGroup.java']
['Cli-28', 1, 1, 1, 1, ["{ // if the value is not yes, true or 1 then don't add the // option to the CommandLine break; } cmd.addOption(opt);"], ["{ // if the value is not yes, true or 1 then don't add the // option to the CommandLine continue; } cmd.addOption(opt);"], ['break;'], ['continue;'], 'a/src/java/org/apache/commons/cli/Parser.java', 'b/src/java/org/apache/commons/cli/Parser.java']
['Cli-29', 1, 1, 1, 1, ['*/ static String stripLeadingAndTrailingQuotes(String str) { if (str.startsWith("\\"")) { str = str.substring(1, str.length()); } int length = str.length(); if (str.endsWith("\\"")) { str = str.substring(0, length - 1); } return str;'], ['*/ static String stripLeadingAndTrailingQuotes(String str) { int length = str.length(); if (length > 1 && str.startsWith("\\"") && str.endsWith("\\"") && str.substring(1, length - 1).indexOf(\'"\') == -1) { str = str.substring(1, length - 1); } return str;'], ['if (str.startsWith("\\"")) { str = str.substring(1, str.length()); } if (str.endsWith("\\"")) str = str.substring(0, length - 1);'], ['if (length > 1 && str.startsWith("\\"") && str.endsWith("\\"") && str.substring(1, length - 1).indexOf(\'"\') == -1) str = str.substring(1, length - 1);'], 'a/src/java/org/apache/commons/cli/Util.java', 'b/src/java/org/apache/commons/cli/Util.java']
['Cli-30', 2, 2, 2, 2, ['{ String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = options.getOption(option); // if the option is part of a group, check if another option of the group has been selected // get the value from the properties String value = properties.getProperty(option);', '{ String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); // if the option is part of a group, check if another option of the group has been selected // get the value from the properties instance String value = properties.getProperty(option);'], ['{ String option = e.nextElement().toString(); Option opt = options.getOption(option); if (opt == null) { throw new UnrecognizedOptionException("Default option wasn\'t defined", option); } // if the option is part of a group, check if another option of the group has been selected OptionGroup group = options.getOptionGroup(opt); boolean selected = group != null && group.getSelected() != null; if (!cmd.hasOption(option) && !selected) { // get the value from the properties String value = properties.getProperty(option);', '{ String option = e.nextElement().toString(); Option opt = options.getOption(option); if (opt == null) { throw new UnrecognizedOptionException("Default option wasn\'t defined", option); } // if the option is part of a group, check if another option of the group has been selected OptionGroup group = options.getOptionGroup(opt); boolean selected = group != null && group.getSelected() != null; if (!cmd.hasOption(option) && !selected) { // get the value from the properties instance String value = properties.getProperty(option);'], ['if (!cmd.hasOption(option)) Option opt = options.getOption(option);', 'if (!cmd.hasOption(option)) Option opt = getOptions().getOption(option);'], ['Option opt = options.getOption(option); if (opt == null) throw new UnrecognizedOptionException("Default option wasn\'t defined", option); } OptionGroup group = options.getOptionGroup(opt); boolean selected = group != null && group.getSelected() != null; if (!cmd.hasOption(option) && !selected) {', 'Option opt = options.getOption(option); if (opt == null) throw new UnrecognizedOptionException("Default option wasn\'t defined", option); } OptionGroup group = options.getOptionGroup(opt); boolean selected = group != null && group.getSelected() != null; if (!cmd.hasOption(option) && !selected) {'], 'a/src/main/java/org/apache/commons/cli/Parser.java', 'b/src/main/java/org/apache/commons/cli/Parser.java']
['Cli-31', 3, 3, 3, 3, ['} // if the Option has a value and a non blank argname if (option.hasArg() && option.hasArgName()) { buff.append(option.getOpt() == null ? longOptSeparator : " "); buff.append("<").append(option.getArgName()).append(">"); } // if the Option is not a required option', 'private String longOpt; /** the name of the argument for this option */ private String argName = "arg"; /** description of the option */ private String description;', 'private static void reset() { description = null; argName = "arg"; longopt = null; type = null; required = false;'], ['} // if the Option has a value and a non blank argname if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0)) { buff.append(option.getOpt() == null ? longOptSeparator : " "); buff.append("<").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(">"); } // if the Option is not a required option', 'private String longOpt; /** the name of the argument for this option */ private String argName; /** description of the option */ private String description;', 'private static void reset() { description = null; argName = null; longopt = null; type = null; required = false;'], ['if (option.hasArg() && option.hasArgName()) buff.append("<").append(option.getArgName()).append(">");', 'private String argName = "arg";', 'argName = "arg";'], ['if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0)) buff.append("<").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(">");', 'private String argName;', 'argName = null;'], 'a/src/main/java/org/apache/commons/cli/OptionBuilder.java', 'b/src/main/java/org/apache/commons/cli/OptionBuilder.java']
['Cli-32', 1, 1, 1, 1, [" // if we didn't find one, simply chop at startPos+width pos = startPos + width; while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; } return pos == text.length() ? -1 : pos; }"], [" // if we didn't find one, simply chop at startPos+width pos = startPos + width; return pos == text.length() ? -1 : pos; }"], ["while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; }"], [''], 'a/src/main/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/main/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-33', 2, 2, 2, 2, ['{ StringBuffer sb = new StringBuffer(text.length()); renderWrappedText(sb, width, nextLineTabStop, text); pw.println(sb.toString()); }', '* @param nextLineTabStop The position on the next line for the first tab. * @param text The text to be rendered. */ // cannot happen /** * Finds the next text wrap position after <code>startPos</code> for the'], ['{ StringBuffer sb = new StringBuffer(text.length()); renderWrappedTextBlock(sb, width, nextLineTabStop, text); pw.println(sb.toString()); }', '* @param nextLineTabStop The position on the next line for the first tab. * @param text The text to be rendered. */ private StringBuffer renderWrappedTextBlock(StringBuffer sb, int width, int nextLineTabStop, String text) { try { BufferedReader in = new BufferedReader(new StringReader(text)); String line; boolean firstLine = true; while ((line = in.readLine()) != null) { if (!firstLine) { sb.append(getNewLine()); } else { firstLine = false; } renderWrappedText(sb, width, nextLineTabStop, line); } } catch (IOException e) { // cannot happen } return sb; } /** * Finds the next text wrap position after <code>startPos</code> for the'], ['renderWrappedText(sb, width, nextLineTabStop, text);', ''], ['renderWrappedTextBlock(sb, width, nextLineTabStop, text);', 'private StringBuffer renderWrappedTextBlock(StringBuffer sb, int width, int nextLineTabStop, String text) { try { BufferedReader in = new BufferedReader(new StringReader(text)); String line; boolean firstLine = true; while ((line = in.readLine()) != null) { if (!firstLine) { sb.append(getNewLine()); } else { firstLine = false; } renderWrappedText(sb, width, nextLineTabStop, line); } } catch (IOException e) { } return sb; }'], 'a/src/main/java/org/apache/commons/cli/HelpFormatter.java', 'b/src/main/java/org/apache/commons/cli/HelpFormatter.java']
['Cli-34', 2, 2, 2, 2, ['private int numberOfArgs = UNINITIALIZED; /** the type of this Option */ private Class type; /** the list of argument values **/ private List values = new ArrayList();', 'description = null; argName = null; longopt = null; type = null; required = false; numberOfArgs = Option.UNINITIALIZED; optionalArg = false;'], ['private int numberOfArgs = UNINITIALIZED; /** the type of this Option */ private Class type = String.class; /** the list of argument values **/ private List values = new ArrayList();', 'description = null; argName = null; longopt = null; type = String.class; required = false; numberOfArgs = Option.UNINITIALIZED; optionalArg = false;'], ['private Class type;', 'type = null;'], ['private Class type = String.class;', 'type = String.class;'], 'a/src/main/java/org/apache/commons/cli/OptionBuilder.java', 'b/src/main/java/org/apache/commons/cli/OptionBuilder.java']
['Cli-35', 1, 1, 1, 1, ['List<String> matchingOpts = new ArrayList<String>(); // for a perfect match return the single option only for (String longOpt : longOpts.keySet()) {'], ['List<String> matchingOpts = new ArrayList<String>(); // for a perfect match return the single option only if(longOpts.keySet().contains(opt)) { return Collections.singletonList(opt); } for (String longOpt : longOpts.keySet()) {'], [''], ['if(longOpts.keySet().contains(opt)) { return Collections.singletonList(opt); }'], 'a/src/main/java/org/apache/commons/cli/Options.java', 'b/src/main/java/org/apache/commons/cli/Options.java']
['Cli-36', 4, 4, 4, 4, [' import java.io.Serializable; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; /**', 'private static final long serialVersionUID = 1L; /** hold the options */ private final Map<String, Option> optionMap = new HashMap<String, Option>(); /** the name of the selected option */ private String selected;', 'import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.List;', 'private final List<Object> requiredOpts = new ArrayList<Object>(); /** a map of the option groups */ private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>(); /** * Add the specified option group.'], [' import java.io.Serializable; import java.util.Collection; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; /**', 'private static final long serialVersionUID = 1L; /** hold the options */ private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>(); /** the name of the selected option */ private String selected;', 'import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.List;', 'private final List<Object> requiredOpts = new ArrayList<Object>(); /** a map of the option groups */ private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<String, OptionGroup>(); /** * Add the specified option group.'], ['import java.util.HashMap;', 'private final Map<String, Option> optionMap = new HashMap<String, Option>();', 'import java.util.HashMap;', 'private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>();'], ['import java.util.LinkedHashMap;', 'private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();', '', 'private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<String, OptionGroup>();'], 'a/src/main/java/org/apache/commons/cli/Options.java', 'b/src/main/java/org/apache/commons/cli/Options.java']
['Cli-37', 1, 1, 1, 1, ['private boolean isShortOption(String token) { // short options (-S, -SV, -S=V, -SV1=V2, -S1S2) return token.startsWith("-") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2)); // remove leading "-" and "=value" } /**'], ['private boolean isShortOption(String token) { // short options (-S, -SV, -S=V, -SV1=V2, -S1S2) if (!token.startsWith("-") || token.length() == 1) { return false; } // remove leading "-" and "=value" int pos = token.indexOf("="); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName); } /**'], ['return token.startsWith("-") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));'], ['if (!token.startsWith("-") || token.length() == 1) { return false; } int pos = token.indexOf("="); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName);'], 'a/src/main/java/org/apache/commons/cli/DefaultParser.java', 'b/src/main/java/org/apache/commons/cli/DefaultParser.java']
['Cli-38', 1, 1, 1, 1, ['// remove leading "-" and "=value" int pos = token.indexOf("="); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName); // check for several concatenated short options } /**'], ['// remove leading "-" and "=value" int pos = token.indexOf("="); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); if (options.hasShortOption(optName)) { return true; } // check for several concatenated short options return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0))); } /**'], ['return options.hasShortOption(optName);'], ['if (options.hasShortOption(optName)) { return true; } return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));'], 'a/src/main/java/org/apache/commons/cli/DefaultParser.java', 'b/src/main/java/org/apache/commons/cli/DefaultParser.java']
['Cli-39', 2, 2, 2, 2, ['} else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) {', '* @return The file input stream represented by <code>str</code>. * @throws ParseException if the file is not exist or not readable */ /** * Returns the File[] represented by <code>str</code>.'], ['} else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) {', '* @return The file input stream represented by <code>str</code>. * @throws ParseException if the file is not exist or not readable */ public static FileInputStream openFile(String str) throws ParseException { try { return new FileInputStream(str); } catch (FileNotFoundException e) { throw new ParseException("Unable to find file: " + str); } } /** * Returns the File[] represented by <code>str</code>.'], ['return createFile(str);', ''], ['return openFile(str);', 'public static FileInputStream openFile(String str) throws ParseException { try { return new FileInputStream(str); } catch (FileNotFoundException e) { throw new ParseException("Unable to find file: " + str); } }'], 'a/src/main/java/org/apache/commons/cli/TypeHandler.java', 'b/src/main/java/org/apache/commons/cli/TypeHandler.java']
['Cli-40', 1, 1, 1, 1, ['} else { return null; } }'], ['} else { throw new ParseException("Unable to handle the class: " + clazz); } }'], ['return null;'], ['throw new ParseException("Unable to handle the class: " + clazz);'], 'a/src/main/java/org/apache/commons/cli/TypeHandler.java', 'b/src/main/java/org/apache/commons/cli/TypeHandler.java']
['Chart-1', 1, 1, 1, 1, ['} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount();'], ['} int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset == null) { return result; } int seriesCount = dataset.getRowCount();'], ['if (dataset != null) {'], ['if (dataset == null) {'], 'a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java', 'b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java']
['Chart-2', 2, 2, 2, 2, ['for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } }', 'for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } }'], ['for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double value = intervalXYData.getXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, lvalue); } if (!Double.isNaN(uvalue)) { minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); } }', 'for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double value = ixyd.getYValue(series, item); double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, lvalue); } if (!Double.isNaN(uvalue)) { minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); } }'], ['', ''], ['double value = intervalXYData.getXValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } maximum = Math.max(maximum, lvalue); minimum = Math.min(minimum, uvalue);', 'double value = ixyd.getYValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } maximum = Math.max(maximum, lvalue); minimum = Math.min(minimum, uvalue);'], 'a/source/org/jfree/data/general/DatasetUtilities.java', 'b/source/org/jfree/data/general/DatasetUtilities.java']
['Chart-3', 1, 1, 1, 1, ['throw new IllegalArgumentException("Requires start <= end."); } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) {'], ['throw new IllegalArgumentException("Requires start <= end."); } TimeSeries copy = (TimeSeries) super.clone(); copy.minY = Double.NaN; copy.maxY = Double.NaN; copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) {'], [''], ['copy.minY = Double.NaN; copy.maxY = Double.NaN;'], 'a/source/org/jfree/data/time/TimeSeries.java', 'b/source/org/jfree/data/time/TimeSeries.java']
['Chart-4', 2, 2, 2, 2, ['} } Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) {', 'includedAnnotations.add(a); } } } }'], ['} } if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) {', 'includedAnnotations.add(a); } } } } }'], ['', ''], ['if (r != null) {', '}'], 'a/source/org/jfree/chart/plot/XYPlot.java', 'b/source/org/jfree/chart/plot/XYPlot.java']
['Chart-5', 1, 1, 1, 1, ['if (x == null) { throw new IllegalArgumentException("Null \'x\' argument."); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone();'], ['if (x == null) { throw new IllegalArgumentException("Null \'x\' argument."); } if (this.allowDuplicateXValues) { add(x, y); return null; } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone();'], ['if (index >= 0 && !this.allowDuplicateXValues) {'], ['if (this.allowDuplicateXValues) { add(x, y); return null; } if (index >= 0) {'], 'a/source/org/jfree/data/xy/XYSeries.java', 'b/source/org/jfree/data/xy/XYSeries.java']
['Chart-6', 1, 1, 1, 1, ['if (!(obj instanceof ShapeList)) { return false; } return super.equals(obj); }'], ['if (!(obj instanceof ShapeList)) { return false; } ShapeList that = (ShapeList) obj; int listSize = size(); for (int i = 0; i < listSize; i++) { if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { return false; } } return true; }'], ['return super.equals(obj);'], ['ShapeList that = (ShapeList) obj; int listSize = size(); for (int i = 0; i < listSize; i++) { if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { return false; } } return true;'], 'a/source/org/jfree/chart/util/ShapeList.java', 'b/source/org/jfree/chart/util/ShapeList.java']
['Chart-7', 1, 1, 1, 1, ['} if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) {'], ['} if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) {'], ['long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()'], ['long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()'], 'source/org/jfree/data/time/TimePeriodValues.java\t(revision 1087)', 'source/org/jfree/data/time/TimePeriodValues.java\t(revision 1086)']
['Chart-8', 1, 1, 1, 1, ['*/ public Week(Date time, TimeZone zone) { // defer argument checking... this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); } /**'], ['*/ public Week(Date time, TimeZone zone) { // defer argument checking... this(time, zone, Locale.getDefault()); } /**'], ['this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());'], ['this(time, zone, Locale.getDefault());'], 'a/source/org/jfree/data/time/Week.java', 'b/source/org/jfree/data/time/Week.java']
['Chart-9', 1, 1, 1, 1, ['endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) {'], ['endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if ((endIndex < 0) || (endIndex < startIndex)) { emptyRange = true; } if (emptyRange) {'], ['if (endIndex < 0) {'], ['if ((endIndex < 0) || (endIndex < startIndex)) {'], 'a/source/org/jfree/data/time/TimeSeries.java', 'b/source/org/jfree/data/time/TimeSeries.java']
['Chart-10', 1, 1, 1, 1, ['* @return The formatted HTML area tag attribute(s). */ public String generateToolTipFragment(String toolTipText) { return " title=\\"" + toolTipText + "\\" alt=\\"\\""; }'], ['* @return The formatted HTML area tag attribute(s). */ public String generateToolTipFragment(String toolTipText) { return " title=\\"" + ImageMapUtilities.htmlEscape(toolTipText) + "\\" alt=\\"\\""; }'], ['return " title=\\"" + toolTipText'], ['return " title=\\"" + ImageMapUtilities.htmlEscape(toolTipText)'], 'a/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java', 'b/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java']
['Chart-11', 1, 1, 1, 1, ['return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();'], ['return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone();'], ['PathIterator iterator2 = p1.getPathIterator(null);'], ['PathIterator iterator2 = p2.getPathIterator(null);'], 'a/source/org/jfree/chart/util/ShapeUtilities.java', 'b/source/org/jfree/chart/util/ShapeUtilities.java']
['Chart-12', 1, 1, 1, 1, ['*/ public MultiplePiePlot(CategoryDataset dataset) { super(); this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend();'], ['*/ public MultiplePiePlot(CategoryDataset dataset) { super(); setDataset(dataset); PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend();'], ['this.dataset = dataset;'], ['setDataset(dataset);'], 'a/source/org/jfree/chart/plot/MultiplePiePlot.java', 'b/source/org/jfree/chart/plot/MultiplePiePlot.java']
['Chart-13', 1, 1, 1, 1, ['h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4);'], ['h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4);'], ['new Range(0.0, constraint.getWidth() - w[2]),'], ['new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),'], 'a/source/org/jfree/chart/block/BorderArrangement.java', 'b/source/org/jfree/chart/block/BorderArrangement.java']
['Chart-14', 4, 4, 4, 4, ['markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();'], ['markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();', 'markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent();'], ['', '', '', ''], ['if (markers == null) { return false; }', 'if (markers == null) { return false; }', 'if (markers == null) { return false; }', 'if (markers == null) { return false; }'], 'a/source/org/jfree/chart/plot/XYPlot.java', 'b/source/org/jfree/chart/plot/XYPlot.java']
['Chart-15', 2, 2, 2, 2, ['* @return The percent. */ public double getMaximumExplodePercent() { double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {', ' PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); state.setLatestAngle(plot.getStartAngle()); return state;'], ['* @return The percent. */ public double getMaximumExplodePercent() { if (this.dataset == null) { return 0.0; } double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) {', ' PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); if (this.dataset != null) { state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); } state.setLatestAngle(plot.getStartAngle()); return state;'], ['', ''], ['if (this.dataset == null) { return 0.0; }', 'if (this.dataset != null) { }'], 'a/source/org/jfree/chart/plot/PiePlot.java', 'b/source/org/jfree/chart/plot/PiePlot.java']
['Chart-16', 2, 2, 2, 2, [' } else { this.seriesKeys = null; this.categoryKeys = null; } }', 'if (categoryKeys == null) { throw new IllegalArgumentException("Null \'categoryKeys\' argument."); } if (categoryKeys.length != this.startData[0].length) { throw new IllegalArgumentException( "The number of categories does not match the data."); }'], [' } else { this.seriesKeys = new Comparable[0]; this.categoryKeys = new Comparable[0]; } }', 'if (categoryKeys == null) { throw new IllegalArgumentException("Null \'categoryKeys\' argument."); } if (categoryKeys.length != getCategoryCount()) { throw new IllegalArgumentException( "The number of categories does not match the data."); }'], ['this.seriesKeys = null; this.categoryKeys = null;', 'if (categoryKeys.length != this.startData[0].length) {'], ['this.seriesKeys = new Comparable[0]; this.categoryKeys = new Comparable[0];', 'if (categoryKeys.length != getCategoryCount()) {'], 'a/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java', 'b/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java']
['Chart-17', 1, 1, 1, 1, ['* subclasses may differ. */ public Object clone() throws CloneNotSupportedException { Object clone = createCopy(0, getItemCount() - 1); return clone; }'], ['* subclasses may differ. */ public Object clone() throws CloneNotSupportedException { TimeSeries clone = (TimeSeries) super.clone(); clone.data = (List) ObjectUtilities.deepClone(this.data); return clone; }'], ['Object clone = createCopy(0, getItemCount() - 1);'], ['TimeSeries clone = (TimeSeries) super.clone(); clone.data = (List) ObjectUtilities.deepClone(this.data);'], 'a/source/org/jfree/data/time/TimeSeries.java', 'b/source/org/jfree/data/time/TimeSeries.java']
['Chart-18', 3, 3, 3, 3, ['public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); if (index < this.keys.size()) { rebuildIndex(); } } /**', 'public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { return; } removeValue(index); }', '* @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); rowData.removeValue(columnKey); } this.columnKeys.remove(columnKey); }'], ['public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); rebuildIndex(); } /**', 'public void removeValue(Comparable key) { int index = getIndex(key); if (index < 0) { throw new UnknownKeyException("The key (" + key + ") is not recognised."); } removeValue(index); }', '* @see #removeRow(Comparable) */ public void removeColumn(Comparable columnKey) { if (columnKey == null) { throw new IllegalArgumentException("Null \'columnKey\' argument."); } if (!this.columnKeys.contains(columnKey)) { throw new UnknownKeyException("Unknown key: " + columnKey); } Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next(); int index = rowData.getIndex(columnKey); if (index >= 0) { rowData.removeValue(columnKey); } } this.columnKeys.remove(columnKey); }'], ['if (index < this.keys.size()) { }', 'return;', ''], ['', 'throw new UnknownKeyException("The key (" + key + ") is not recognised.");', 'if (columnKey == null) { throw new IllegalArgumentException("Null \'columnKey\' argument."); } if (!this.columnKeys.contains(columnKey)) { throw new UnknownKeyException("Unknown key: " + columnKey); } int index = rowData.getIndex(columnKey); if (index >= 0) { }'], 'a/source/org/jfree/data/DefaultKeyedValues2D.java', 'b/source/org/jfree/data/DefaultKeyedValues2D.java']
['Chart-19', 2, 2, 2, 2, ['* @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { return this.domainAxes.indexOf(axis); }', '* @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();'], ['* @since 1.0.3 */ public int getDomainAxisIndex(CategoryAxis axis) { if (axis == null) { throw new IllegalArgumentException("Null \'axis\' argument."); } return this.domainAxes.indexOf(axis); }', '* @since 1.0.7 */ public int getRangeAxisIndex(ValueAxis axis) { if (axis == null) { throw new IllegalArgumentException("Null \'axis\' argument."); } int result = this.rangeAxes.indexOf(axis); if (result < 0) { // try the parent plot Plot parent = getParent();'], ['', ''], ['if (axis == null) { throw new IllegalArgumentException("Null \'axis\' argument."); }', 'if (axis == null) { throw new IllegalArgumentException("Null \'axis\' argument."); }'], 'a/source/org/jfree/chart/plot/CategoryPlot.java', 'b/source/org/jfree/chart/plot/CategoryPlot.java']
['Chart-20', 1, 1, 1, 1, ['*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { super(paint, stroke, paint, stroke, alpha); this.value = value; }'], ['*/ public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; }'], ['super(paint, stroke, paint, stroke, alpha);'], ['super(paint, stroke, outlinePaint, outlineStroke, alpha);'], 'a/source/org/jfree/chart/plot/ValueMarker.java', 'b/source/org/jfree/chart/plot/ValueMarker.java']
['Chart-21', 3, 3, 3, 3, ['&& this.minimumRangeValueColumn == c)) { updateBounds(); } double minval = Double.NaN; if (item.getMinOutlier() != null) {', 'this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } this.rangeBounds = new Range(this.minimumRangeValue, this.maximumRangeValue);', '*/ private void updateBounds() { this.minimumRangeValue = Double.NaN; this.maximumRangeValue = Double.NaN; } /**'], ['&& this.minimumRangeValueColumn == c)) { updateBounds(); } else { double minval = Double.NaN; if (item.getMinOutlier() != null) {', 'this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } } this.rangeBounds = new Range(this.minimumRangeValue, this.maximumRangeValue);', '*/ private void updateBounds() { this.minimumRangeValue = Double.NaN; this.minimumRangeValueRow = -1; this.minimumRangeValueColumn = -1; this.maximumRangeValue = Double.NaN; this.maximumRangeValueRow = -1; this.maximumRangeValueColumn = -1; int rowCount = getRowCount(); int columnCount = getColumnCount(); for (int r = 0; r < rowCount; r++) { for (int c = 0; c < columnCount; c++) { BoxAndWhiskerItem item = getItem(r, c); if (item != null) { Number min = item.getMinOutlier(); if (min != null) { double minv = min.doubleValue(); if (!Double.isNaN(minv)) { if (minv < this.minimumRangeValue || Double.isNaN( this.minimumRangeValue)) { this.minimumRangeValue = minv; this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } } } Number max = item.getMaxOutlier(); if (max != null) { double maxv = max.doubleValue(); if (!Double.isNaN(maxv)) { if (maxv > this.maximumRangeValue || Double.isNaN( this.maximumRangeValue)) { this.maximumRangeValue = maxv; this.maximumRangeValueRow = r; this.maximumRangeValueColumn = c; } } } } } } } /**'], ['', '', ''], ['else {', '}', 'this.minimumRangeValueRow = -1; this.minimumRangeValueColumn = -1; this.maximumRangeValueRow = -1; this.maximumRangeValueColumn = -1; int rowCount = getRowCount(); int columnCount = getColumnCount(); for (int r = 0; r < rowCount; r++) { for (int c = 0; c < columnCount; c++) { BoxAndWhiskerItem item = getItem(r, c); if (item != null) { Number min = item.getMinOutlier(); if (min != null) { double minv = min.doubleValue(); if (!Double.isNaN(minv)) { if (minv < this.minimumRangeValue || Double.isNaN( this.minimumRangeValue)) { this.minimumRangeValue = minv; this.minimumRangeValueRow = r; this.minimumRangeValueColumn = c; } } } Number max = item.getMaxOutlier(); if (max != null) { double maxv = max.doubleValue(); if (!Double.isNaN(maxv)) { if (maxv > this.maximumRangeValue || Double.isNaN( this.maximumRangeValue)) { this.maximumRangeValue = maxv; this.maximumRangeValueRow = r; this.maximumRangeValueColumn = c; } } } } } }'], 'a/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java', 'b/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java']
['Chart-22', 4, 4, 4, 4, ['throw new UnknownKeyException("Column key (" + columnKey + ") not recognised."); } if (row >= 0) { KeyedObjects rowData = (KeyedObjects) this.rows.get(row); return rowData.getObject(columnKey); } else { return null;', '} // 2. check whether the column is now empty. } /**', '*/ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); removeRow(index); }', 'Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { KeyedObjects rowData = (KeyedObjects) iterator.next(); rowData.removeValue(columnKey); } this.columnKeys.remove(columnKey); }'], ['throw new UnknownKeyException("Column key (" + columnKey + ") not recognised."); } KeyedObjects rowData = (KeyedObjects) this.rows.get(row); int index = rowData.getIndex(columnKey); if (index >= 0) { return rowData.getObject(index); } else { return null;', '} // 2. check whether the column is now empty. allNull = true; for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getObject(columnIndex) != null) { allNull = false; break; } } if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0) { row.removeValue(columnIndex); } } this.columnKeys.remove(columnKey); } } /**', '*/ public void removeRow(Comparable rowKey) { int index = getRowIndex(rowKey); if (index < 0) { throw new UnknownKeyException("Row key (" + rowKey + ") not recognised."); } removeRow(index); }', 'Iterator iterator = this.rows.iterator(); while (iterator.hasNext()) { KeyedObjects rowData = (KeyedObjects) iterator.next(); int i = rowData.getIndex(columnKey); if (i >= 0) { rowData.removeValue(i); } } this.columnKeys.remove(columnKey); }'], ['if (row >= 0) { return rowData.getObject(columnKey);', '', '', 'rowData.removeValue(columnKey);'], ['int index = rowData.getIndex(columnKey); if (index >= 0) { return rowData.getObject(index);', 'allNull = true; for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getObject(columnIndex) != null) { allNull = false; break; } } if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0) { row.removeValue(columnIndex); } } this.columnKeys.remove(columnKey); }', 'if (index < 0) { throw new UnknownKeyException("Row key (" + rowKey + ") not recognised."); }', 'int i = rowData.getIndex(columnKey); if (i >= 0) { rowData.removeValue(i); }'], 'a/source/org/jfree/data/KeyedObjects2D.java', 'b/source/org/jfree/data/KeyedObjects2D.java']
['Chart-23', 1, 1, 1, 1, ['* * @since 1.0.7 */ /** * Returns an icon.'], ['* * @since 1.0.7 */ public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof MinMaxCategoryRenderer)) { return false; } MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; if (this.plotLines != that.plotLines) { return false; } if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { return false; } if (!this.groupStroke.equals(that.groupStroke)) { return false; } return super.equals(obj); } /** * Returns an icon.'], [''], ['public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof MinMaxCategoryRenderer)) { return false; } MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; if (this.plotLines != that.plotLines) { return false; } if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { return false; } if (!this.groupStroke.equals(that.groupStroke)) { return false; } return super.equals(obj); }'], 'a/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java', 'b/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java']
['Chart-24', 1, 1, 1, 1, ['public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }'], ['public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }'], ['int g = (int) ((value - this.lowerBound) / (this.upperBound'], ['int g = (int) ((v - this.lowerBound) / (this.upperBound'], 'a/source/org/jfree/chart/renderer/GrayPaintScale.java', 'b/source/org/jfree/chart/renderer/GrayPaintScale.java']
['Chart-25', 6, 6, 6, 6, [' // BAR X Number meanValue = dataset.getMeanValue(row, column); double value = meanValue.doubleValue(); double base = 0.0;', '} // standard deviation lines double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()', 'line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, lowVal, rectY + rectHeight * 0.75); g2.draw(line); CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);', ' // BAR Y Number meanValue = dataset.getMeanValue(row, column); double value = meanValue.doubleValue(); double base = 0.0;', '} // standard deviation lines double valueDelta = dataset.getStdDevValue(row, column).doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()', 'line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal, rectX + rectWidth / 2.0d + 5.0d, lowVal); g2.draw(line); CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);'], [' // BAR X Number meanValue = dataset.getMeanValue(row, column); if (meanValue == null) { return; } double value = meanValue.doubleValue(); double base = 0.0;', '} // standard deviation lines Number n = dataset.getStdDevValue(row, column); if (n != null) { double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()', 'line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, lowVal, rectY + rectHeight * 0.75); g2.draw(line); } CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);', ' // BAR Y Number meanValue = dataset.getMeanValue(row, column); if (meanValue == null) { return; } double value = meanValue.doubleValue(); double base = 0.0;', '} // standard deviation lines Number n = dataset.getStdDevValue(row, column); if (n != null) { double valueDelta = n.doubleValue(); double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() + valueDelta, dataArea, yAxisLocation); double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()', 'line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal, rectX + rectWidth / 2.0d + 5.0d, lowVal); g2.draw(line); } CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column);'], ['', 'double valueDelta = dataset.getStdDevValue(row, column).doubleValue();', '', '', 'double valueDelta = dataset.getStdDevValue(row, column).doubleValue();', ''], ['if (meanValue == null) { return; }', 'Number n = dataset.getStdDevValue(row, column); if (n != null) { double valueDelta = n.doubleValue();', '}', 'if (meanValue == null) { return; }', 'Number n = dataset.getStdDevValue(row, column); if (n != null) { double valueDelta = n.doubleValue();', '}'], 'a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java', 'b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java']
['Chart-26', 1, 1, 1, 1, ['} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } } return state;'], ['} if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } } } return state;'], [''], ['if (owner != null) { }'], 'a/source/org/jfree/chart/axis/Axis.java', 'b/source/org/jfree/chart/axis/Axis.java']
['Lang-1', 1, 1, 1, 1, ['} } if (pfxLen > 0) { // we have a hex number final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { // too many for Long return createBigInteger(str); } if (hexDigits > 8) { // too many for an int return createLong(str); } return createInteger(str);'], ["} } if (pfxLen > 0) { // we have a hex number char firstSigDigit = 0; // strip leading zeroes for(int i = pfxLen; i < str.length(); i++) { firstSigDigit = str.charAt(i); if (firstSigDigit == '0') { // count leading zeroes pfxLen++; } else { break; } } final int hexDigits = str.length() - pfxLen; if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int return createLong(str); } return createInteger(str);"], ['if (hexDigits > 16) { // too many for Long if (hexDigits > 8) { // too many for an int'], ["char firstSigDigit = 0; // strip leading zeroes for(int i = pfxLen; i < str.length(); i++) { firstSigDigit = str.charAt(i); if (firstSigDigit == '0') { // count leading zeroes pfxLen++; } else { break; } } if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int"], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-2', 1, 1, 1, 1, ['if (str == null) { return null; } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException("Invalid locale format: " + str);'], ['if (str == null) { return null; } if (str.contains("#")) { // LANG-879 - Cannot handle Java 7 script & extensions throw new IllegalArgumentException("Invalid locale format: " + str); } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException("Invalid locale format: " + str);'], [''], ['if (str.contains("#")) { // LANG-879 - Cannot handle Java 7 script & extensions throw new IllegalArgumentException("Invalid locale format: " + str); }'], 'a/src/main/java/org/apache/commons/lang3/LocaleUtils.java', 'b/src/main/java/org/apache/commons/lang3/LocaleUtils.java']
['Lang-3', 1, 1, 1, 1, ['//Must be a Float, Double, BigDecimal final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number } try { final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number }'], ['//Must be a Float, Double, BigDecimal final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number } try { if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number }'], [''], ['if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float } if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double }'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-4', 3, 3, 3, 3, ['*/ public class LookupTranslator extends CharSequenceTranslator { private final HashMap<CharSequence, CharSequence> lookupMap; private final int shortest; private final int longest;', '* @param lookup CharSequence[][] table of size [*][2] */ public LookupTranslator(final CharSequence[]... lookup) { lookupMap = new HashMap<CharSequence, CharSequence>(); int _shortest = Integer.MAX_VALUE; int _longest = 0; if (lookup != null) { for (final CharSequence[] seq : lookup) { this.lookupMap.put(seq[0], seq[1]); final int sz = seq[0].length(); if (sz < _shortest) { _shortest = sz;', '// descend so as to get a greedy algorithm for (int i = max; i >= shortest; i--) { final CharSequence subSeq = input.subSequence(index, index + i); final CharSequence result = lookupMap.get(subSeq); if (result != null) { out.write(result.toString()); return i;'], ['*/ public class LookupTranslator extends CharSequenceTranslator { private final HashMap<String, CharSequence> lookupMap; private final int shortest; private final int longest;', '* @param lookup CharSequence[][] table of size [*][2] */ public LookupTranslator(final CharSequence[]... lookup) { lookupMap = new HashMap<String, CharSequence>(); int _shortest = Integer.MAX_VALUE; int _longest = 0; if (lookup != null) { for (final CharSequence[] seq : lookup) { this.lookupMap.put(seq[0].toString(), seq[1]); final int sz = seq[0].length(); if (sz < _shortest) { _shortest = sz;', '// descend so as to get a greedy algorithm for (int i = max; i >= shortest; i--) { final CharSequence subSeq = input.subSequence(index, index + i); final CharSequence result = lookupMap.get(subSeq.toString()); if (result != null) { out.write(result.toString()); return i;'], ['private final HashMap<CharSequence, CharSequence> lookupMap;', 'lookupMap = new HashMap<CharSequence, CharSequence>(); this.lookupMap.put(seq[0], seq[1]);', 'final CharSequence result = lookupMap.get(subSeq);'], ['private final HashMap<String, CharSequence> lookupMap;', 'lookupMap = new HashMap<String, CharSequence>(); this.lookupMap.put(seq[0].toString(), seq[1]);', 'final CharSequence result = lookupMap.get(subSeq.toString());'], 'a/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java']
['Lang-5', 2, 2, 2, 2, ['throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch0 = str.charAt(0); final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str);', 'throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); } //-----------------------------------------------------------------------'], ['throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch0 = str.charAt(0); if (ch0 == \'_\') { if (len < 3) { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch1 = str.charAt(1); final char ch2 = str.charAt(2); if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 3) { return new Locale("", str.substring(1, 3)); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(3) != \'_\') { throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale("", str.substring(1, 3), str.substring(4)); } else { final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str);', 'throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); } } //-----------------------------------------------------------------------'], ['', ''], ['if (ch0 == \'_\') { if (len < 3) { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch1 = str.charAt(1); final char ch2 = str.charAt(2); if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 3) { return new Locale("", str.substring(1, 3)); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(3) != \'_\') { throw new IllegalArgumentException("Invalid locale format: " + str); } return new Locale("", str.substring(1, 3), str.substring(4)); } else {', '}'], 'a/src/main/java/org/apache/commons/lang3/LocaleUtils.java', 'b/src/main/java/org/apache/commons/lang3/LocaleUtils.java']
['Lang-6', 1, 1, 1, 1, ['// // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pos)); } } }'], ['// // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pt)); } } }'], ['pos += Character.charCount(Character.codePointAt(input, pos));'], ['pos += Character.charCount(Character.codePointAt(input, pt));'], 'a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java']
['Lang-7', 2, 2, 2, 2, ['if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith("-")) { // drop -', 'if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return new BigDecimal(str); }'], ['if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; // drop 0x if (str.startsWith("-")) { // drop -', 'if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.trim().startsWith("--")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. throw new NumberFormatException(str + " is not a valid number."); } return new BigDecimal(str); }'], ['if (str.startsWith("--")) { return null; }', ''], ['', 'if (str.trim().startsWith("--")) { throw new NumberFormatException(str + " is not a valid number."); }'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-8', 3, 3, 3, 3, ['private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; private final TimeZone zone; private final String mStandard; private final String mDaylight;', 'TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) { mLocale = locale; mStyle = style; zone = timeZone; mStandard = getTimeZoneDisplay(timeZone, false, style, locale); mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);', '*/ @Override public void appendTo(StringBuffer buffer, Calendar calendar) { if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));'], ['private static class TimeZoneNameRule implements Rule { private final Locale mLocale; private final int mStyle; private final String mStandard; private final String mDaylight;', 'TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) { mLocale = locale; mStyle = style; mStandard = getTimeZoneDisplay(timeZone, false, style, locale); mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);', '*/ @Override public void appendTo(StringBuffer buffer, Calendar calendar) { TimeZone zone = calendar.getTimeZone(); if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));'], ['private final TimeZone zone;', 'zone = timeZone;', ''], ['', '', 'TimeZone zone = calendar.getTimeZone();'], 'a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java']
['Lang-9', 1, 1, 1, 1, ['currentFormatField= nextFormatField; currentStrategy= nextStrategy; } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); }'], ['currentFormatField= nextFormatField; currentStrategy= nextStrategy; } if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { throw new IllegalArgumentException("Failed to parse \\""+pattern+"\\" ; gave up at index "+patternMatcher.regionStart()); } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); }'], [''], ['if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { throw new IllegalArgumentException("Failed to parse \\""+pattern+"\\" ; gave up at index "+patternMatcher.regionStart()); }'], 'a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java']
['Lang-10', 1, 1, 1, 1, ['* @return The <code>StringBuilder</code> */ private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append("\\\\s*+"); } continue; } wasWhite= false; switch(c) { case \'\\\'\': if(unquote) {'], ["* @return The <code>StringBuilder</code> */ private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); switch(c) { case '\\'': if(unquote) {"], ['boolean wasWhite= false; if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append("\\\\s*+"); } continue; } wasWhite= false;'], [''], 'a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java']
['Lang-11', 1, 1, 1, 1, ["start = ' '; } } } char[] buffer = new char[count];"], ['start = \' \'; } } } else { if (end <= start) { throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); } } char[] buffer = new char[count];'], [''], ['} else { if (end <= start) { throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); }'], 'a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java', 'b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java']
['Lang-12', 1, 1, 1, 1, ['} else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = \'z\' + 1; start = \' \'; } } char[] buffer = new char[count];'], ['} else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); } if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = \'z\' + 1; start = \' \'; } } } char[] buffer = new char[count];'], [''], ['if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); } if (chars != null) { end = chars.length; } else { }'], 'a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java', 'b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java']
['Lang-13', 3, 3, 3, 3, ['* class here is a workaround, see the JIRA issue LANG-626. </p> */ static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private ClassLoader classLoader; /**', 'super(in); this.classLoader = classLoader; } /**', 'try { return Class.forName(name, false, classLoader); } catch (ClassNotFoundException ex) { return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); } }'], ['* class here is a workaround, see the JIRA issue LANG-626. </p> */ static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private static final Map<String, Class<?>> primitiveTypes = new HashMap<String, Class<?>>(); private ClassLoader classLoader; /**', 'super(in); this.classLoader = classLoader; primitiveTypes.put("byte", byte.class); primitiveTypes.put("short", short.class); primitiveTypes.put("int", int.class); primitiveTypes.put("long", long.class); primitiveTypes.put("float", float.class); primitiveTypes.put("double", double.class); primitiveTypes.put("boolean", boolean.class); primitiveTypes.put("char", char.class); primitiveTypes.put("void", void.class); } /**', 'try { return Class.forName(name, false, classLoader); } catch (ClassNotFoundException ex) { try { return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); } catch (ClassNotFoundException cnfe) { Class<?> cls = primitiveTypes.get(name); if (cls != null) return cls; else throw cnfe; } } }'], ['', '', ''], ['private static final Map<String, Class<?>> primitiveTypes = new HashMap<String, Class<?>>();', 'primitiveTypes.put("byte", byte.class); primitiveTypes.put("short", short.class); primitiveTypes.put("int", int.class); primitiveTypes.put("long", long.class); primitiveTypes.put("float", float.class); primitiveTypes.put("double", double.class); primitiveTypes.put("boolean", boolean.class); primitiveTypes.put("char", char.class); primitiveTypes.put("void", void.class);', 'try { } catch (ClassNotFoundException cnfe) { Class<?> cls = primitiveTypes.get(name); if (cls != null) return cls; else throw cnfe; }'], 'a/src/main/java/org/apache/commons/lang3/SerializationUtils.java', 'b/src/main/java/org/apache/commons/lang3/SerializationUtils.java']
['Lang-14', 1, 1, 1, 1, ['if (cs1 == null || cs2 == null) { return false; } return cs1.equals(cs2); } /**'], ['if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); } /**'], [''], ['if (cs1 instanceof String && cs2 instanceof String) { } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));'], 'a/src/main/java/org/apache/commons/lang3/StringUtils.java', 'b/src/main/java/org/apache/commons/lang3/StringUtils.java']
['Lang-15', 2, 2, 2, 2, ['toClass, typeVarAssigns); // now to check each type argument for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { Type toTypeArg = entry.getValue(); Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); // parameters must either be absent from the subject type, within // the bounds of the wildcard type, or be an exact match to the', ': new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); // has target class been reached? if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) { return typeVarAssigns; }'], ['toClass, typeVarAssigns); // now to check each type argument for (TypeVariable<?> var : toTypeVarAssigns.keySet()) { Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); // parameters must either be absent from the subject type, within // the bounds of the wildcard type, or be an exact match to the', ': new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); // has target class been reached? if (toClass.equals(cls)) { return typeVarAssigns; }'], ['for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) { Type toTypeArg = entry.getValue(); Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());', 'if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {'], ['for (TypeVariable<?> var : toTypeVarAssigns.keySet()) { Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);', 'if (toClass.equals(cls)) {'], 'a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java', 'b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java']
['Lang-16', 1, 1, 1, 1, ['// a wrong value. return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);'], ['// a wrong value. return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1);'], ['if (str.startsWith("0x") || str.startsWith("-0x")) {'], ['if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) {'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-17', 1, 1, 1, 1, ['return; } int pos = 0; int len = Character.codePointCount(input, 0, input.length()); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); } else { // // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); } else { pos++; } } pos--; } pos++; } }'], ['return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } // // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pos)); } } }'], ['int len = Character.codePointCount(input, 0, input.length()); else { if (pos < len - 2) { } else { pos++; } } pos--; pos++;'], ['int len = input.length(); pos+= c.length; continue;'], 'a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java']
['Lang-18', 1, 1, 1, 1, ["rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE; } break; case 'M': // month in year (text and number)"], ["rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) if (tokenLen == 2) { rule = TwoDigitYearField.INSTANCE; } else { rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); } break; case 'M': // month in year (text and number)"], ['if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); rule = TwoDigitYearField.INSTANCE;'], ['if (tokenLen == 2) { rule = TwoDigitYearField.INSTANCE; rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);'], 'a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java']
['Lang-19', 3, 3, 3, 3, ["public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); // Uses -2 to ensure there is something after the &# if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;", "isHex = true; // Check there's more than just an x after the &# } int end = start; // Note that this supports character codes without a ; on the end while(input.charAt(end) != ';') { end++; }", 'out.write(entityValue); } return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0; }'], ["public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); // Uses -2 to ensure there is something after the &# if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;", "isHex = true; // Check there's more than just an x after the &# if(start == seqEnd) { return 0; } } int end = start; // Note that this supports character codes without a ; on the end while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') || (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) ) { end++; }", "out.write(entityValue); } boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';'); return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0); } return 0; }"], ["if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {", "while(input.charAt(end) != ';')", 'return 2 + (end - start) + (isHex ? 1 : 0) + 1;'], ["if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {", "if(start == seqEnd) { return 0; } while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') || (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )", "boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';'); return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);"], 'a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java']
['Lang-20', 2, 2, 2, 2, ['return EMPTY; } StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {', 'return EMPTY; } StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {'], ['return EMPTY; } StringBuilder buf = new StringBuilder(noOfItems * 16); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {', 'return EMPTY; } StringBuilder buf = new StringBuilder(noOfItems * 16); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {'], ['StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);', 'StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());'], ['StringBuilder buf = new StringBuilder(noOfItems * 16);', 'StringBuilder buf = new StringBuilder(noOfItems * 16);'], 'a/src/main/java/org/apache/commons/lang3/StringUtils.java', 'b/src/main/java/org/apache/commons/lang3/StringUtils.java']
['Lang-21', 1, 1, 1, 1, ['return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&'], ['return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&'], ['cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&'], ['cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&'], 'a/src/main/java/org/apache/commons/lang3/time/DateUtils.java', 'b/src/main/java/org/apache/commons/lang3/time/DateUtils.java']
['Lang-22', 1, 1, 1, 1, ['*/ private static int greatestCommonDivisor(int u, int v) { // From Commons Math: //if either operand is abs 1, return 1: if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { return 1; } // keep u and v negative, as negative integers range down to'], ['*/ private static int greatestCommonDivisor(int u, int v) { // From Commons Math: if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw new ArithmeticException("overflow: gcd is 2^31"); } return Math.abs(u) + Math.abs(v); } //if either operand is abs 1, return 1: if (Math.abs(u) == 1 || Math.abs(v) == 1) { return 1; } // keep u and v negative, as negative integers range down to'], ['if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {'], ['if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw new ArithmeticException("overflow: gcd is 2^31"); } return Math.abs(u) + Math.abs(v); } if (Math.abs(u) == 1 || Math.abs(v) == 1) {'], 'a/src/main/java/org/apache/commons/lang3/math/Fraction.java', 'b/src/main/java/org/apache/commons/lang3/math/Fraction.java']
['Lang-23', 2, 2, 2, 2, ['*/ public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; private static final String DUMMY_PATTERN = ""; private static final String ESCAPED_QUOTE = "\'\'";', '* @param obj the object to compare to * @return true if this object equals the other, otherwise false */ /** * Return the hashcode. * * @return the hashcode */ /** * Get a custom format from a format description.'], ['*/ public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = -2362048321261811743L; private static final int HASH_SEED = 31; private static final String DUMMY_PATTERN = ""; private static final String ESCAPED_QUOTE = "\'\'";', '* @param obj the object to compare to * @return true if this object equals the other, otherwise false */ @Override public boolean equals(Object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (!super.equals(obj)) { return false; } if (ObjectUtils.notEqual(getClass(), obj.getClass())) { return false; } ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj; if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { return false; } if (ObjectUtils.notEqual(registry, rhs.registry)) { return false; } return true; } /** * Return the hashcode. * * @return the hashcode */ @Override public int hashCode() { int result = super.hashCode(); result = HASH_SEED * result + ObjectUtils.hashCode(registry); result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); return result; } /** * Get a custom format from a format description.'], ['', ''], ['private static final int HASH_SEED = 31;', '@Override public boolean equals(Object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (!super.equals(obj)) { return false; } if (ObjectUtils.notEqual(getClass(), obj.getClass())) { return false; } ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj; if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { return false; } if (ObjectUtils.notEqual(registry, rhs.registry)) { return false; } return true; } @Override public int hashCode() { int result = super.hashCode(); result = HASH_SEED * result + ObjectUtils.hashCode(registry); result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); return result; }'], 'a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java', 'b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java']
['Lang-24', 1, 1, 1, 1, ["if (chars[i] == 'l' || chars[i] == 'L') { // not allowing L with an exponent or decimal point return foundDigit && !hasExp; } // last character is illegal return false;"], ["if (chars[i] == 'l' || chars[i] == 'L') { // not allowing L with an exponent or decimal point return foundDigit && !hasExp && !hasDecPoint; } // last character is illegal return false;"], ['return foundDigit && !hasExp;'], ['return foundDigit && !hasExp && !hasDecPoint;'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-25', 1, 1, 1, 1, ['{"\\u00C7", "&Ccedil;"}, // - uppercase C, cedilla {"\\u00C8", "&Egrave;"}, // - uppercase E, grave accent {"\\u00C9", "&Eacute;"}, // - uppercase E, acute accent {"\\u00CB", "&Ecirc;"}, // - uppercase E, circumflex accent {"\\u00CC", "&Euml;"}, // - uppercase E, umlaut {"\\u00CD", "&Igrave;"}, // - uppercase I, grave accent {"\\u00CE", "&Iacute;"}, // - uppercase I, acute accent {"\\u00CF", "&Icirc;"}, // - uppercase I, circumflex accent {"\\u00D0", "&Iuml;"}, // - uppercase I, umlaut {"\\u00D1", "&ETH;"}, // - uppercase Eth, Icelandic {"\\u00D2", "&Ntilde;"}, // - uppercase N, tilde {"\\u00D3", "&Ograve;"}, // - uppercase O, grave accent {"\\u00D4", "&Oacute;"}, // - uppercase O, acute accent {"\\u00D5", "&Ocirc;"}, // - uppercase O, circumflex accent {"\\u00D6", "&Otilde;"}, // - uppercase O, tilde {"\\u00D7", "&Ouml;"}, // - uppercase O, umlaut {"\\u00D8", "&times;"}, // multiplication sign {"\\u00D9", "&Oslash;"}, // - uppercase O, slash {"\\u00DA", "&Ugrave;"}, // - uppercase U, grave accent {"\\u00DB", "&Uacute;"}, // - uppercase U, acute accent {"\\u00DC", "&Ucirc;"}, // - uppercase U, circumflex accent {"\\u00DD", "&Uuml;"}, // - uppercase U, umlaut {"\\u00DE", "&Yacute;"}, // - uppercase Y, acute accent {"\\u00DF", "&THORN;"}, // - uppercase THORN, Icelandic {"\\u00E0", "&szlig;"}, // - lowercase sharps, German {"\\u00E1", "&agrave;"}, // - lowercase a, grave accent {"\\u00E2", "&aacute;"}, // - lowercase a, acute accent {"\\u00E3", "&acirc;"}, // - lowercase a, circumflex accent {"\\u00E4", "&atilde;"}, // - lowercase a, tilde {"\\u00E5", "&auml;"}, // - lowercase a, umlaut {"\\u00E5", "&aring;"}, // - lowercase a, ring {"\\u00E6", "&aelig;"}, // - lowercase ae {"\\u00E7", "&ccedil;"}, // - lowercase c, cedilla'], ['{"\\u00C7", "&Ccedil;"}, // - uppercase C, cedilla {"\\u00C8", "&Egrave;"}, // - uppercase E, grave accent {"\\u00C9", "&Eacute;"}, // - uppercase E, acute accent {"\\u00CA", "&Ecirc;"}, // - uppercase E, circumflex accent {"\\u00CB", "&Euml;"}, // - uppercase E, umlaut {"\\u00CC", "&Igrave;"}, // - uppercase I, grave accent {"\\u00CD", "&Iacute;"}, // - uppercase I, acute accent {"\\u00CE", "&Icirc;"}, // - uppercase I, circumflex accent {"\\u00CF", "&Iuml;"}, // - uppercase I, umlaut {"\\u00D0", "&ETH;"}, // - uppercase Eth, Icelandic {"\\u00D1", "&Ntilde;"}, // - uppercase N, tilde {"\\u00D2", "&Ograve;"}, // - uppercase O, grave accent {"\\u00D3", "&Oacute;"}, // - uppercase O, acute accent {"\\u00D4", "&Ocirc;"}, // - uppercase O, circumflex accent {"\\u00D5", "&Otilde;"}, // - uppercase O, tilde {"\\u00D6", "&Ouml;"}, // - uppercase O, umlaut {"\\u00D7", "&times;"}, // multiplication sign {"\\u00D8", "&Oslash;"}, // - uppercase O, slash {"\\u00D9", "&Ugrave;"}, // - uppercase U, grave accent {"\\u00DA", "&Uacute;"}, // - uppercase U, acute accent {"\\u00DB", "&Ucirc;"}, // - uppercase U, circumflex accent {"\\u00DC", "&Uuml;"}, // - uppercase U, umlaut {"\\u00DD", "&Yacute;"}, // - uppercase Y, acute accent {"\\u00DE", "&THORN;"}, // - uppercase THORN, Icelandic {"\\u00DF", "&szlig;"}, // - lowercase sharps, German {"\\u00E0", "&agrave;"}, // - lowercase a, grave accent {"\\u00E1", "&aacute;"}, // - lowercase a, acute accent {"\\u00E2", "&acirc;"}, // - lowercase a, circumflex accent {"\\u00E3", "&atilde;"}, // - lowercase a, tilde {"\\u00E4", "&auml;"}, // - lowercase a, umlaut {"\\u00E5", "&aring;"}, // - lowercase a, ring {"\\u00E6", "&aelig;"}, // - lowercase ae {"\\u00E7", "&ccedil;"}, // - lowercase c, cedilla'], ['{"\\u00CB", "&Ecirc;"}, // - uppercase E, circumflex accent {"\\u00CC", "&Euml;"}, // - uppercase E, umlaut {"\\u00CD", "&Igrave;"}, // - uppercase I, grave accent {"\\u00CE", "&Iacute;"}, // - uppercase I, acute accent {"\\u00CF", "&Icirc;"}, // - uppercase I, circumflex accent {"\\u00D0", "&Iuml;"}, // - uppercase I, umlaut {"\\u00D1", "&ETH;"}, // - uppercase Eth, Icelandic {"\\u00D2", "&Ntilde;"}, // - uppercase N, tilde {"\\u00D3", "&Ograve;"}, // - uppercase O, grave accent {"\\u00D4", "&Oacute;"}, // - uppercase O, acute accent {"\\u00D5", "&Ocirc;"}, // - uppercase O, circumflex accent {"\\u00D6", "&Otilde;"}, // - uppercase O, tilde {"\\u00D7", "&Ouml;"}, // - uppercase O, umlaut {"\\u00D8", "&times;"}, // multiplication sign {"\\u00D9", "&Oslash;"}, // - uppercase O, slash {"\\u00DA", "&Ugrave;"}, // - uppercase U, grave accent {"\\u00DB", "&Uacute;"}, // - uppercase U, acute accent {"\\u00DC", "&Ucirc;"}, // - uppercase U, circumflex accent {"\\u00DD", "&Uuml;"}, // - uppercase U, umlaut {"\\u00DE", "&Yacute;"}, // - uppercase Y, acute accent {"\\u00DF", "&THORN;"}, // - uppercase THORN, Icelandic {"\\u00E0", "&szlig;"}, // - lowercase sharps, German {"\\u00E1", "&agrave;"}, // - lowercase a, grave accent {"\\u00E2", "&aacute;"}, // - lowercase a, acute accent {"\\u00E3", "&acirc;"}, // - lowercase a, circumflex accent {"\\u00E4", "&atilde;"}, // - lowercase a, tilde {"\\u00E5", "&auml;"}, // - lowercase a, umlaut'], ['{"\\u00CA", "&Ecirc;"}, // - uppercase E, circumflex accent {"\\u00CB", "&Euml;"}, // - uppercase E, umlaut {"\\u00CC", "&Igrave;"}, // - uppercase I, grave accent {"\\u00CD", "&Iacute;"}, // - uppercase I, acute accent {"\\u00CE", "&Icirc;"}, // - uppercase I, circumflex accent {"\\u00CF", "&Iuml;"}, // - uppercase I, umlaut {"\\u00D0", "&ETH;"}, // - uppercase Eth, Icelandic {"\\u00D1", "&Ntilde;"}, // - uppercase N, tilde {"\\u00D2", "&Ograve;"}, // - uppercase O, grave accent {"\\u00D3", "&Oacute;"}, // - uppercase O, acute accent {"\\u00D4", "&Ocirc;"}, // - uppercase O, circumflex accent {"\\u00D5", "&Otilde;"}, // - uppercase O, tilde {"\\u00D6", "&Ouml;"}, // - uppercase O, umlaut {"\\u00D7", "&times;"}, // multiplication sign {"\\u00D8", "&Oslash;"}, // - uppercase O, slash {"\\u00D9", "&Ugrave;"}, // - uppercase U, grave accent {"\\u00DA", "&Uacute;"}, // - uppercase U, acute accent {"\\u00DB", "&Ucirc;"}, // - uppercase U, circumflex accent {"\\u00DC", "&Uuml;"}, // - uppercase U, umlaut {"\\u00DD", "&Yacute;"}, // - uppercase Y, acute accent {"\\u00DE", "&THORN;"}, // - uppercase THORN, Icelandic {"\\u00DF", "&szlig;"}, // - lowercase sharps, German {"\\u00E0", "&agrave;"}, // - lowercase a, grave accent {"\\u00E1", "&aacute;"}, // - lowercase a, acute accent {"\\u00E2", "&acirc;"}, // - lowercase a, circumflex accent {"\\u00E3", "&atilde;"}, // - lowercase a, tilde {"\\u00E4", "&auml;"}, // - lowercase a, umlaut'], 'a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java']
['Lang-26', 1, 1, 1, 1, ['* @return the formatted string */ public String format(Date date) { Calendar c = new GregorianCalendar(mTimeZone); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }'], ['* @return the formatted string */ public String format(Date date) { Calendar c = new GregorianCalendar(mTimeZone, mLocale); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }'], ['Calendar c = new GregorianCalendar(mTimeZone);'], ['Calendar c = new GregorianCalendar(mTimeZone, mLocale);'], 'a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java', 'b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java']
['Lang-27', 2, 2, 2, 2, ['if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos);', 'mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str;'], ['if (decPos > -1) { if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos);', 'mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str;'], ['if (expPos < decPos) {', ''], ['if (expPos < decPos || expPos > str.length()) {', 'if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); }'], 'a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-28', 1, 1, 1, 1, ['return 0; } out.write(entityValue); return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0;'], ['return 0; } if(entityValue > 0xFFFF) { char[] chrs = Character.toChars(entityValue); out.write(chrs[0]); out.write(chrs[1]); } else { out.write(entityValue); } return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0;'], [''], ['if(entityValue > 0xFFFF) { char[] chrs = Character.toChars(entityValue); out.write(chrs[0]); out.write(chrs[1]); } else { }'], 'a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java', 'b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java']
['Lang-29', 1, 1, 1, 1, ['* * @return the version, for example 131 for Java 1.3.1 */ static float toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }'], ['* * @return the version, for example 131 for Java 1.3.1 */ static int toJavaVersionInt(String version) { return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }'], ['static float toJavaVersionInt(String version) {'], ['static int toJavaVersionInt(String version) {'], 'a/src/main/java/org/apache/commons/lang3/SystemUtils.java', 'b/src/main/java/org/apache/commons/lang3/SystemUtils.java']
['Lang-30', 7, 7, 7, 7, ['return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { // ch is a supplementary character return i; } } }', '* <code>false</code> if no match or null input * @since 2.4 */ public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; }', 'char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // missing low surrogate, fine, like String.indexOf(String) if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else {', '* @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input * @since 2.4 */ public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; }', 'return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i;', 'int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND;', 'return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { // missing low surrogate, fine, like String.indexOf(String) // ch is in the Basic Multilingual Plane return false; } } }'], ['return INDEX_NOT_FOUND; } int csLen = cs.length(); int csLast = csLen - 1; int searchLen = searchChars.length; int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { // ch is a supplementary character if (searchChars[j + 1] == cs.charAt(i + 1)) { return i; } } else { return i; } } } }', '* <code>false</code> if no match or null input * @since 2.4 */ public static boolean containsAny(String cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; }', 'char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (Character.isHighSurrogate(ch)) { if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) return true; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else {', '* @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input * @since 2.4 */ public static boolean containsAny(String cs, String searchChars) { if (searchChars == null) { return false; }', 'return INDEX_NOT_FOUND; } int csLen = cs.length(); int csLast = csLen - 1; int searchLen = searchChars.length; int searchLast = searchLen - 1; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { if (searchChars[j + 1] == cs.charAt(i + 1)) { continue outer; } } else { continue outer; } } } return i;', 'int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); boolean chFound = searchChars.indexOf(ch) >= 0; if (i + 1 < strLen && Character.isHighSurrogate(ch)) { char ch2 = str.charAt(i + 1); if (chFound && searchChars.indexOf(ch2) < 0) { return i; } } else { if (!chFound) { return i; } } } return INDEX_NOT_FOUND;', 'return true; } int csLen = cs.length(); int csLast = csLen - 1; int searchLen = searchChars.length; int searchLast = searchLen - 1; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { if (Character.isHighSurrogate(ch)) { if (j == searchLast) { // missing low surrogate, fine, like String.indexOf(String) return false; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return false; } } else { // ch is in the Basic Multilingual Plane return false; } } } }'], ['', 'public static boolean containsAny(CharSequence cs, char[] searchChars) {', 'if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) {', 'public static boolean containsAny(CharSequence cs, String searchChars) {', '', 'if (searchChars.indexOf(ch) < 0) {', ''], ['int csLast = csLen - 1; int searchLast = searchLen - 1; if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return i; } } else { }', 'public static boolean containsAny(String cs, char[] searchChars) {', 'if (Character.isHighSurrogate(ch)) { if (j == searchLast) { return true; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {', 'public static boolean containsAny(String cs, String searchChars) {', 'int csLast = csLen - 1; int searchLast = searchLen - 1; if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { if (searchChars[j + 1] == cs.charAt(i + 1)) { continue outer; } } else { }', 'boolean chFound = searchChars.indexOf(ch) >= 0; if (i + 1 < strLen && Character.isHighSurrogate(ch)) { char ch2 = str.charAt(i + 1); if (chFound && searchChars.indexOf(ch2) < 0) { } } else { if (!chFound) { return i; }', 'int csLast = csLen - 1; int searchLast = searchLen - 1; if (Character.isHighSurrogate(ch)) { if (j == searchLast) { return false; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return false; } } else { }'], 'a/src/main/java/org/apache/commons/lang3/StringUtils.java', 'b/src/main/java/org/apache/commons/lang3/StringUtils.java']
['Lang-31', 1, 1, 1, 1, ['} int csLength = cs.length(); int searchLength = searchChars.length; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { // ch is a supplementary character // ch is in the Basic Multilingual Plane return true; } } }'], ['} int csLength = cs.length(); int searchLength = searchChars.length; int csLastIndex = csLength - 1; int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { // ch is in the Basic Multilingual Plane return true; } } } }'], [''], ['int csLastIndex = csLength - 1; int searchLastIndex = searchLength - 1; if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { }'], 'a/src/main/java/org/apache/commons/lang3/StringUtils.java', 'b/src/main/java/org/apache/commons/lang3/StringUtils.java']
['Lang-32', 4, 4, 4, 4, ['* * @since 2.3 */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() { @Override protected Set<IDKey> initialValue() { return new HashSet<IDKey>(); } }; /* * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()', '* @since 2.3 */ static boolean isRegistered(Object value) { return getRegistry().contains(new IDKey(value)); } /**', '* The object to register. */ static void register(Object value) { getRegistry().add(new IDKey(value)); }', '* @since 2.3 */ static void unregister(Object value) { getRegistry().remove(new IDKey(value)); } /**'], ['* * @since 2.3 */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>(); /* * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()', '* @since 2.3 */ static boolean isRegistered(Object value) { Set<IDKey> registry = getRegistry(); return registry != null && registry.contains(new IDKey(value)); } /**', '* The object to register. */ static void register(Object value) { synchronized (HashCodeBuilder.class) { if (getRegistry() == null) { REGISTRY.set(new HashSet<IDKey>()); } } getRegistry().add(new IDKey(value)); }', '* @since 2.3 */ static void unregister(Object value) { Set<IDKey> s = getRegistry(); if (s != null) { s.remove(new IDKey(value)); synchronized (HashCodeBuilder.class) { if (s.isEmpty()) { REGISTRY.remove(); } } } } /**'], ['private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() { @Override protected Set<IDKey> initialValue() { return new HashSet<IDKey>(); } };', 'return getRegistry().contains(new IDKey(value));', '', 'getRegistry().remove(new IDKey(value));'], ['private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();', 'Set<IDKey> registry = getRegistry(); return registry != null && registry.contains(new IDKey(value));', 'synchronized (HashCodeBuilder.class) { if (getRegistry() == null) { REGISTRY.set(new HashSet<IDKey>()); } }', 'Set<IDKey> s = getRegistry(); if (s != null) { s.remove(new IDKey(value)); synchronized (HashCodeBuilder.class) { if (s.isEmpty()) { REGISTRY.remove(); } } }'], 'a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java', 'b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java']
['Lang-33', 1, 1, 1, 1, ['} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }'], ['} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i] == null ? null : array[i].getClass(); } return classes; }'], ['classes[i] = array[i].getClass();'], ['classes[i] = array[i] == null ? null : array[i].getClass();'], 'a/src/main/java/org/apache/commons/lang3/ClassUtils.java', 'b/src/main/java/org/apache/commons/lang3/ClassUtils.java']
['Lang-34', 2, 2, 2, 2, ['* @return Set the registry of objects being traversed */ static Map<Object, Object> getRegistry() { return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap(); } /**', '*/ static boolean isRegistered(Object value) { Map<Object, Object> m = getRegistry(); return m.containsKey(value); } /**'], ['* @return Set the registry of objects being traversed */ static Map<Object, Object> getRegistry() { return REGISTRY.get(); } /**', '*/ static boolean isRegistered(Object value) { Map<Object, Object> m = getRegistry(); return m != null && m.containsKey(value); } /**'], ['return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();', 'return m.containsKey(value);'], ['return REGISTRY.get();', 'return m != null && m.containsKey(value);'], 'a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java', 'b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java']
['Lang-35', 2, 2, 2, 2, ['} else if (element != null) { type = element.getClass(); } else { type = Object.class; } @SuppressWarnings("unchecked") // type must be T T[] newArray = (T[]) copyArrayGrow1(array, type);', '} else if (element != null) { clss = element.getClass(); } else { return (T[]) new Object[] { null }; } @SuppressWarnings("unchecked") // the add method creates an array of type clss, which is type T final T[] newArray = (T[]) add(array, index, element, clss);'], ['} else if (element != null) { type = element.getClass(); } else { throw new IllegalArgumentException("Arguments cannot both be null"); } @SuppressWarnings("unchecked") // type must be T T[] newArray = (T[]) copyArrayGrow1(array, type);', '} else if (element != null) { clss = element.getClass(); } else { throw new IllegalArgumentException("Array and element cannot both be null"); } @SuppressWarnings("unchecked") // the add method creates an array of type clss, which is type T final T[] newArray = (T[]) add(array, index, element, clss);'], ['type = Object.class;', 'return (T[]) new Object[] { null };'], ['throw new IllegalArgumentException("Arguments cannot both be null");', 'throw new IllegalArgumentException("Array and element cannot both be null");'], 'a/src/main/java/org/apache/commons/lang3/ArrayUtils.java', 'b/src/main/java/org/apache/commons/lang3/ArrayUtils.java']
['Lang-36', 2, 2, 2, 2, ['} dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else {', "// can't have an E at the last byte return false; } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D'"], ["} dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else {", "// can't have an E at the last byte return false; } if (chars[i] == '.') { if (hasDecPoint || hasExp) { // two decimal points or dec in exponent return false; } // single trailing decimal point after non-exponent is ok return foundDigit; } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D'"], ['if (!Character.isDigit(lastChar)) {', ''], ["if (!Character.isDigit(lastChar) && lastChar != '.') {", "if (chars[i] == '.') { if (hasDecPoint || hasExp) { // two decimal points or dec in exponent return false; } // single trailing decimal point after non-exponent is ok return foundDigit; }"], 'a/src/java/org/apache/commons/lang3/math/NumberUtils.java', 'b/src/java/org/apache/commons/lang3/math/NumberUtils.java']
['Lang-37', 1, 1, 1, 1, ['final Class<?> type1 = array1.getClass().getComponentType(); T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); // Check if problem is incompatible types return joinedArray; }'], ['final Class<?> type1 = array1.getClass().getComponentType(); T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length); try { System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); } catch (ArrayStoreException ase) { // Check if problem is incompatible types final Class<?> type2 = array2.getClass().getComponentType(); if (!type1.isAssignableFrom(type2)){ throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "+type1.getName()); } throw ase; // No, so rethrow original } return joinedArray; }'], [''], ['try { } catch (ArrayStoreException ase) { final Class<?> type2 = array2.getClass().getComponentType(); if (!type1.isAssignableFrom(type2)){ throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "+type1.getName()); } throw ase; // No, so rethrow original }'], 'a/src/java/org/apache/commons/lang3/ArrayUtils.java', 'b/src/java/org/apache/commons/lang3/ArrayUtils.java']
['Lang-38', 1, 1, 1, 1, ['*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }'], ['*/ public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { calendar.getTime(); /// LANG-538 calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); }'], [''], ['calendar.getTime(); /// LANG-538'], 'a/src/java/org/apache/commons/lang3/time/FastDateFormat.java', 'b/src/java/org/apache/commons/lang3/time/FastDateFormat.java']
['Lang-39', 1, 1, 1, 1, [' // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches'], [' // count the replacement text elements that are larger than their corresponding text being replaced for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches'], [''], ['if (searchList[i] == null || replacementList[i] == null) { continue; }'], 'a/src/java/org/apache/commons/lang3/StringUtils.java', 'b/src/java/org/apache/commons/lang3/StringUtils.java']
['Lang-40', 1, 1, 1, 1, ['if (str == null || searchStr == null) { return false; } return contains(str.toUpperCase(), searchStr.toUpperCase()); } // IndexOfAny chars'], ['if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } // IndexOfAny chars'], ['return contains(str.toUpperCase(), searchStr.toUpperCase());'], ['int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false;'], 'a/src/java/org/apache/commons/lang/StringUtils.java', 'b/src/java/org/apache/commons/lang/StringUtils.java']
['Lang-41', 3, 3, 3, 3, ['return StringUtils.EMPTY; } // Handle array encoding // Strip Object type encoding int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf(', 'if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out; } // Package name', '* @return the package name or an empty string */ public static String getPackageName(String className) { if (className == null) { return StringUtils.EMPTY; } // Strip array encoding // Strip Object type encoding int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) {'], ['return StringUtils.EMPTY; } StringBuffer arrayPrefix = new StringBuffer(); // Handle array encoding if (className.startsWith("[")) { while (className.charAt(0) == \'[\') { className = className.substring(1); arrayPrefix.append("[]"); } // Strip Object type encoding if (className.charAt(0) == \'L\' && className.charAt(className.length() - 1) == \';\') { className = className.substring(1, className.length() - 1); } } if (reverseAbbreviationMap.containsKey(className)) { className = reverseAbbreviationMap.get(className); } int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf(', 'if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out + arrayPrefix; } // Package name', "* @return the package name or an empty string */ public static String getPackageName(String className) { if (className == null || className.length() == 0) { return StringUtils.EMPTY; } // Strip array encoding while (className.charAt(0) == '[') { className = className.substring(1); } // Strip Object type encoding if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { className = className.substring(1); } int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) {"], ['', 'return out;', 'if (className == null) {'], ['StringBuffer arrayPrefix = new StringBuffer(); if (className.startsWith("[")) { while (className.charAt(0) == \'[\') { className = className.substring(1); arrayPrefix.append("[]"); } if (className.charAt(0) == \'L\' && className.charAt(className.length() - 1) == \';\') { className = className.substring(1, className.length() - 1); } } if (reverseAbbreviationMap.containsKey(className)) { className = reverseAbbreviationMap.get(className); }', 'return out + arrayPrefix;', "if (className == null || className.length() == 0) { while (className.charAt(0) == '[') { className = className.substring(1); } if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { className = className.substring(1); }"], 'a/src/java/org/apache/commons/lang/ClassUtils.java', 'b/src/java/org/apache/commons/lang/ClassUtils.java']
['Lang-42', 1, 1, 1, 1, ['public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { char c = str.charAt(i); String entityName = this.entityName(c); if (entityName == null) { if (c > 0x7F) { writer.write("&#"); writer.write(Integer.toString(c, 10)); writer.write(\';\');'], ['public void escape(Writer writer, String str) throws IOException { int len = str.length(); for (int i = 0; i < len; i++) { int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { if (c >= 0x010000 && i < len - 1) { writer.write("&#"); writer.write(Integer.toString(c, 10)); writer.write(\';\'); i++; } else if (c > 0x7F) { writer.write("&#"); writer.write(Integer.toString(c, 10)); writer.write(\';\');'], ['char c = str.charAt(i); if (c > 0x7F) {'], ['int c = Character.codePointAt(str, i); if (c >= 0x010000 && i < len - 1) { writer.write("&#"); writer.write(Integer.toString(c, 10)); writer.write(\';\'); i++; } else if (c > 0x7F) {'], 'a/src/java/org/apache/commons/lang/Entities.java', 'b/src/java/org/apache/commons/lang/Entities.java']
['Lang-43', 1, 1, 1, 1, ['int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;'], ['int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { next(pos); return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start;'], [''], ['next(pos);'], 'a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java', 'b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java']
['Lang-44', 1, 1, 1, 1, ['if (val.length() == 0) { throw new NumberFormatException("\\"\\" is not a valid number."); } if (val.startsWith("--")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear'], ['if (val.length() == 0) { throw new NumberFormatException("\\"\\" is not a valid number."); } if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { throw new NumberFormatException(val + " is not a valid number."); } if (val.startsWith("--")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear'], [''], ['if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { throw new NumberFormatException(val + " is not a valid number."); }'], 'a/src/java/org/apache/commons/lang/NumberUtils.java', 'b/src/java/org/apache/commons/lang/NumberUtils.java']
['Lang-45', 1, 1, 1, 1, [' // if the lower value is greater than the length of the string, // set to the length of the string // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) {'], [' // if the lower value is greater than the length of the string, // set to the length of the string if (lower > str.length()) { lower = str.length(); } // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) {'], [''], ['if (lower > str.length()) { lower = str.length(); }'], 'a/src/java/org/apache/commons/lang/WordUtils.java', 'b/src/java/org/apache/commons/lang/WordUtils.java']
['Lang-46', 7, 7, 7, 7, ['* @return String with escaped values, <code>null</code> if null string input */ public static String escapeJava(String str) { return escapeJavaStyleString(str, false); } /**', '* @throws IOException if error occurs on underlying Writer */ public static void escapeJava(Writer out, String str) throws IOException { escapeJavaStyleString(out, str, false); } /**', '* @return String with escaped values, <code>null</code> if null string input */ public static String escapeJavaScript(String str) { return escapeJavaStyleString(str, true); } /**', '* @throws IOException if error occurs on underlying Writer **/ public static void escapeJavaScript(Writer out, String str) throws IOException { escapeJavaStyleString(out, str, true); } /**', '* @param escapeForwardSlash TODO * @return the escaped string */ private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) { if (str == null) { return null; } try { StringWriter writer = new StringWriter(str.length() * 2); escapeJavaStyleString(writer, str, escapeSingleQuotes); return writer.toString(); } catch (IOException ioe) { // this should never ever happen while writing to a StringWriter', '* @param escapeForwardSlash TODO * @throws IOException if an IOException occurs */ private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException { if (out == null) { throw new IllegalArgumentException("The Writer must not be null"); }', "out.write('\\\\'); break; case '/' : out.write('\\\\'); out.write('/'); break; default :"], ['* @return String with escaped values, <code>null</code> if null string input */ public static String escapeJava(String str) { return escapeJavaStyleString(str, false, false); } /**', '* @throws IOException if error occurs on underlying Writer */ public static void escapeJava(Writer out, String str) throws IOException { escapeJavaStyleString(out, str, false, false); } /**', '* @return String with escaped values, <code>null</code> if null string input */ public static String escapeJavaScript(String str) { return escapeJavaStyleString(str, true, true); } /**', '* @throws IOException if error occurs on underlying Writer **/ public static void escapeJavaScript(Writer out, String str) throws IOException { escapeJavaStyleString(out, str, true, true); } /**', '* @param escapeForwardSlash TODO * @return the escaped string */ private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) { if (str == null) { return null; } try { StringWriter writer = new StringWriter(str.length() * 2); escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash); return writer.toString(); } catch (IOException ioe) { // this should never ever happen while writing to a StringWriter', '* @param escapeForwardSlash TODO * @throws IOException if an IOException occurs */ private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, boolean escapeForwardSlash) throws IOException { if (out == null) { throw new IllegalArgumentException("The Writer must not be null"); }', "out.write('\\\\'); break; case '/' : if (escapeForwardSlash) { out.write('\\\\'); } out.write('/'); break; default :"], ['return escapeJavaStyleString(str, false);', 'escapeJavaStyleString(out, str, false);', 'return escapeJavaStyleString(str, true);', 'escapeJavaStyleString(out, str, true);', 'private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) { escapeJavaStyleString(writer, str, escapeSingleQuotes);', 'private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {', ''], ['return escapeJavaStyleString(str, false, false);', 'escapeJavaStyleString(out, str, false, false);', 'return escapeJavaStyleString(str, true, true);', 'escapeJavaStyleString(out, str, true, true);', 'private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) { escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);', 'private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote, boolean escapeForwardSlash) throws IOException {', 'if (escapeForwardSlash) { }'], 'a/src/java/org/apache/commons/lang/StringEscapeUtils.java', 'b/src/java/org/apache/commons/lang/StringEscapeUtils.java']
['Lang-47', 2, 2, 2, 2, ['if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size);', 'if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size);'], ['if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); if (str == null) { str = ""; } int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size);', 'if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); if (str == null) { str = ""; } int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size);'], ['', ''], ['if (str == null) { str = ""; }', 'if (str == null) { str = ""; }'], 'a/src/java/org/apache/commons/lang/text/StrBuilder.java', 'b/src/java/org/apache/commons/lang/text/StrBuilder.java']
['Lang-48', 1, 1, 1, 1, ['} Class lhsClass = lhs.getClass(); if (!lhsClass.isArray()) { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); } else if (lhs.getClass() != rhs.getClass()) { // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] this.setEquals(false);'], ['} Class lhsClass = lhs.getClass(); if (!lhsClass.isArray()) { if (lhs instanceof java.math.BigDecimal) { isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); } else { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); } } else if (lhs.getClass() != rhs.getClass()) { // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] this.setEquals(false);'], [''], ['if (lhs instanceof java.math.BigDecimal) { isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); } else { }'], 'a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java', 'b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java']
['Lang-49', 1, 1, 1, 1, ['* @return a new reduced fraction instance, or this if no simplification possible */ public Fraction reduce() { int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); if (gcd == 1) { return this;'], ['* @return a new reduced fraction instance, or this if no simplification possible */ public Fraction reduce() { if (numerator == 0) { return equals(ZERO) ? this : ZERO; } int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); if (gcd == 1) { return this;'], [''], ['if (numerator == 0) { return equals(ZERO) ? this : ZERO; }'], 'a/src/java/org/apache/commons/lang/math/Fraction.java', 'b/src/java/org/apache/commons/lang/math/Fraction.java']
['Lang-50', 2, 2, 2, 2, ['key = new Pair(key, timeZone); } if (locale != null) { key = new Pair(key, locale); } FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key); if (format == null) { if (locale == null) { locale = Locale.getDefault(); } try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale); String pattern = formatter.toPattern();', 'if (timeZone != null) { key = new Pair(key, timeZone); } if (locale != null) { key = new Pair(key, locale); } FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key); if (format == null) { if (locale == null) { locale = Locale.getDefault(); } try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);'], ['key = new Pair(key, timeZone); } if (locale == null) { locale = Locale.getDefault(); } key = new Pair(key, locale); FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key); if (format == null) { try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale); String pattern = formatter.toPattern();', 'if (timeZone != null) { key = new Pair(key, timeZone); } if (locale == null) { locale = Locale.getDefault(); } key = new Pair(key, locale); FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key); if (format == null) { try { SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);'], ['if (locale != null) { key = new Pair(key, locale); if (locale == null) { locale = Locale.getDefault(); }', 'if (locale != null) { key = new Pair(key, locale); if (locale == null) { locale = Locale.getDefault(); }'], ['if (locale == null) { locale = Locale.getDefault(); key = new Pair(key, locale);', 'if (locale == null) { locale = Locale.getDefault(); key = new Pair(key, locale);'], 'a/src/java/org/apache/commons/lang/time/FastDateFormat.java', 'b/src/java/org/apache/commons/lang/time/FastDateFormat.java']
['Lang-51', 1, 1, 1, 1, ["(str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0);"], ["(str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } return false; } case 4: { char ch = str.charAt(0);"], [''], ['return false;'], 'a/src/java/org/apache/commons/lang/BooleanUtils.java', 'b/src/java/org/apache/commons/lang/BooleanUtils.java']
['Lang-52', 1, 1, 1, 1, ["out.write('\\\\'); out.write('\\\\'); break; default : out.write(ch); break;"], ["out.write('\\\\'); out.write('\\\\'); break; case '/': out.write('\\\\'); out.write('/'); break; default : out.write(ch); break;"], [''], ["case '/': out.write('\\\\'); out.write('/'); break;"], 'a/src/java/org/apache/commons/lang/StringEscapeUtils.java', 'b/src/java/org/apache/commons/lang/StringEscapeUtils.java']
['Lang-53', 1, 1, 1, 1, ['int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; if (field == Calendar.SECOND) { done = true; } } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; } } // truncate minutes'], ['int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; } if (field == Calendar.SECOND) { done = true; } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); } if (field == Calendar.MINUTE) { done = true; } // truncate minutes'], ['} }'], ['} }'], 'a/src/java/org/apache/commons/lang/time/DateUtils.java', 'b/src/java/org/apache/commons/lang/time/DateUtils.java']
['Lang-54', 1, 1, 1, 1, ['throw new IllegalArgumentException("Invalid locale format: " + str); } char ch3 = str.charAt(3); char ch4 = str.charAt(4); if (ch3 < \'A\' || ch3 > \'Z\' || ch4 < \'A\' || ch4 > \'Z\') { throw new IllegalArgumentException("Invalid locale format: " + str);'], ['throw new IllegalArgumentException("Invalid locale format: " + str); } char ch3 = str.charAt(3); if (ch3 == \'_\') { return new Locale(str.substring(0, 2), "", str.substring(4)); } char ch4 = str.charAt(4); if (ch3 < \'A\' || ch3 > \'Z\' || ch4 < \'A\' || ch4 > \'Z\') { throw new IllegalArgumentException("Invalid locale format: " + str);'], [''], ['if (ch3 == \'_\') { return new Locale(str.substring(0, 2), "", str.substring(4)); }'], 'a/src/java/org/apache/commons/lang/LocaleUtils.java', 'b/src/java/org/apache/commons/lang/LocaleUtils.java']
['Lang-55', 1, 1, 1, 1, ['if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException("Stopwatch is not running. "); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }'], ['if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException("Stopwatch is not running. "); } if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }'], [''], ['if(this.runningState == STATE_RUNNING) { }'], 'a/src/java/org/apache/commons/lang/time/StopWatch.java', 'b/src/java/org/apache/commons/lang/time/StopWatch.java']
['Lang-56', 2, 2, 2, 2, ['/** * The parsed rules. */ private Rule[] mRules; /** * The estimated maximum length. */ private int mMaxLengthEstimate; //----------------------------------------------------------------------- /**', ' // Serializing //----------------------------------------------------------------------- // Rules //-----------------------------------------------------------------------'], ['/** * The parsed rules. */ private transient Rule[] mRules; /** * The estimated maximum length. */ private transient int mMaxLengthEstimate; //----------------------------------------------------------------------- /**', ' // Serializing //----------------------------------------------------------------------- private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); init(); } // Rules //-----------------------------------------------------------------------'], ['private Rule[] mRules; private int mMaxLengthEstimate;', ''], ['private transient Rule[] mRules; private transient int mMaxLengthEstimate;', 'private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); init(); }'], 'a/src/java/org/apache/commons/lang/time/FastDateFormat.java', 'b/src/java/org/apache/commons/lang/time/FastDateFormat.java']
['Lang-57', 1, 1, 1, 1, ['* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); } //-----------------------------------------------------------------------'], ['* @return true if the locale is a known locale */ public static boolean isAvailableLocale(Locale locale) { return availableLocaleList().contains(locale); } //-----------------------------------------------------------------------'], ['return cAvailableLocaleSet.contains(locale);'], ['return availableLocaleList().contains(locale);'], 'a/src/java/org/apache/commons/lang/LocaleUtils.java', 'b/src/java/org/apache/commons/lang/LocaleUtils.java']
['Lang-58', 1, 1, 1, 1, ["case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {"], ["case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) {"], ["&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {"], ["&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {"], 'a/src/java/org/apache/commons/lang/math/NumberUtils.java', 'b/src/java/org/apache/commons/lang/math/NumberUtils.java']
['Lang-59', 1, 1, 1, 1, ['String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);'], ['String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size);'], ['str.getChars(0, strLen, buffer, size);'], ['str.getChars(0, width, buffer, size);'], 'a/src/java/org/apache/commons/lang/text/StrBuilder.java', 'b/src/java/org/apache/commons/lang/text/StrBuilder.java']
['Lang-60', 2, 2, 2, 2, ['*/ public boolean contains(char ch) { char[] thisBuf = buffer; for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; }', 'return -1; } char[] thisBuf = buffer; for (int i = startIndex; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return i; }'], ['*/ public boolean contains(char ch) { char[] thisBuf = buffer; for (int i = 0; i < this.size; i++) { if (thisBuf[i] == ch) { return true; }', 'return -1; } char[] thisBuf = buffer; for (int i = startIndex; i < size; i++) { if (thisBuf[i] == ch) { return i; }'], ['for (int i = 0; i < thisBuf.length; i++) {', 'for (int i = startIndex; i < thisBuf.length; i++) {'], ['for (int i = 0; i < this.size; i++) {', 'for (int i = startIndex; i < size; i++) {'], 'a/src/java/org/apache/commons/lang/text/StrBuilder.java', 'b/src/java/org/apache/commons/lang/text/StrBuilder.java']
['Lang-61', 1, 1, 1, 1, ['return -1; } char[] thisBuf = buffer; int len = thisBuf.length - strLen; outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) {'], ['return -1; } char[] thisBuf = buffer; int len = size - strLen + 1; outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) {'], ['int len = thisBuf.length - strLen;'], ['int len = size - strLen + 1;'], 'a/src/java/org/apache/commons/lang/text/StrBuilder.java', 'b/src/java/org/apache/commons/lang/text/StrBuilder.java']
['Lang-62', 2, 2, 2, 2, ['} else { entityValue = Integer.parseInt(entityName.substring(1)); } } catch (NumberFormatException ex) { entityValue = -1; }', "case 'X' : case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16); } default : { entityValue = Integer.parseInt(entityContent.substring(1), 10); } } } catch (NumberFormatException e) { } } } else { //escaped value content is an entity name"], ['} else { entityValue = Integer.parseInt(entityName.substring(1)); } if (entityValue > 0xFFFF) { entityValue = -1; } } catch (NumberFormatException ex) { entityValue = -1; }', "case 'X' : case 'x' : { entityValue = Integer.parseInt(entityContent.substring(2), 16); break; } default : { entityValue = Integer.parseInt(entityContent.substring(1), 10); } } if (entityValue > 0xFFFF) { entityValue = -1; } } catch (NumberFormatException e) { entityValue = -1; } } } else { //escaped value content is an entity name"], ['', ''], ['if (entityValue > 0xFFFF) { entityValue = -1; }', 'break; if (entityValue > 0xFFFF) { entityValue = -1; } entityValue = -1;'], 'a/src/java/org/apache/commons/lang/Entities.java', 'b/src/java/org/apache/commons/lang/Entities.java']
['Lang-63', 2, 2, 2, 2, ["days -= 1; } while (days < 0) { days += 31; //days += 31; // TODO: Need tests to show this is bad and the new code is good. // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days. // Also it's contextual - if asked for no M in the format then I should probably // be doing no calculating here. months -= 1; } while (months < 0) { months += 12; years -= 1; } milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years); // This next block of code adds in values that // aren't requested. This allows the user to ask for the", '} return buffer.toString(); } static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } } static final Object y = "y"; static final Object M = "M";'], ["days -= 1; } while (days < 0) { end.add(Calendar.MONTH, -1); days += end.getActualMaximum(Calendar.DAY_OF_MONTH); //days += 31; // TODO: Need tests to show this is bad and the new code is good. // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days. // Also it's contextual - if asked for no M in the format then I should probably // be doing no calculating here. months -= 1; end.add(Calendar.MONTH, 1); } while (months < 0) { months += 12; years -= 1; } // This next block of code adds in values that // aren't requested. This allows the user to ask for the", '} return buffer.toString(); } static final Object y = "y"; static final Object M = "M";'], ['days += 31; milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years);', 'static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } }'], ['end.add(Calendar.MONTH, -1); days += end.getActualMaximum(Calendar.DAY_OF_MONTH); end.add(Calendar.MONTH, 1);', ''], 'a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java', 'b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java']
['Lang-64', 2, 2, 2, 2, ['* @throws NullPointerException if other is <code>null</code> */ public int compareTo(Object other) { return iValue - ((ValuedEnum) other).iValue; }', '* @param other the object to determine the value for * @return the value */ // ignore - should never happen // ignore - should never happen // ignore - should never happen /** * <p>Human readable description of this <code>Enum</code> item.</p>'], ['* @throws NullPointerException if other is <code>null</code> */ public int compareTo(Object other) { if (other == this) { return 0; } if (other.getClass() != this.getClass()) { if (other.getClass().getName().equals(this.getClass().getName())) { return iValue - getValueInOtherClassLoader(other); } throw new ClassCastException( "Different enum class \'" + ClassUtils.getShortClassName(other.getClass()) + "\'"); } return iValue - ((ValuedEnum) other).iValue; }', '* @param other the object to determine the value for * @return the value */ private int getValueInOtherClassLoader(Object other) { try { Method mth = other.getClass().getMethod("getValue", null); Integer value = (Integer) mth.invoke(other, null); return value.intValue(); } catch (NoSuchMethodException e) { // ignore - should never happen } catch (IllegalAccessException e) { // ignore - should never happen } catch (InvocationTargetException e) { // ignore - should never happen } throw new IllegalStateException("This should not happen"); } /** * <p>Human readable description of this <code>Enum</code> item.</p>'], ['', ''], ['if (other == this) { return 0; } if (other.getClass() != this.getClass()) { if (other.getClass().getName().equals(this.getClass().getName())) { return iValue - getValueInOtherClassLoader(other); } throw new ClassCastException( "Different enum class \'" + ClassUtils.getShortClassName(other.getClass()) + "\'"); }', 'private int getValueInOtherClassLoader(Object other) { try { Method mth = other.getClass().getMethod("getValue", null); Integer value = (Integer) mth.invoke(other, null); return value.intValue(); } catch (NoSuchMethodException e) { } catch (IllegalAccessException e) { } catch (InvocationTargetException e) { } throw new IllegalStateException("This should not happen"); }'], 'a/src/java/org/apache/commons/lang/enums/ValuedEnum.java', 'b/src/java/org/apache/commons/lang/enums/ValuedEnum.java']
['Lang-65', 3, 3, 3, 3, ['throw new ArithmeticException("Calendar value too large for accurate calculations"); } // ----------------- Fix for LANG-59 ---------------------- START --------------- // see http://issues.apache.org/jira/browse/LANG-59', '// Manually truncate milliseconds, seconds and minutes, rather than using // Calendar methods. // truncate milliseconds // truncate seconds // truncate minutes // reset time // ----------------- Fix for LANG-59 ----------------------- END ---------------- boolean roundUp = false;', 'roundUp = offset > ((max - min) / 2); } //We need to remove this field val.set(fields[i][0], val.get(fields[i][0]) - offset); } throw new IllegalArgumentException("The field " + field + " is not supported");'], ['throw new ArithmeticException("Calendar value too large for accurate calculations"); } if (field == Calendar.MILLISECOND) { return; } // ----------------- Fix for LANG-59 ---------------------- START --------------- // see http://issues.apache.org/jira/browse/LANG-59', '// Manually truncate milliseconds, seconds and minutes, rather than using // Calendar methods. Date date = val.getTime(); long time = date.getTime(); boolean done = false; // truncate milliseconds int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; if (field == Calendar.SECOND) { done = true; } } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; } } // truncate minutes int minutes = val.get(Calendar.MINUTE); if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L); } // reset time if (date.getTime() != time) { date.setTime(time); val.setTime(date); } // ----------------- Fix for LANG-59 ----------------------- END ---------------- boolean roundUp = false;', 'roundUp = offset > ((max - min) / 2); } //We need to remove this field if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); } } throw new IllegalArgumentException("The field " + field + " is not supported");'], ['', '', ''], ['if (field == Calendar.MILLISECOND) { return; }', 'Date date = val.getTime(); long time = date.getTime(); boolean done = false; int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; if (field == Calendar.SECOND) { done = true; } } int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; } } int minutes = val.get(Calendar.MINUTE); if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L); } if (date.getTime() != time) { date.setTime(time); val.setTime(date); }', 'if (offset != 0) { }'], 'a/src/java/org/apache/commons/lang/time/DateUtils.java', 'b/src/java/org/apache/commons/lang/time/DateUtils.java']
['Compress-1', 1, 1, 1, 1, ['*/ public void close() throws IOException { if (!this.closed) { super.close(); this.closed = true; }'], ['*/ public void close() throws IOException { if (!this.closed) { this.finish(); super.close(); this.closed = true; }'], [''], ['this.finish();'], 'a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java']
['Compress-2', 6, 6, 6, 6, ['* If getNextEnxtry has been called, the entry metadata is stored in * currentEntry. */ /* * The offset where the current entry started. -1 if no entry has been * called */ public ArArchiveInputStream( final InputStream pInput ) { input = pInput;', '* if the entry could not be read */ public ArArchiveEntry getNextArEntry() throws IOException { // hit EOF before previous entry was complete // TODO: throw an exception instead? if (offset == 0) { final byte[] expected = ArArchiveEntry.HEADER.getBytes();', '} } // hit eof if (input.available() == 0) { return null; } if (offset % 2 != 0) { read(); } final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12]; final byte[] userid = new byte[6];', '} } return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length) .trim())); }', 'closed = true; input.close(); } } public int read() throws IOException { final int ret = input.read(); offset += (ret > 0 ? 1 : 0); return ret; } public int read(byte[] b) throws IOException {', ' public int read(byte[] b, final int off, final int len) throws IOException { int toRead = len; final int ret = this.input.read(b, off, toRead); offset += (ret > 0 ? ret : 0); return ret;'], ['* If getNextEnxtry has been called, the entry metadata is stored in * currentEntry. */ private ArArchiveEntry currentEntry = null; /* * The offset where the current entry started. -1 if no entry has been * called */ private long entryOffset = -1; public ArArchiveInputStream( final InputStream pInput ) { input = pInput;', '* if the entry could not be read */ public ArArchiveEntry getNextArEntry() throws IOException { if (currentEntry != null) { final long entryEnd = entryOffset + currentEntry.getLength(); while (offset < entryEnd) { int x = read(); if (x == -1) { // hit EOF before previous entry was complete // TODO: throw an exception instead? return null; } } currentEntry = null; } if (offset == 0) { final byte[] expected = ArArchiveEntry.HEADER.getBytes();', '} } if (offset % 2 != 0) { if (read() < 0) { // hit eof return null; } } if (input.available() == 0) { return null; } final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12]; final byte[] userid = new byte[6];', '} } entryOffset = offset; currentEntry = new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length) .trim())); return currentEntry; }', 'closed = true; input.close(); } currentEntry = null; } public int read() throws IOException { byte[] single = new byte[1]; int num = read(single, 0, 1); return num == -1 ? -1 : single[0] & 0xff; } public int read(byte[] b) throws IOException {', ' public int read(byte[] b, final int off, final int len) throws IOException { int toRead = len; if (currentEntry != null) { final long entryEnd = entryOffset + currentEntry.getLength(); if (len > 0 && entryEnd > offset) { toRead = (int) Math.min(len, entryEnd - offset); } else { return -1; } } final int ret = this.input.read(b, off, toRead); offset += (ret > 0 ? ret : 0); return ret;'], ['', '', 'if (offset % 2 != 0) { read(); }', 'return new ArArchiveEntry(new String(name).trim(),', 'final int ret = input.read(); offset += (ret > 0 ? 1 : 0); return ret;', ''], ['private ArArchiveEntry currentEntry = null; private long entryOffset = -1;', 'if (currentEntry != null) { final long entryEnd = entryOffset + currentEntry.getLength(); while (offset < entryEnd) { int x = read(); if (x == -1) { return null; } } currentEntry = null; }', 'if (offset % 2 != 0) { if (read() < 0) { return null; } }', 'entryOffset = offset; currentEntry = new ArArchiveEntry(new String(name).trim(), return currentEntry;', 'currentEntry = null; byte[] single = new byte[1]; int num = read(single, 0, 1); return num == -1 ? -1 : single[0] & 0xff;', 'if (currentEntry != null) { final long entryEnd = entryOffset + currentEntry.getLength(); if (len > 0 && entryEnd > offset) { toRead = (int) Math.min(len, entryEnd - offset); } else { return -1; } }'], 'a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java']
['Compress-3', 4, 4, 4, 4, ['private boolean closed = false; /* Indicates if putArchiveEntry has been called without closeArchiveEntry */ private final OutputStream out;', '* @throws IOException on error */ public void finish() throws IOException { writeEOFRecord(); writeEOFRecord(); }', 'currSize = entry.getSize(); } currName = entry.getName(); } /**', '+ "\' before the \'" + currSize + "\' bytes specified in the header were written"); } } /**'], ['private boolean closed = false; /* Indicates if putArchiveEntry has been called without closeArchiveEntry */ private boolean haveUnclosedEntry = false; private final OutputStream out;', '* @throws IOException on error */ public void finish() throws IOException { if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); }', 'currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; } /**', '+ "\' before the \'" + currSize + "\' bytes specified in the header were written"); } haveUnclosedEntry = false; } /**'], ['', '', '', ''], ['private boolean haveUnclosedEntry = false;', 'if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); }', 'haveUnclosedEntry = true;', 'haveUnclosedEntry = false;'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java']
['Compress-4', 4, 4, 4, 4, ['*/ public void close() throws IOException { if (!this.closed) { this.finish(); out.close(); this.closed = true; }', '*/ public void close() throws IOException { if (!closed) { finish(); buffer.close(); out.close(); closed = true;', '* @exception IOException if an I/O error occurs. */ public void close() throws IOException { finish(); if (raf != null) { raf.close(); }', 'results.addedFromChangeSet(change.getEntry().getName()); } } return results; }'], ['*/ public void close() throws IOException { if (!this.closed) { out.close(); this.closed = true; }', '*/ public void close() throws IOException { if (!closed) { buffer.close(); out.close(); closed = true;', '* @exception IOException if an I/O error occurs. */ public void close() throws IOException { if (raf != null) { raf.close(); }', 'results.addedFromChangeSet(change.getEntry().getName()); } } out.finish(); return results; }'], ['this.finish();', 'finish();', 'finish();', ''], ['', '', '', 'out.finish();'], 'a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java', 'b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java']
['Compress-5', 1, 1, 1, 1, ['} catch (DataFormatException e) { throw new ZipException(e.getMessage()); } if (read == 0 && inf.finished()) { return -1; } crc.update(buffer, start, read); return read;'], ['} catch (DataFormatException e) { throw new ZipException(e.getMessage()); } if (read == 0) { if (inf.finished()) { return -1; } else if (lengthOfLastRead == -1) { throw new IOException("Truncated ZIP file"); } } crc.update(buffer, start, read); return read;'], ['if (read == 0 && inf.finished()) { return -1;'], ['if (read == 0) { if (inf.finished()) { return -1; } else if (lengthOfLastRead == -1) { throw new IOException("Truncated ZIP file"); }'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Compress-6', 2, 2, 2, 2, ['*/ public ZipArchiveEntry(String name) { super(name); } /**', 'return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; if (name == null) { if (other.name != null) { return false; } } else if (!name.equals(other.name)) { return false; } return true;'], ['*/ public ZipArchiveEntry(String name) { super(name); setName(name); } /**', 'return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } return true;'], ['', 'if (name == null) { if (other.name != null) { } else if (!name.equals(other.name)) {'], ['setName(name);', 'String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { } else if (!myName.equals(otherName)) {'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java']
['Compress-7', 1, 1, 1, 1, ['int end = offset + length; for (int i = offset; i < end; ++i) { if (buffer[i] == 0) { break; } result.append((char) buffer[i]); } return result.toString();'], ['int end = offset + length; for (int i = offset; i < end; ++i) { byte b = buffer[i]; if (b == 0) { // Trailing null break; } result.append((char) (b & 0xFF)); // Allow for sign-extension } return result.toString();'], ['if (buffer[i] == 0) { result.append((char) buffer[i]);'], ['byte b = buffer[i]; if (b == 0) { // Trailing null result.append((char) (b & 0xFF)); // Allow for sign-extension'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-8', 1, 1, 1, 1, ["*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; boolean stillPadding = true; int end = offset + length; int start = offset; for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; } // Skip leading spaces if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { break; } } // Must have trailing NUL or space // May have additional NUL or space stillPadding = false; // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException("], ['*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); } boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { return 0L; } // Skip leading spaces while (start < end){ if (buffer[start] == \' \'){ start++; } else { break; } } // Must have trailing NUL or space byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer == \' \'){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } // May have additional NUL or space trailer = buffer[end-1]; if (trailer == 0 || trailer == \' \'){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; // CheckStyle:MagicNumber OFF if (currentByte < \'0\' || currentByte > \'7\'){ throw new IllegalArgumentException('], ["boolean stillPadding = true; final byte currentByte = buffer[i]; if (currentByte == 0) { if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { } stillPadding = false;"], ['if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); } boolean allNUL = true; if (buffer[i] != 0){ allNUL = false; } if (allNUL) { return 0L; } while (start < end){ if (buffer[start] == \' \'){ start++; } else { } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer == \' \'){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer == \' \'){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start];'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-9', 2, 2, 2, 2, ['} /** * Ends the TAR archive without closing the underlying OutputStream.', 'numToWrite -= num; wOffset += num; } count(numToWrite); } /**'], ['} @Deprecated @Override public int getCount() { return (int) getBytesWritten(); } @Override public long getBytesWritten() { return ((CountingOutputStream) out).getBytesWritten(); } /** * Ends the TAR archive without closing the underlying OutputStream.', 'numToWrite -= num; wOffset += num; } } /**'], ['', 'count(numToWrite);'], ['@Deprecated @Override public int getCount() { return (int) getBytesWritten(); } @Override public long getBytesWritten() { return ((CountingOutputStream) out).getBytesWritten(); }', ''], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java']
['Compress-10', 2, 2, 2, 2, ['// the hashcode - see COMPRESS-164 // Map needs to be reconstructed in order to keep central // directory order for (ZipArchiveEntry ze : entries.keySet()) { OffsetEntry offsetEntry = entries.get(ze); long offset = offsetEntry.headerOffset; archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); byte[] b = new byte[SHORT];', 'nameMap.put(ze.getName(), ze); } } } }'], ['// the hashcode - see COMPRESS-164 // Map needs to be reconstructed in order to keep central // directory order Map<ZipArchiveEntry, OffsetEntry> origMap = new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries); entries.clear(); for (ZipArchiveEntry ze : origMap.keySet()) { OffsetEntry offsetEntry = origMap.get(ze); long offset = offsetEntry.headerOffset; archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); byte[] b = new byte[SHORT];', 'nameMap.put(ze.getName(), ze); } } entries.put(ze, offsetEntry); } }'], ['for (ZipArchiveEntry ze : entries.keySet()) { OffsetEntry offsetEntry = entries.get(ze);', ''], ['Map<ZipArchiveEntry, OffsetEntry> origMap = new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries); entries.clear(); for (ZipArchiveEntry ze : origMap.keySet()) { OffsetEntry offsetEntry = origMap.get(ze);', 'entries.put(ze, offsetEntry);'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java']
['Compress-11', 2, 2, 2, 2, ['return new TarArchiveInputStream(in); } // COMPRESS-117 - improve auto-recognition try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); tais.getNextEntry();', '// autodetection, simply not a TAR // ignored } } catch (IOException e) { throw new ArchiveException("Could not use reset and mark operations.", e); }'], ['return new TarArchiveInputStream(in); } // COMPRESS-117 - improve auto-recognition if (signatureLength >= 512) { try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); tais.getNextEntry();', '// autodetection, simply not a TAR // ignored } } } catch (IOException e) { throw new ArchiveException("Could not use reset and mark operations.", e); }'], ['', ''], ['if (signatureLength >= 512) {', '}'], 'a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java', 'b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java']
['Compress-12', 1, 1, 1, 1, ['return null; } currEntry = new TarArchiveEntry(headerBuf); entryOffset = 0; entrySize = currEntry.getSize();'], ['return null; } try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; entrySize = currEntry.getSize();'], ['currEntry = new TarArchiveEntry(headerBuf);'], ['try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java']
['Compress-13', 1, 1, 1, 1, ['* @param name the name to use */ protected void setName(String name) { this.name = name; }'], ['* @param name the name to use */ protected void setName(String name) { if (name != null && getPlatform() == PLATFORM_FAT && name.indexOf("/") == -1) { name = name.replace(\'\\\\\', \'/\'); } this.name = name; }'], [''], ['if (name != null && getPlatform() == PLATFORM_FAT && name.indexOf("/") == -1) { name = name.replace(\'\\\\\', \'/\'); }'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java']
['Compress-14', 1, 1, 1, 1, ['throw new IllegalArgumentException("Length "+length+" must be at least 2"); } boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { return 0L; }'], ['throw new IllegalArgumentException("Length "+length+" must be at least 2"); } if (buffer[start] == 0) { return 0L; }'], ['boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) {'], ['if (buffer[start] == 0) {'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-15', 1, 1, 1, 1, ['String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false; } return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes()'], ['String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { myComment = ""; } if (otherComment == null) { otherComment = ""; } return getTime() == other.getTime() && myComment.equals(otherComment) && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes()'], ['if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false;'], ['myComment = ""; } if (otherComment == null) { otherComment = ""; && myComment.equals(otherComment)'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java']
['Compress-16', 1, 1, 1, 1, ['try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); // COMPRESS-191 - verify the header checksum tais.getNextEntry(); return new TarArchiveInputStream(in); } catch (Exception e) { // NOPMD // can generate IllegalArgumentException as well // as IOException'], ['try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); // COMPRESS-191 - verify the header checksum if (tais.getNextTarEntry().isCheckSumOK()) { return new TarArchiveInputStream(in); } } catch (Exception e) { // NOPMD // can generate IllegalArgumentException as well // as IOException'], ['tais.getNextEntry();'], ['if (tais.getNextTarEntry().isCheckSumOK()) { }'], 'a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java', 'b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java']
['Compress-17', 1, 1, 1, 1, ["} // May have additional NULs or spaces trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ end--; } for ( ;start < end; start++) {"], ["} // May have additional NULs or spaces trailer = buffer[end - 1]; while (start < end - 1 && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) {"], ["if (trailer == 0 || trailer == ' '){"], ["while (start < end - 1 && (trailer == 0 || trailer == ' ')) { trailer = buffer[end - 1];"], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-18', 1, 1, 1, 1, ['void writePaxHeaders(String entryName, Map<String, String> headers) throws IOException { String name = "./PaxHeaders.X/" + stripTo7Bits(entryName); // TarEntry\'s constructor would think this is a directory // and not allow any data to be written if (name.length() >= TarConstants.NAMELEN) { name = name.substring(0, TarConstants.NAMELEN - 1); }'], ['void writePaxHeaders(String entryName, Map<String, String> headers) throws IOException { String name = "./PaxHeaders.X/" + stripTo7Bits(entryName); while (name.endsWith("/")) { // TarEntry\'s constructor would think this is a directory // and not allow any data to be written name = name.substring(0, name.length() - 1); } if (name.length() >= TarConstants.NAMELEN) { name = name.substring(0, TarConstants.NAMELEN - 1); }'], [''], ['while (name.endsWith("/")) { name = name.substring(0, name.length() - 1); }'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java']
['Compress-19', 1, 1, 1, 1, ['+ (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0); if (rawCentralDirectoryData.length != expectedLength) { throw new ZipException("central directory zip64 extended" + " information extra field\'s length" + " doesn\'t match central directory"'], ['+ (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0); if (rawCentralDirectoryData.length < expectedLength) { throw new ZipException("central directory zip64 extended" + " information extra field\'s length" + " doesn\'t match central directory"'], ['if (rawCentralDirectoryData.length != expectedLength) {'], ['if (rawCentralDirectoryData.length < expectedLength) {'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java']
['Compress-20', 6, 6, 6, 6, [' ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16); if (mode != 0){ ret.setMode(mode); } ret.setUID(readAsciiLong(8, 16));', 'ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry name: "+name + " Occured at byte: " + getBytesRead()); } skip(ret.getHeaderPadCount());', 'ret.setDevice(readAsciiLong(6, 8)); ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (mode != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8));', 'ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry: "+ name + " Occured at byte: " + getBytesRead()); }', 'ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (mode != 0){ ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord));', 'ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name); if (mode == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry: "+name + "Occured at byte: " + getBytesRead()); } skip(ret.getHeaderPadCount());'], [' ret.setInode(readAsciiLong(8, 16)); long mode = readAsciiLong(8, 16); if (CpioUtil.fileType(mode) != 0){ // mode is initialised to 0 ret.setMode(mode); } ret.setUID(readAsciiLong(8, 16));', 'ret.setChksum(readAsciiLong(8, 16)); String name = readCString((int) namesize); ret.setName(name); if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry name: "+name + " Occured at byte: " + getBytesRead()); } skip(ret.getHeaderPadCount());', 'ret.setDevice(readAsciiLong(6, 8)); ret.setInode(readAsciiLong(6, 8)); final long mode = readAsciiLong(6, 8); if (CpioUtil.fileType(mode) != 0) { ret.setMode(mode); } ret.setUID(readAsciiLong(6, 8));', 'ret.setSize(readAsciiLong(11, 8)); final String name = readCString((int) namesize); ret.setName(name); if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry: "+ name + " Occured at byte: " + getBytesRead()); }', 'ret.setDevice(readBinaryLong(2, swapHalfWord)); ret.setInode(readBinaryLong(2, swapHalfWord)); final long mode = readBinaryLong(2, swapHalfWord); if (CpioUtil.fileType(mode) != 0){ ret.setMode(mode); } ret.setUID(readBinaryLong(2, swapHalfWord));', 'ret.setSize(readBinaryLong(4, swapHalfWord)); final String name = readCString((int) namesize); ret.setName(name); if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){ throw new IOException("Mode 0 only allowed in the trailer. Found entry: "+name + "Occured at byte: " + getBytesRead()); } skip(ret.getHeaderPadCount());'], ['if (mode != 0){', 'if (mode == 0 && !name.equals(CPIO_TRAILER)){', 'if (mode != 0) {', 'if (mode == 0 && !name.equals(CPIO_TRAILER)){', 'if (mode != 0){', 'if (mode == 0 && !name.equals(CPIO_TRAILER)){'], ['if (CpioUtil.fileType(mode) != 0){ // mode is initialised to 0', 'if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){', 'if (CpioUtil.fileType(mode) != 0) {', 'if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){', 'if (CpioUtil.fileType(mode) != 0){', 'if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){'], 'a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java']
['Compress-21', 1, 1, 1, 1, ['int shift = 7; for (int i = 0; i < length; i++) { cache |= ((bits.get(i) ? 1 : 0) << shift); --shift; if (shift == 0) { header.write(cache); shift = 7; cache = 0; } } if (length > 0 && shift > 0) { header.write(cache); } }'], ['int shift = 7; for (int i = 0; i < length; i++) { cache |= ((bits.get(i) ? 1 : 0) << shift); if (--shift < 0) { header.write(cache); shift = 7; cache = 0; } } if (shift != 7) { header.write(cache); } }'], ['--shift; if (shift == 0) { if (length > 0 && shift > 0) {'], ['if (--shift < 0) { if (shift != 7) {'], 'a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java', 'b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java']
['Compress-22', 7, 7, 7, 7, ['private InputStream in; private final boolean decompressConcatenated; private int currentChar = -1; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2;', ' init(true); initBlock(); setupBlock(); } @Override', '} private int read0() throws IOException { final int retChar = this.currentChar; switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: throw new IllegalStateException(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: setupRandPartB(); break; case RAND_PART_C_STATE: setupRandPartC(); break; case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: setupNoRandPartB(); break; case NO_RAND_PART_C_STATE: setupNoRandPartC(); break; default: throw new IllegalStateException(); } return retChar; } private boolean init(boolean isFirstStream) throws IOException {', '} this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;', 'this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentChar = su_ch2Shadow; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;', ' private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.currentChar = this.su_ch2; this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2;', 'private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.currentChar = su_ch2Shadow; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE;'], ['private InputStream in; private final boolean decompressConcatenated; private static final int EOF = 0; private static final int START_BLOCK_STATE = 1; private static final int RAND_PART_A_STATE = 2;', ' init(true); initBlock(); } @Override', '} private int read0() throws IOException { switch (currentState) { case EOF: return -1; case START_BLOCK_STATE: return setupBlock(); case RAND_PART_A_STATE: throw new IllegalStateException(); case RAND_PART_B_STATE: return setupRandPartB(); case RAND_PART_C_STATE: return setupRandPartC(); case NO_RAND_PART_A_STATE: throw new IllegalStateException(); case NO_RAND_PART_B_STATE: return setupNoRandPartB(); case NO_RAND_PART_C_STATE: return setupNoRandPartC(); default: throw new IllegalStateException(); } } private boolean init(boolean isFirstStream) throws IOException {', '} this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; this.su_i2++; this.currentState = RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;', 'this.su_ch2 = su_ch2Shadow; this.su_tPos = this.data.tt[this.su_tPos]; this.su_i2++; this.currentState = NO_RAND_PART_B_STATE; this.crc.updateCRC(su_ch2Shadow); return su_ch2Shadow;', ' private int setupRandPartC() throws IOException { if (this.su_j2 < this.su_z) { this.crc.updateCRC(this.su_ch2); this.su_j2++; return this.su_ch2;', 'private int setupNoRandPartC() throws IOException { if (this.su_j2 < this.su_z) { int su_ch2Shadow = this.su_ch2; this.crc.updateCRC(su_ch2Shadow); this.su_j2++; this.currentState = NO_RAND_PART_C_STATE;'], ['private int currentChar = -1;', 'setupBlock();', 'final int retChar = this.currentChar; throw new IllegalStateException(); setupRandPartB(); break; setupRandPartC(); break; setupNoRandPartB(); break; setupNoRandPartC(); break; return retChar;', 'this.currentChar = su_ch2Shadow;', 'this.currentChar = su_ch2Shadow;', 'this.currentChar = this.su_ch2;', 'this.currentChar = su_ch2Shadow;'], ['', '', 'return setupBlock(); return setupRandPartB(); return setupRandPartC(); return setupNoRandPartB(); return setupNoRandPartC();', '', '', '', ''], 'a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java', 'b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java']
['Compress-23', 1, 1, 1, 1, ['byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { dictSize |= (coder.properties[i + 1] << (8 * i)); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException("Dictionary larger than 4GiB maximum size");'], ['byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException("Dictionary larger than 4GiB maximum size");'], ['dictSize |= (coder.properties[i + 1] << (8 * i));'], ['dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);'], 'a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java', 'b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java']
['Compress-24', 1, 1, 1, 1, ["// space but some implementations use the extra digit for big // sizes/uids/gids ... byte trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end - 1]; while (start < end - 1 && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) {"], ["// space but some implementations use the extra digit for big // sizes/uids/gids ... byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } for ( ;start < end; start++) {"], ["if (trailer == 0 || trailer == ' '){ } else { exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end - 1]; while (start < end - 1 && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1];"], ["while (start < end && (trailer == 0 || trailer == ' ')) { trailer = buffer[end - 1]; } if (start == end) { exceptionMessage(buffer, offset, length, start, trailer));"], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-25', 1, 1, 1, 1, ["this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor; // haven't read anything so far } public ZipArchiveEntry getNextZipEntry() throws IOException {"], ["this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor; // haven't read anything so far buf.limit(0); } public ZipArchiveEntry getNextZipEntry() throws IOException {"], [''], ['buf.limit(0);'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Compress-26', 1, 1, 1, 1, ['numToSkip -= skipped; } return available - numToSkip; }'], ['numToSkip -= skipped; } if (numToSkip > 0) { byte[] skipBuf = new byte[SKIP_BUF_SIZE]; while (numToSkip > 0) { int read = readFully(input, skipBuf, 0, (int) Math.min(numToSkip, SKIP_BUF_SIZE)); if (read < 1) { break; } numToSkip -= read; } } return available - numToSkip; }'], [''], ['if (numToSkip > 0) { byte[] skipBuf = new byte[SKIP_BUF_SIZE]; while (numToSkip > 0) { int read = readFully(input, skipBuf, 0, (int) Math.min(numToSkip, SKIP_BUF_SIZE)); if (read < 1) { break; } numToSkip -= read; } }'], 'a/src/main/java/org/apache/commons/compress/utils/IOUtils.java', 'b/src/main/java/org/apache/commons/compress/utils/IOUtils.java']
['Compress-27', 1, 1, 1, 1, ['end--; trailer = buffer[end - 1]; } if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } for ( ;start < end; start++) { final byte currentByte = buffer[start];'], ['end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start];'], ['if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); }'], [''], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-28', 1, 1, 1, 1, ['numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; }'], ['numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; }'], ['count(totalRead);'], ['if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } count(totalRead);'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java']
['Compress-29', 14, 14, 14, 14, ['} } if (JAR.equalsIgnoreCase(archiverName)) { return new JarArchiveOutputStream(out); } if (CPIO.equalsIgnoreCase(archiverName)) { if (entryEncoding != null) {', 'return new CpioArchiveInputStream(in); } } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return new ArjArchiveInputStream(in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** * Construct the cpio input stream with a blocksize of {@link', 'public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) { this.in = in; this.blockSize = blockSize; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); }', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** * Construct the cpio output stream with a specified format, a', '} this.entryFormat = format; this.blockSize = blockSize; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); }', "private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** * Constructor using the platform's default encoding for file", 'throws ArchiveException { this.raw = new TapeInputStream(is); this.hasHitEOF = false; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); try {', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** * Constructor for TarInputStream.', 'String encoding) { this.is = is; this.hasHitEOF = false; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.recordSize = recordSize; this.blockSize = blockSize;', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) private boolean addPaxHeadersForNonAsciiNames = false; private static final ZipEncoding ASCII =', 'public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) { out = new CountingOutputStream(os); this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.assemLen = 0;', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) /** Whether to look for and use Unicode extra fields. */ private final boolean useUnicodeExtraFields;', 'String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) { zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; in = new PushbackInputStream(inputStream, buf.capacity());'], ['} } if (JAR.equalsIgnoreCase(archiverName)) { if (entryEncoding != null) { return new JarArchiveOutputStream(out, entryEncoding); } else { return new JarArchiveOutputStream(out); } } if (CPIO.equalsIgnoreCase(archiverName)) { if (entryEncoding != null) {', 'return new CpioArchiveInputStream(in); } } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { if (entryEncoding != null) { return new ArjArchiveInputStream(in, entryEncoding); } else { return new ArjArchiveInputStream(in); } } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** * Construct the cpio input stream with a blocksize of {@link', 'public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) { this.in = in; this.blockSize = blockSize; this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); }', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** * Construct the cpio output stream with a specified format, a', '} this.entryFormat = format; this.blockSize = blockSize; this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); }', "private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** * Constructor using the platform's default encoding for file", 'throws ArchiveException { this.raw = new TapeInputStream(is); this.hasHitEOF = false; this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); try {', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** * Constructor for TarInputStream.', 'String encoding) { this.is = is; this.hasHitEOF = false; this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.recordSize = recordSize; this.blockSize = blockSize;', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; private boolean addPaxHeadersForNonAsciiNames = false; private static final ZipEncoding ASCII =', 'public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) { out = new CountingOutputStream(os); this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.assemLen = 0;', 'private final ZipEncoding zipEncoding; // the provided encoding (for unit tests) final String encoding; /** Whether to look for and use Unicode extra fields. */ private final boolean useUnicodeExtraFields;', 'String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) { this.encoding = encoding; zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; in = new PushbackInputStream(inputStream, buf.capacity());'], ['', '', '', '', '', '', '', '', '', '', '', '', '', ''], ['if (entryEncoding != null) { return new JarArchiveOutputStream(out, entryEncoding); } else { }', 'if (entryEncoding != null) { return new ArjArchiveInputStream(in, entryEncoding); } else { }', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;', 'final String encoding;', 'this.encoding = encoding;'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Compress-30', 1, 1, 1, 1, ['if (this.in == null) { throw new IOException("stream closed"); } final int hi = offs + len; int destOffs = offs;'], ['if (this.in == null) { throw new IOException("stream closed"); } if (len == 0) { return 0; } final int hi = offs + len; int destOffs = offs;'], [''], ['if (len == 0) { return 0; }'], 'a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java', 'b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java']
['Compress-31', 1, 1, 1, 1, [" for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte == 0) { break; } // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException("], [" for ( ;start < end; start++) { final byte currentByte = buffer[start]; // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException("], ['if (currentByte == 0) { break; }'], [''], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-32', 1, 1, 1, 1, ['} else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){'], ['} else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Long.parseLong(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Long.parseLong(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){'], ['currEntry.setGroupId(Integer.parseInt(val)); currEntry.setUserId(Integer.parseInt(val));'], ['currEntry.setGroupId(Long.parseLong(val)); currEntry.setUserId(Long.parseLong(val));'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java']
['Compress-33', 3, 3, 3, 3, ['return new ZCompressorInputStream(in); } if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {', '* @since 1.9 */ public class DeflateCompressorInputStream extends CompressorInputStream { private final InputStream in;', '* * @since 1.9 */ }'], ['return new ZCompressorInputStream(in); } if (DeflateCompressorInputStream.matches(signature, signatureLength)) { return new DeflateCompressorInputStream(in); } if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {', '* @since 1.9 */ public class DeflateCompressorInputStream extends CompressorInputStream { private static final int MAGIC_1 = 0x78; private static final int MAGIC_2a = 0x01; private static final int MAGIC_2b = 0x5e; private static final int MAGIC_2c = 0x9c; private static final int MAGIC_2d = 0xda; private final InputStream in;', '* * @since 1.9 */ public static boolean matches(byte[] signature, int length) { return length > 3 && signature[0] == MAGIC_1 && ( signature[1] == (byte) MAGIC_2a || signature[1] == (byte) MAGIC_2b || signature[1] == (byte) MAGIC_2c || signature[1] == (byte) MAGIC_2d); } }'], ['', '', ''], ['if (DeflateCompressorInputStream.matches(signature, signatureLength)) { return new DeflateCompressorInputStream(in); }', 'private static final int MAGIC_1 = 0x78; private static final int MAGIC_2a = 0x01; private static final int MAGIC_2b = 0x5e; private static final int MAGIC_2c = 0x9c; private static final int MAGIC_2d = 0xda;', 'public static boolean matches(byte[] signature, int length) { return length > 3 && signature[0] == MAGIC_1 && ( signature[1] == (byte) MAGIC_2a || signature[1] == (byte) MAGIC_2b || signature[1] == (byte) MAGIC_2c || signature[1] == (byte) MAGIC_2d); }'], 'a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java', 'b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java']
['Compress-34', 2, 2, 2, 2, ['*/ public class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable { private static final ZipShort HEADER_ID = new ZipShort(0x7875); private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000); private static final long serialVersionUID = 1L;', '* @return a <code>ZipShort</code> for the length of the data of this extra field */ public ZipShort getCentralDirectoryLength() { return getLocalFileDataLength(); } /**'], ['*/ public class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable { private static final ZipShort HEADER_ID = new ZipShort(0x7875); private static final ZipShort ZERO = new ZipShort(0); private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000); private static final long serialVersionUID = 1L;', '* @return a <code>ZipShort</code> for the length of the data of this extra field */ public ZipShort getCentralDirectoryLength() { return ZERO; } /**'], ['', 'return getLocalFileDataLength();'], ['private static final ZipShort ZERO = new ZipShort(0);', 'return ZERO;'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java']
['Compress-35', 2, 2, 2, 2, ['* @since 1.5 */ public static boolean verifyCheckSum(byte[] header) { long storedSum = 0; long unsignedSum = 0; long signedSum = 0;', "for (int i = 0; i < header.length; i++) { byte b = header[i]; if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) { if ('0' <= b && b <= '7' && digits++ < 6) { storedSum = storedSum * 8 + b - '0'; } else if (digits > 0) { digits = 6; } b = ' '; } unsignedSum += 0xff & b;"], ['* @since 1.5 */ public static boolean verifyCheckSum(byte[] header) { long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN); long unsignedSum = 0; long signedSum = 0;', "for (int i = 0; i < header.length; i++) { byte b = header[i]; if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) { b = ' '; } unsignedSum += 0xff & b;"], ['long storedSum = 0;', "if ('0' <= b && b <= '7' && digits++ < 6) { storedSum = storedSum * 8 + b - '0'; } else if (digits > 0) { digits = 6; }"], ['long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);', ''], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-36', 1, 1, 1, 1, ['} private InputStream getCurrentStream() throws IOException { if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); }'], ['} private InputStream getCurrentStream() throws IOException { if (archive.files[currentEntryIndex].getSize() == 0) { return new ByteArrayInputStream(new byte[0]); } if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); }'], [''], ['if (archive.files[currentEntryIndex].getSize() == 0) { return new ByteArrayInputStream(new byte[0]); }'], 'a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java', 'b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java']
['Compress-37', 1, 1, 1, 1, ["int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) {"], ["int read = 0; while((ch = i.read()) != -1) { read++; if (ch == '\\n') { // blank line in header break; } else if (ch == ' '){ // End of length string // Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) {"], ["if (ch == ' '){"], ["if (ch == '\\n') { // blank line in header break; } else if (ch == ' '){ // End of length string"], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java']
['Compress-38', 1, 1, 1, 1, ['return true; } if (getName().endsWith("/")) { return true; }'], ['return true; } if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith("/")) { return true; }'], ['if (getName().endsWith("/")) {'], ['if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith("/")) {'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java']
['Compress-39', 2, 2, 2, 2, ['*/ public class ArchiveUtils { /** Private constructor to prevent instantiation of this utility class. */ private ArchiveUtils(){', '* @since Compress 1.12 */ public static String sanitize(String s) { final char[] chars = s.toCharArray(); final int len = chars.length; final StringBuilder sb = new StringBuilder(); for (int i = 0; i < len; i++) {'], ['*/ public class ArchiveUtils { private static final int MAX_SANITIZED_NAME_LENGTH = 255; /** Private constructor to prevent instantiation of this utility class. */ private ArchiveUtils(){', "* @since Compress 1.12 */ public static String sanitize(String s) { final char[] cs = s.toCharArray(); final char[] chars = cs.length <= MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH); if (cs.length > MAX_SANITIZED_NAME_LENGTH) { for (int i = MAX_SANITIZED_NAME_LENGTH - 3; i < MAX_SANITIZED_NAME_LENGTH; i++) { chars[i] = '.'; } } final int len = chars.length; final StringBuilder sb = new StringBuilder(); for (int i = 0; i < len; i++) {"], ['', 'final char[] chars = s.toCharArray();'], ['private static final int MAX_SANITIZED_NAME_LENGTH = 255;', "final char[] cs = s.toCharArray(); final char[] chars = cs.length <= MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH); if (cs.length > MAX_SANITIZED_NAME_LENGTH) { for (int i = MAX_SANITIZED_NAME_LENGTH - 3; i < MAX_SANITIZED_NAME_LENGTH; i++) { chars[i] = '.'; } }"], 'a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java', 'b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java']
['Compress-40', 3, 3, 3, 3, ['if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte;', '} bitsCachedSize += 8; } // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count;', 'bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; } }'], ['if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count && bitsCachedSize < 57) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte;', '} bitsCachedSize += 8; } int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } final long bitsOut; if (overflowBits == 0) { if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count;', 'bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; } else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; } return bitsOut; } }'], ['while (bitsCachedSize < count) {', '', ''], ['while (bitsCachedSize < count && bitsCachedSize < 57) {', 'int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } if (overflowBits == 0) {', '} else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; }'], 'a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java', 'b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java']
['Compress-41', 1, 1, 1, 1, ['if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) { hitCentralDirectory = true; skipRemainderOfArchive(); } if (!sig.equals(ZipLong.LFH_SIG)) { return null; } int off = WORD;'], ['if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) { hitCentralDirectory = true; skipRemainderOfArchive(); return null; } if (!sig.equals(ZipLong.LFH_SIG)) { throw new ZipException(String.format("Unexpected record signature: 0X%X", sig.getValue())); } int off = WORD;'], ['return null;'], ['return null; throw new ZipException(String.format("Unexpected record signature: 0X%X", sig.getValue()));'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Compress-42', 2, 2, 2, 2, ['* Bits used to indicate the filesystem object type. * @since 1.14 */ /** * Indicates symbolic links. */', '* @return true if the entry represents a unix symlink, false otherwise. */ public boolean isUnixSymlink() { return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG; } /**'], ['* Bits used to indicate the filesystem object type. * @since 1.14 */ int FILE_TYPE_FLAG = 0170000; /** * Indicates symbolic links. */', '* @return true if the entry represents a unix symlink, false otherwise. */ public boolean isUnixSymlink() { return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG; } /**'], ['', 'return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;'], ['int FILE_TYPE_FLAG = 0170000;', 'return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG;'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java']
['Compress-43', 4, 4, 4, 4, [' final long localHeaderStart = streamCompressor.getTotalBytesWritten(); final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart); metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod()))); entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset writeCounted(localHeader); entry.dataStart = streamCompressor.getTotalBytesWritten();', ' //store method in local variable to prevent multiple method calls final int zipMethod = ze.getMethod(); final boolean dataDescriptor = usesDataDescriptor(zipMethod); putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);', '* @throws IOException on error */ protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException { if (ze.getMethod() != DEFLATED || channel != null) { return; } writeCounted(DD_SIG);', 'return versionNeededToExtractMethod(zipMethod); } private boolean usesDataDescriptor(final int zipMethod) { return zipMethod == DEFLATED && channel == null; } private int versionNeededToExtractMethod(int zipMethod) {'], [' final long localHeaderStart = streamCompressor.getTotalBytesWritten(); final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart); metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased))); entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset writeCounted(localHeader); entry.dataStart = streamCompressor.getTotalBytesWritten();', ' //store method in local variable to prevent multiple method calls final int zipMethod = ze.getMethod(); final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased); putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);', '* @throws IOException on error */ protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException { if (!usesDataDescriptor(ze.getMethod(), false)) { return; } writeCounted(DD_SIG);', 'return versionNeededToExtractMethod(zipMethod); } private boolean usesDataDescriptor(final int zipMethod, boolean phased) { return !phased && zipMethod == DEFLATED && channel == null; } private int versionNeededToExtractMethod(int zipMethod) {'], ['metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));', 'final boolean dataDescriptor = usesDataDescriptor(zipMethod);', 'if (ze.getMethod() != DEFLATED || channel != null) {', 'private boolean usesDataDescriptor(final int zipMethod) { return zipMethod == DEFLATED && channel == null;'], ['metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));', 'final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);', 'if (!usesDataDescriptor(ze.getMethod(), false)) {', 'private boolean usesDataDescriptor(final int zipMethod, boolean phased) { return !phased && zipMethod == DEFLATED && channel == null;'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java']
['Compress-44', 1, 1, 1, 1, [' public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) { this.checksum = checksum; this.in = in;'], [' public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) { if ( checksum == null ){ throw new NullPointerException("Parameter checksum must not be null"); } if ( in == null ){ throw new NullPointerException("Parameter in must not be null"); } this.checksum = checksum; this.in = in;'], [''], ['if ( checksum == null ){ throw new NullPointerException("Parameter checksum must not be null"); } if ( in == null ){ throw new NullPointerException("Parameter in must not be null"); }'], 'a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java', 'b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java']
['Compress-45', 1, 1, 1, 1, [' if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length;'], [' if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } else { formatBigIntegerBinary(value, buf, offset, length, negative); } buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length;'], ['formatBigIntegerBinary(value, buf, offset, length, negative);'], ['} else { formatBigIntegerBinary(value, buf, offset, length, negative);'], 'a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java', 'b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java']
['Compress-46', 1, 1, 1, 1, ['} private static ZipLong unixTimeToZipLong(long l) { final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { throw new IllegalArgumentException("X5455 timestamps must fit in a signed 32 bit integer: " + l); } return new ZipLong(l);'], ['} private static ZipLong unixTimeToZipLong(long l) { if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { throw new IllegalArgumentException("X5455 timestamps must fit in a signed 32 bit integer: " + l); } return new ZipLong(l);'], ['final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) {'], ['if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java']
['Compress-47', 3, 3, 3, 3, ['if (ae instanceof ZipArchiveEntry) { final ZipArchiveEntry ze = (ZipArchiveEntry) ae; return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze); } return false; }', 'throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry); } int read; if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {', '* Whether the compressed size for the entry is either known or * not required by the compression method being used. */ /** * Caches a stored entry that uses the data descriptor.'], ['if (ae instanceof ZipArchiveEntry) { final ZipArchiveEntry ze = (ZipArchiveEntry) ae; return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze) && supportsCompressedSizeFor(ze); } return false; }', 'throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry); } if (!supportsCompressedSizeFor(current.entry)) { throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry); } int read; if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {', '* Whether the compressed size for the entry is either known or * not required by the compression method being used. */ private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) { return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN || entry.getMethod() == ZipEntry.DEFLATED || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED); } /** * Caches a stored entry that uses the data descriptor.'], ['&& supportsDataDescriptorFor(ze);', '', ''], ['&& supportsDataDescriptorFor(ze) && supportsCompressedSizeFor(ze);', 'if (!supportsCompressedSizeFor(current.entry)) { throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry); }', 'private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) { return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN || entry.getMethod() == ZipEntry.DEFLATED || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED); }'], 'a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java', 'b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java']
['Gson-1', 2, 2, 2, 2, ['int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); return actualTypeArguments[indexOfActualTypeArgument]; } throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType', '} } // Evaluate type on this type private static Type[] extractRealTypes( Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {'], ['int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); return actualTypeArguments[indexOfActualTypeArgument]; } else if (typeToEvaluate instanceof TypeVariable<?>) { Type theSearchedType = null; do { theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); if (theSearchedType != null) { return theSearchedType; } } throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType', '} } private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { Class<?> rawParentType = null; if (parentType instanceof Class<?>) { rawParentType = (Class<?>) parentType; } else if (parentType instanceof ParameterizedType) { ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; rawParentType = (Class<?>) parentTypeAsPT.getRawType(); } else { return null; } Type superClass = rawParentType.getGenericSuperclass(); if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { // Evaluate type on this type TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); Type[] actualTypeArguments = null; if (parentType instanceof Class<?>) { actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); } else if (parentType instanceof ParameterizedType) { actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); } else { return null; } return actualTypeArguments[indexOfActualTypeArgument]; } Type searchedType = null; if (superClass != null) { searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); } return searchedType; } private static Type[] extractRealTypes( Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {'], ['', ''], ['} else if (typeToEvaluate instanceof TypeVariable<?>) { Type theSearchedType = null; do { theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); if (theSearchedType != null) { return theSearchedType; }', 'private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { Class<?> rawParentType = null; if (parentType instanceof Class<?>) { rawParentType = (Class<?>) parentType; } else if (parentType instanceof ParameterizedType) { ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; rawParentType = (Class<?>) parentTypeAsPT.getRawType(); } else { return null; } Type superClass = rawParentType.getGenericSuperclass(); if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); Type[] actualTypeArguments = null; if (parentType instanceof Class<?>) { actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); } else if (parentType instanceof ParameterizedType) { actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); } else { return null; } return actualTypeArguments[indexOfActualTypeArgument]; } Type searchedType = null; if (superClass != null) { searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); } return searchedType; }'], 'a/gson/src/main/java/com/google/gson/TypeInfoFactory.java', 'b/gson/src/main/java/com/google/gson/TypeInfoFactory.java']
['Gson-2', 1, 1, 1, 1, ['if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) typeAdapter; } @Override public String toString() { return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]";'], ['if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException("Expected a " + requestedType.getName() + " but was " + result.getClass().getName()); } return result; } }; } @Override public String toString() { return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]";'], ['return (TypeAdapter<T2>) typeAdapter;'], ['return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException("Expected a " + requestedType.getName() + " but was " + result.getClass().getName()); } return result; } };'], 'a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java']
['Gson-3', 2, 2, 2, 2, ['import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet; import com.google.gson.InstanceCreator; import com.google.gson.JsonIOException;', '} if (Map.class.isAssignableFrom(rawType)) { if (SortedMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new TreeMap<Object, Object>();'], ['import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.ConcurrentNavigableMap; import java.util.concurrent.ConcurrentSkipListMap; import com.google.gson.InstanceCreator; import com.google.gson.JsonIOException;', '} if (Map.class.isAssignableFrom(rawType)) { if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new ConcurrentSkipListMap<Object, Object>(); } }; } else if (ConcurrentMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new ConcurrentHashMap<Object, Object>(); } }; } else if (SortedMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new TreeMap<Object, Object>();'], ['', 'if (SortedMap.class.isAssignableFrom(rawType)) {'], ['import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.ConcurrentNavigableMap; import java.util.concurrent.ConcurrentSkipListMap;', 'if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new ConcurrentSkipListMap<Object, Object>(); } }; } else if (ConcurrentMap.class.isAssignableFrom(rawType)) { return new ObjectConstructor<T>() { @Override public T construct() { return (T) new ConcurrentHashMap<Object, Object>(); } }; } else if (SortedMap.class.isAssignableFrom(rawType)) {'], 'a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java', 'b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java']
['Gson-4', 12, 12, 12, 12, ['checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case \'"\': if (stackSize == 1) { checkLenient(); } return peeked = PEEKED_DOUBLE_QUOTED; case \'[\': return peeked = PEEKED_BEGIN_ARRAY;', "default: pos--; // Don't consume the first character in a literal value. } if (stackSize == 1) { checkLenient(); } int result = peekKeyword(); if (result != PEEKED_NONE) {", '* bracket. */ private JsonWriter open(int empty, String openBracket) throws IOException { beforeValue(true); push(empty); out.write(openBracket); return this;', 'return nullValue(); } writeDeferredName(); beforeValue(false); string(value); return this; }', 'return nullValue(); } writeDeferredName(); beforeValue(false); out.append(value); return this; }', 'return this; // skip the name and the value } } beforeValue(false); out.write("null"); return this; }', '*/ public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(false); out.write(value ? "true" : "false"); return this; }', 'throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } writeDeferredName(); beforeValue(false); out.append(Double.toString(value)); return this; }', '*/ public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(false); out.write(Long.toString(value)); return this; }', '&& (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue(false); out.append(string); return this; }', '* closing bracket or another element. */ @SuppressWarnings("fallthrough") private void beforeValue(boolean root) throws IOException { switch (peek()) { case NONEMPTY_DOCUMENT: if (!lenient) {', '} // fall-through case EMPTY_DOCUMENT: // first in document if (!lenient && !root) { throw new IllegalStateException( "JSON must start with an array or an object."); } replaceTop(NONEMPTY_DOCUMENT); break;'], ['checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case \'"\': return peeked = PEEKED_DOUBLE_QUOTED; case \'[\': return peeked = PEEKED_BEGIN_ARRAY;', "default: pos--; // Don't consume the first character in a literal value. } int result = peekKeyword(); if (result != PEEKED_NONE) {", '* bracket. */ private JsonWriter open(int empty, String openBracket) throws IOException { beforeValue(); push(empty); out.write(openBracket); return this;', 'return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; }', 'return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; }', 'return this; // skip the name and the value } } beforeValue(); out.write("null"); return this; }', '*/ public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; }', 'throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; }', '*/ public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; }', '&& (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue(); out.append(string); return this; }', '* closing bracket or another element. */ @SuppressWarnings("fallthrough") private void beforeValue() throws IOException { switch (peek()) { case NONEMPTY_DOCUMENT: if (!lenient) {', '} // fall-through case EMPTY_DOCUMENT: // first in document replaceTop(NONEMPTY_DOCUMENT); break;'], ['if (stackSize == 1) { checkLenient(); }', 'if (stackSize == 1) { checkLenient(); }', 'beforeValue(true);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'beforeValue(false);', 'private void beforeValue(boolean root) throws IOException {', 'if (!lenient && !root) { throw new IllegalStateException( "JSON must start with an array or an object."); }'], ['', '', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'beforeValue();', 'private void beforeValue() throws IOException {', ''], 'a/gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'b/gson/src/main/java/com/google/gson/stream/JsonWriter.java']
['Gson-5', 1, 1, 1, 1, ['String timezoneOffset = date.substring(offset); // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00 offset += timezoneOffset.length(); // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"'], ['String timezoneOffset = date.substring(offset); // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00 timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + "00"; offset += timezoneOffset.length(); // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"'], [''], ['timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + "00";'], 'a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java', 'b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java']
['Gson-6', 1, 1, 1, 1, ['throw new IllegalArgumentException( "@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."); } typeAdapter = typeAdapter.nullSafe(); return typeAdapter; } }'], ['throw new IllegalArgumentException( "@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."); } if (typeAdapter != null) { typeAdapter = typeAdapter.nullSafe(); } return typeAdapter; } }'], [''], ['if (typeAdapter != null) { }'], 'a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java', 'b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java']
['Gson-7', 2, 2, 2, 2, ['if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? \'\\\'\' : \'"\'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE;', 'if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? \'\\\'\' : \'"\'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE;'], ['if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? \'\\\'\' : \'"\'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE;', 'if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? \'\\\'\' : \'"\'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE;'], ['} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {', '} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {'], ['} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { }', '} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { }'], 'a/gson/src/main/java/com/google/gson/stream/JsonReader.java', 'b/gson/src/main/java/com/google/gson/stream/JsonReader.java']
['Gson-8', 5, 5, 5, 5, ['import java.io.ObjectStreamClass; import java.lang.reflect.Field; import java.lang.reflect.Method; /** * Do sneaky things to allocate objects without invoking their constructors.', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { return (T) allocateInstance.invoke(unsafe, c); } };', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { return (T) newInstance.invoke(null, c, constructorId); } };', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { return (T) newInstance.invoke(null, c, Object.class); } };', '* throw an {@link java.lang.UnsupportedOperationException} * @param c instance of the class to be checked */ }'], ['import java.io.ObjectStreamClass; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Modifier; /** * Do sneaky things to allocate objects without invoking their constructors.', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) allocateInstance.invoke(unsafe, c); } };', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, constructorId); } };', '@Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, Object.class); } };', '* throw an {@link java.lang.UnsupportedOperationException} * @param c instance of the class to be checked */ private static void assertInstantiable(Class<?> c) { int modifiers = c.getModifiers(); if (Modifier.isInterface(modifiers)) { throw new UnsupportedOperationException("Interface can\'t be instantiated! Interface name: " + c.getName()); } if (Modifier.isAbstract(modifiers)) { throw new UnsupportedOperationException("Abstract class can\'t be instantiated! Class name: " + c.getName()); } } }'], ['', '', '', '', ''], ['import java.lang.reflect.Modifier;', 'assertInstantiable(c);', 'assertInstantiable(c);', 'assertInstantiable(c);', 'private static void assertInstantiable(Class<?> c) { int modifiers = c.getModifiers(); if (Modifier.isInterface(modifiers)) { throw new UnsupportedOperationException("Interface can\'t be instantiated! Interface name: " + c.getName()); } if (Modifier.isAbstract(modifiers)) { throw new UnsupportedOperationException("Abstract class can\'t be instantiated! Class name: " + c.getName()); } }'], 'a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java', 'b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java']
['Gson-9', 3, 3, 3, 3, ['return this; } @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {', '} @Override public void write(JsonWriter out, Boolean value) throws IOException { if (value == null) { out.nullValue(); return; } out.value(value); } };', '* * @return this writer. */ /** * Encodes {@code value}.'], ['return this; } @Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {', '} @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } };', '* * @return this writer. */ public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; } /** * Encodes {@code value}.'], ['', 'if (value == null) { out.nullValue(); return; }', ''], ['@Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; }', '', 'public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; }'], 'a/gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'b/gson/src/main/java/com/google/gson/stream/JsonWriter.java']
['Gson-10', 1, 1, 1, 1, ['@Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value)'], ['@Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value)'], ['TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());'], ['TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());'], 'a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java', 'b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java']
['Gson-11', 1, 1, 1, 1, ['in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException("Expecting number, got: " + jsonToken);'], ['in.nextNull(); return null; case NUMBER: case STRING: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException("Expecting number, got: " + jsonToken);'], [''], ['case STRING:'], 'a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java']
['Gson-12', 1, 1, 1, 1, ['pathNames[stackSize - 2] = "null"; } else { popStack(); pathNames[stackSize - 1] = "null"; } pathIndices[stackSize - 1]++; } @Override public String toString() {'], ['pathNames[stackSize - 2] = "null"; } else { popStack(); if (stackSize > 0) { pathNames[stackSize - 1] = "null"; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; } } @Override public String toString() {'], [''], ['if (stackSize > 0) { } if (stackSize > 0) { }'], 'a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java', 'b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java']
['Gson-13', 1, 1, 1, 1, ["} // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER. if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) { peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG;"], ["} // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER. if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) { peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG;"], ['if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {'], ['if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {'], 'a/gson/src/main/java/com/google/gson/stream/JsonReader.java', 'b/gson/src/main/java/com/google/gson/stream/JsonReader.java']
['Gson-14', 2, 2, 2, 2, ['*/ public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; upperBounds = new Type[] { bound }; return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); }', '*/ public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; lowerBounds = new Type[] { bound }; return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); }'], ['*/ public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); }', '*/ public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); }'], ['', ''], ['if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { }', 'if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { }'], 'a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java']
['Gson-15', 1, 1, 1, 1, ['*/ public JsonWriter value(double value) throws IOException { writeDeferredName(); if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue();'], ['*/ public JsonWriter value(double value) throws IOException { writeDeferredName(); if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue();'], ['if (Double.isNaN(value) || Double.isInfinite(value)) {'], ['if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {'], 'a/gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'b/gson/src/main/java/com/google/gson/stream/JsonWriter.java']
['Gson-16', 1, 1, 1, 1, ['while (true) { if (toResolve instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; // cannot reduce due to infinite recursion toResolve = resolveTypeVariable(context, contextRawType, typeVariable); if (toResolve == typeVariable) { return toResolve;'], ['while (true) { if (toResolve instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; if (visitedTypeVariables.contains(typeVariable)) { // cannot reduce due to infinite recursion return toResolve; } else { visitedTypeVariables.add(typeVariable); } toResolve = resolveTypeVariable(context, contextRawType, typeVariable); if (toResolve == typeVariable) { return toResolve;'], [''], ['if (visitedTypeVariables.contains(typeVariable)) { return toResolve; } else { visitedTypeVariables.add(typeVariable); }'], 'a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java']
['Gson-17', 1, 1, 1, 1, [' @Override public Date read(JsonReader in) throws IOException { if (in.peek() != JsonToken.STRING) { throw new JsonParseException("The date should be a string value"); } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) {'], [' @Override public Date read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) {'], ['if (in.peek() != JsonToken.STRING) { throw new JsonParseException("The date should be a string value");'], ['if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;'], 'a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java', 'b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java']
['Gson-18', 1, 1, 1, 1, ['* @param supertype a superclass of, or interface implemented by, this. */ static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) { // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead checkArgument(supertype.isAssignableFrom(contextRawType)); return resolve(context, contextRawType, $Gson$Types.getGenericSupertype(context, contextRawType, supertype));'], ['* @param supertype a superclass of, or interface implemented by, this. */ static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) { if (context instanceof WildcardType) { // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead context = ((WildcardType)context).getUpperBounds()[0]; } checkArgument(supertype.isAssignableFrom(contextRawType)); return resolve(context, contextRawType, $Gson$Types.getGenericSupertype(context, contextRawType, supertype));'], [''], ['if (context instanceof WildcardType) { context = ((WildcardType)context).getUpperBounds()[0]; }'], 'a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java']
['Mockito-1', 1, 1, 1, 1, ['public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; throw new UnsupportedOperationException(); } else { for (int position = 0; position < matchers.size(); position++) {'], ['public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; for (int position = 0; position < indexOfVararg; position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } } } else { for (int position = 0; position < matchers.size(); position++) {'], ['throw new UnsupportedOperationException();'], ['for (int position = 0; position < indexOfVararg; position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } }'], 'a/src/org/mockito/internal/invocation/InvocationMatcher.java', 'b/src/org/mockito/internal/invocation/InvocationMatcher.java']
['Mockito-2', 3, 3, 3, 3, ['package org.mockito.internal.util; public class Timer {', 'private long startTime = -1; public Timer(long durationMillis) { this.durationMillis = durationMillis; }', 'startTime = System.currentTimeMillis(); } }'], ['package org.mockito.internal.util; import org.mockito.exceptions.Reporter; public class Timer {', 'private long startTime = -1; public Timer(long durationMillis) { validateInput(durationMillis); this.durationMillis = durationMillis; }', 'startTime = System.currentTimeMillis(); } private void validateInput(long durationMillis) { if (durationMillis < 0) { new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis); } } }'], ['', '', ''], ['import org.mockito.exceptions.Reporter;', 'validateInput(durationMillis);', 'private void validateInput(long durationMillis) { if (durationMillis < 0) { new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis); } }'], 'a/src/org/mockito/internal/util/Timer.java', 'b/src/org/mockito/internal/util/Timer.java']
['Mockito-3', 2, 2, 2, 2, ['((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } } } else {', '} } public static List<InvocationMatcher> createFrom(List<Invocation> invocations) { LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();'], ['((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (Matcher m : uniqueMatcherSet(indexOfVararg)) { if (m instanceof CapturesArguments) { Object rawArgument = invocation.getRawArguments()[indexOfVararg]; for (int i = 0; i < Array.getLength(rawArgument); i++) { ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i)); } } } } else {', '} } private Set<Matcher> uniqueMatcherSet(int indexOfVararg) { HashSet<Matcher> set = new HashSet<Matcher>(); for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher matcher = matchers.get(position); if(matcher instanceof MatcherDecorator) { set.add(((MatcherDecorator) matcher).getActualMatcher()); } else { set.add(matcher); } } return set; } public static List<InvocationMatcher> createFrom(List<Invocation> invocations) { LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();'], ['for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);', ''], ['for (Matcher m : uniqueMatcherSet(indexOfVararg)) { Object rawArgument = invocation.getRawArguments()[indexOfVararg]; for (int i = 0; i < Array.getLength(rawArgument); i++) { ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i)); }', 'private Set<Matcher> uniqueMatcherSet(int indexOfVararg) { HashSet<Matcher> set = new HashSet<Matcher>(); for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher matcher = matchers.get(position); if(matcher instanceof MatcherDecorator) { set.add(((MatcherDecorator) matcher).getActualMatcher()); } else { set.add(matcher); } } return set; }'], 'a/src/org/mockito/internal/invocation/InvocationMatcher.java', 'b/src/org/mockito/internal/invocation/InvocationMatcher.java']
['Mockito-4', 3, 3, 3, 3, ['throw new NoInteractionsWanted(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock \'" + undesired.getMock() + "\':", undesired.getLocation(), scenario ));', 'throw new VerificationInOrderFailure(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock \'" + undesired.getMock() + "\':", undesired.getLocation() )); }', '} private String exceptionCauseMessageIfAvailable(Exception details) { return details.getCause().getMessage(); }'], ['throw new NoInteractionsWanted(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock \'" + safelyGetMockName(undesired.getMock()) + "\':", undesired.getLocation(), scenario ));', 'throw new VerificationInOrderFailure(join( "No interactions wanted here:", new LocationImpl(), "But found this interaction on mock \'" + safelyGetMockName(undesired.getMock()) + "\':", undesired.getLocation() )); }', '} private String exceptionCauseMessageIfAvailable(Exception details) { if (details.getCause() == null) { return details.getMessage(); } return details.getCause().getMessage(); }'], ['"But found this interaction on mock \'" + undesired.getMock() + "\':",', '"But found this interaction on mock \'" + undesired.getMock() + "\':",', ''], ['"But found this interaction on mock \'" + safelyGetMockName(undesired.getMock()) + "\':",', '"But found this interaction on mock \'" + safelyGetMockName(undesired.getMock()) + "\':",', 'if (details.getCause() == null) { return details.getMessage(); }'], 'a/src/org/mockito/exceptions/Reporter.java', 'b/src/org/mockito/exceptions/Reporter.java']
['Mockito-5', 1, 1, 1, 1, ['} catch (MockitoAssertionError e) { error = handleVerifyException(e); } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { error = handleVerifyException(e); } }'], ['} catch (MockitoAssertionError e) { error = handleVerifyException(e); } catch (AssertionError e) { error = handleVerifyException(e); } }'], ['catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {'], ['catch (AssertionError e) {'], 'a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java', 'b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java']
['Mockito-6', 20, 20, 20, 20, ['* @return <code>false</code>. */ public static boolean anyBoolean() { return reportMatcher(Any.ANY).returnFalse(); } /**', '* @return <code>0</code>. */ public static byte anyByte() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static char anyChar() { return reportMatcher(Any.ANY).returnChar(); } /**', '* @return <code>0</code>. */ public static int anyInt() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static long anyLong() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static float anyFloat() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static double anyDouble() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>0</code>. */ public static short anyShort() { return reportMatcher(Any.ANY).returnZero(); } /**', '* @return <code>null</code>. */ public static <T> T anyObject() { return (T) reportMatcher(Any.ANY).returnNull(); } /**', '* @return <code>null</code>. */ public static <T> T any(Class<T> clazz) { return (T) reportMatcher(Any.ANY).returnFor(clazz); } /**', '* @return <code>null</code>. */ public static <T> T any() { return (T) anyObject(); } /**', '* @return empty String ("") */ public static String anyString() { return reportMatcher(Any.ANY).returnString(); } /**', '* @return empty List. */ public static List anyList() { return reportMatcher(Any.ANY).returnList(); } /**', '* @return empty List. */ public static <T> List<T> anyListOf(Class<T> clazz) { return (List) reportMatcher(Any.ANY).returnList(); } /**', '* @return empty Set */ public static Set anySet() { return reportMatcher(Any.ANY).returnSet(); } /**', '* @return empty Set */ public static <T> Set<T> anySetOf(Class<T> clazz) { return (Set) reportMatcher(Any.ANY).returnSet(); } /**', '* @return empty Map. */ public static Map anyMap() { return reportMatcher(Any.ANY).returnMap(); } /**', '* @return empty Map. */ public static <K, V> Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) { return reportMatcher(Any.ANY).returnMap(); } /**', '* @return empty Collection. */ public static Collection anyCollection() { return reportMatcher(Any.ANY).returnList(); } /**', '* @return empty Collection. */ public static <T> Collection<T> anyCollectionOf(Class<T> clazz) { return (Collection) reportMatcher(Any.ANY).returnList(); } /**'], ['* @return <code>false</code>. */ public static boolean anyBoolean() { return reportMatcher(new InstanceOf(Boolean.class)).returnFalse(); } /**', '* @return <code>0</code>. */ public static byte anyByte() { return reportMatcher(new InstanceOf(Byte.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static char anyChar() { return reportMatcher(new InstanceOf(Character.class)).returnChar(); } /**', '* @return <code>0</code>. */ public static int anyInt() { return reportMatcher(new InstanceOf(Integer.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static long anyLong() { return reportMatcher(new InstanceOf(Long.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static float anyFloat() { return reportMatcher(new InstanceOf(Float.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static double anyDouble() { return reportMatcher(new InstanceOf(Double.class)).returnZero(); } /**', '* @return <code>0</code>. */ public static short anyShort() { return reportMatcher(new InstanceOf(Short.class)).returnZero(); } /**', '* @return <code>null</code>. */ public static <T> T anyObject() { return (T) reportMatcher(new InstanceOf(Object.class)).returnNull(); } /**', '* @return <code>null</code>. */ public static <T> T any(Class<T> clazz) { return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz); } /**', '* @return <code>null</code>. */ public static <T> T any() { return (T) reportMatcher(Any.ANY).returnNull(); } /**', '* @return empty String ("") */ public static String anyString() { return reportMatcher(new InstanceOf(String.class)).returnString(); } /**', '* @return empty List. */ public static List anyList() { return reportMatcher(new InstanceOf(List.class)).returnList(); } /**', '* @return empty List. */ public static <T> List<T> anyListOf(Class<T> clazz) { return anyList(); } /**', '* @return empty Set */ public static Set anySet() { return reportMatcher(new InstanceOf(Set.class)).returnSet(); } /**', '* @return empty Set */ public static <T> Set<T> anySetOf(Class<T> clazz) { return anySet(); } /**', '* @return empty Map. */ public static Map anyMap() { return reportMatcher(new InstanceOf(Map.class)).returnMap(); } /**', '* @return empty Map. */ public static <K, V> Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) { return anyMap(); } /**', '* @return empty Collection. */ public static Collection anyCollection() { return reportMatcher(new InstanceOf(Collection.class)).returnList(); } /**', '* @return empty Collection. */ public static <T> Collection<T> anyCollectionOf(Class<T> clazz) { return anyCollection(); } /**'], ['return reportMatcher(Any.ANY).returnFalse();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnChar();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnZero();', 'return reportMatcher(Any.ANY).returnZero();', 'return (T) reportMatcher(Any.ANY).returnNull();', 'return (T) reportMatcher(Any.ANY).returnFor(clazz);', 'return (T) anyObject();', 'return reportMatcher(Any.ANY).returnString();', 'return reportMatcher(Any.ANY).returnList();', 'return (List) reportMatcher(Any.ANY).returnList();', 'return reportMatcher(Any.ANY).returnSet();', 'return (Set) reportMatcher(Any.ANY).returnSet();', 'return reportMatcher(Any.ANY).returnMap();', 'return reportMatcher(Any.ANY).returnMap();', 'return reportMatcher(Any.ANY).returnList();', 'return (Collection) reportMatcher(Any.ANY).returnList();'], ['return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();', 'return reportMatcher(new InstanceOf(Byte.class)).returnZero();', 'return reportMatcher(new InstanceOf(Character.class)).returnChar();', 'return reportMatcher(new InstanceOf(Integer.class)).returnZero();', 'return reportMatcher(new InstanceOf(Long.class)).returnZero();', 'return reportMatcher(new InstanceOf(Float.class)).returnZero();', 'return reportMatcher(new InstanceOf(Double.class)).returnZero();', 'return reportMatcher(new InstanceOf(Short.class)).returnZero();', 'return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();', 'return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);', 'return (T) reportMatcher(Any.ANY).returnNull();', 'return reportMatcher(new InstanceOf(String.class)).returnString();', 'return reportMatcher(new InstanceOf(List.class)).returnList();', 'return anyList();', 'return reportMatcher(new InstanceOf(Set.class)).returnSet();', 'return anySet();', 'return reportMatcher(new InstanceOf(Map.class)).returnMap();', 'return anyMap();', 'return reportMatcher(new InstanceOf(Collection.class)).returnList();', 'return anyCollection();'], 'a/src/org/mockito/Matchers.java', 'b/src/org/mockito/Matchers.java']
['Mockito-7', 1, 1, 1, 1, ['for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); }'], ['for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeParametersOn(new TypeVariable[] { typeVariable }); registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); }'], [''], ['registerTypeParametersOn(new TypeVariable[] { typeVariable });'], 'a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java', 'b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java']
['Mockito-8', 1, 1, 1, 1, [' if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); } else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } // logger.log("For \'" + parameterizedType + "\' found type variable : { \'" + typeParameter + "(" + System.identityHashCode(typeParameter) + ")" + "\' : \'" + actualTypeArgument + "(" + System.identityHashCode(typeParameter) + ")" + "\' }");'], [' if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); } else if (typeParameter != actualTypeArgument) { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } // logger.log("For \'" + parameterizedType + "\' found type variable : { \'" + typeParameter + "(" + System.identityHashCode(typeParameter) + ")" + "\' : \'" + actualTypeArgument + "(" + System.identityHashCode(typeParameter) + ")" + "\' }");'], ['} else {'], ['} else if (typeParameter != actualTypeArgument) {'], 'a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java', 'b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java']
['Mockito-9', 2, 2, 2, 2, ['package org.mockito.internal.stubbing.answers; import java.io.Serializable; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer;', 'private static final long serialVersionUID = 9057165148930624087L; public Object answer(InvocationOnMock invocation) throws Throwable { return invocation.callRealMethod(); } } No newline at end of file'], ['package org.mockito.internal.stubbing.answers; import java.io.Serializable; import java.lang.reflect.Modifier; import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer;', 'private static final long serialVersionUID = 9057165148930624087L; public Object answer(InvocationOnMock invocation) throws Throwable { if (Modifier.isAbstract(invocation.getMethod().getModifiers())) { return new GloballyConfiguredAnswer().answer(invocation); } return invocation.callRealMethod(); } } No newline at end of file'], ['', ''], ['import java.lang.reflect.Modifier; import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;', 'if (Modifier.isAbstract(invocation.getMethod().getModifiers())) { return new GloballyConfiguredAnswer().answer(invocation); }'], 'a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java', 'b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java']
['Mockito-10', 3, 3, 3, 3, ['import org.mockito.internal.util.MockUtil; import org.mockito.internal.util.reflection.GenericMetadataSupport; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import java.io.IOException;', ' // record deep stub answer return recordDeepStubAnswer( newDeepStubMock(returnTypeGenericMetadata), container ); }', '* @param parentMock The parent of the current deep stub mock. * @return The mock */ private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) { return mockitoCore().mock( returnTypeGenericMetadata.rawType(), withSettingsUsing(returnTypeGenericMetadata) ); } private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) { MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ? withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) : withSettings(); return mockSettings.serializable() .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); } private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) { return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);'], ['import org.mockito.internal.util.MockUtil; import org.mockito.internal.util.reflection.GenericMetadataSupport; import org.mockito.invocation.InvocationOnMock; import org.mockito.mock.MockCreationSettings; import org.mockito.stubbing.Answer; import java.io.IOException;', ' // record deep stub answer return recordDeepStubAnswer( newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()), container ); }', '* @param parentMock The parent of the current deep stub mock. * @return The mock */ private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) { MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock); return mockitoCore().mock( returnTypeGenericMetadata.rawType(), withSettingsUsing(returnTypeGenericMetadata, parentMockSettings) ); } private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) { MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ? withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) : withSettings(); return propagateSerializationSettings(mockSettings, parentMockSettings) .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); } private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) { return mockSettings.serializable(parentMockSettings.getSerializableMode()); } private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) { return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);'], ['', 'newDeepStubMock(returnTypeGenericMetadata),', 'private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) { withSettingsUsing(returnTypeGenericMetadata) private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) { return mockSettings.serializable()'], ['import org.mockito.mock.MockCreationSettings;', 'newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),', 'private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) { MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock); withSettingsUsing(returnTypeGenericMetadata, parentMockSettings) private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) { return propagateSerializationSettings(mockSettings, parentMockSettings) private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) { return mockSettings.serializable(parentMockSettings.getSerializableMode()); }'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java']
['Mockito-11', 1, 1, 1, 1, ['*/ @Override public boolean equals(Object o) { return method.equals(o); } @Override public int hashCode() { return 1; } } No newline at end of file'], ['*/ @Override public boolean equals(Object o) { if (this == o) { return true; } if (o instanceof DelegatingMethod) { DelegatingMethod that = (DelegatingMethod) o; return method.equals(that.method); } else { return method.equals(o); } } @Override public int hashCode() { return method.hashCode(); } } No newline at end of file'], ['return 1;'], ['if (this == o) { return true; } if (o instanceof DelegatingMethod) { DelegatingMethod that = (DelegatingMethod) o; return method.equals(that.method); } else { } return method.hashCode();'], 'a/src/org/mockito/internal/creation/DelegatingMethod.java', 'b/src/org/mockito/internal/creation/DelegatingMethod.java']
['Mockito-12', 1, 1, 1, 1, ["Type generic = field.getGenericType(); if (generic != null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (Class) actual; //in case of nested generics we don't go deep } return Object.class;"], ["Type generic = field.getGenericType(); if (generic != null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actual instanceof Class) { return (Class) actual; } else if (actual instanceof ParameterizedType) { //in case of nested generics we don't go deep return (Class) ((ParameterizedType) actual).getRawType(); } } return Object.class;"], [''], ['if (actual instanceof Class) { } else if (actual instanceof ParameterizedType) { return (Class) ((ParameterizedType) actual).getRawType(); }'], 'a/src/org/mockito/internal/util/reflection/GenericMaster.java', 'b/src/org/mockito/internal/util/reflection/GenericMaster.java']
['Mockito-13', 1, 1, 1, 1, ['if (verificationMode != null) { //We need to check if verification was started on the correct mock // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher); verificationMode.verify(data); return null; // this means there is an invocation on a different mock. Re-adding verification mode // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) } }'], ['if (verificationMode != null) { //We need to check if verification was started on the correct mock // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher); verificationMode.verify(data); return null; } else { // this means there is an invocation on a different mock. Re-adding verification mode // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) mockingProgress.verificationStarted(verificationMode); } }'], ['if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {'], ['if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { } else { mockingProgress.verificationStarted(verificationMode);'], 'a/src/org/mockito/internal/MockHandler.java', 'b/src/org/mockito/internal/MockHandler.java']
['Mockito-14', 4, 4, 4, 4, ['import org.mockito.internal.stubbing.OngoingStubbingImpl; import org.mockito.internal.stubbing.StubbedInvocationMatcher; import org.mockito.internal.stubbing.VoidMethodStubbableImpl; import org.mockito.internal.verification.VerificationDataImpl; import org.mockito.stubbing.Answer; import org.mockito.stubbing.VoidMethodStubbable;', 'if (verificationMode != null) { //We need to check if verification was started on the correct mock // - see VerifyingWithAnExtraCallToADifferentMockTest VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher); verificationMode.verify(data); return null; } invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);', 'import org.mockito.internal.stubbing.OngoingStubbingImpl; import org.mockito.internal.stubbing.StubberImpl; import org.mockito.internal.util.MockUtil; import org.mockito.internal.verification.VerificationDataImpl; import org.mockito.internal.verification.VerificationModeFactory; import org.mockito.internal.verification.api.InOrderContext;', '} else if (!mockUtil.isMock(mock)) { reporter.notAMockPassedToVerify(); } mockingProgress.verificationStarted(mode); return mock; }'], ['import org.mockito.internal.stubbing.OngoingStubbingImpl; import org.mockito.internal.stubbing.StubbedInvocationMatcher; import org.mockito.internal.stubbing.VoidMethodStubbableImpl; import org.mockito.internal.verification.MockAwareVerificationMode; import org.mockito.internal.verification.VerificationDataImpl; import org.mockito.stubbing.Answer; import org.mockito.stubbing.VoidMethodStubbable;', 'if (verificationMode != null) { //We need to check if verification was started on the correct mock // - see VerifyingWithAnExtraCallToADifferentMockTest if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher); verificationMode.verify(data); return null; } } invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);', 'import org.mockito.internal.stubbing.OngoingStubbingImpl; import org.mockito.internal.stubbing.StubberImpl; import org.mockito.internal.util.MockUtil; import org.mockito.internal.verification.MockAwareVerificationMode; import org.mockito.internal.verification.VerificationDataImpl; import org.mockito.internal.verification.VerificationModeFactory; import org.mockito.internal.verification.api.InOrderContext;', '} else if (!mockUtil.isMock(mock)) { reporter.notAMockPassedToVerify(); } mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode)); return mock; }'], ['', '', '', 'mockingProgress.verificationStarted(mode);'], ['import org.mockito.internal.verification.MockAwareVerificationMode;', 'if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { }', 'import org.mockito.internal.verification.MockAwareVerificationMode;', 'mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));'], 'a/src/org/mockito/internal/MockitoCore.java', 'b/src/org/mockito/internal/MockitoCore.java']
['Mockito-15', 2, 2, 2, 2, ['package org.mockito.internal.configuration.injection; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.reflection.FieldSetter; import java.lang.reflect.Field;', 'return new OngoingInjecter() { public boolean thenInject() { try { new FieldSetter(fieldInstance, field).set(matchingMock); } catch (Exception e) { throw new MockitoException("Problems injecting dependency in " + field.getName(), e); }'], ['package org.mockito.internal.configuration.injection; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.reflection.BeanPropertySetter; import org.mockito.internal.util.reflection.FieldSetter; import java.lang.reflect.Field;', 'return new OngoingInjecter() { public boolean thenInject() { try { if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) { new FieldSetter(fieldInstance, field).set(matchingMock); } } catch (Exception e) { throw new MockitoException("Problems injecting dependency in " + field.getName(), e); }'], ['', ''], ['import org.mockito.internal.util.reflection.BeanPropertySetter;', 'if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) { }'], 'a/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java', 'b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java']
['Mockito-16', 3, 3, 3, 3, ['* @return mock object */ public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) { return MOCKITO_CORE.mock(classToMock, mockSettings); } /**', 'public static <T> T spy(T object) { return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings() .spiedInstance(object) .defaultAnswer(CALLS_REAL_METHODS)); } /**', 'private final MockUtil mockUtil = new MockUtil(); private final MockingProgress mockingProgress = new ThreadSafeMockingProgress(); public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); } public <T> T mock(Class<T> classToMock, MockSettings mockSettings) { mockingProgress.validateState(); mockingProgress.resetOngoingStubbing(); return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings); }'], ['* @return mock object */ public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) { return MOCKITO_CORE.mock(classToMock, mockSettings, true); } /**', 'public static <T> T spy(T object) { return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings() .spiedInstance(object) .defaultAnswer(CALLS_REAL_METHODS), true); } /**', 'private final MockUtil mockUtil = new MockUtil(); private final MockingProgress mockingProgress = new ThreadSafeMockingProgress(); public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { mockingProgress.validateState(); if (shouldResetOngoingStubbing) { mockingProgress.resetOngoingStubbing(); } return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings); }'], ['return MOCKITO_CORE.mock(classToMock, mockSettings);', '.defaultAnswer(CALLS_REAL_METHODS));', 'public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); } public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {'], ['return MOCKITO_CORE.mock(classToMock, mockSettings, true);', '.defaultAnswer(CALLS_REAL_METHODS), true);', 'public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { if (shouldResetOngoingStubbing) { }'], 'a/src/org/mockito/internal/MockitoCore.java', 'b/src/org/mockito/internal/MockitoCore.java']
['Mockito-17', 4, 4, 4, 4, ['private Object spiedInstance; private Answer<Object> defaultAnswer; private MockName mockName; public MockSettings serializable() { return this.extraInterfaces(java.io.Serializable.class); } public MockSettings extraInterfaces(Class<?>... extraInterfaces) {', '} public boolean isSerializable() { return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class); } public void initiateMockName(Class classToMock) {', 'import org.mockito.internal.creation.jmock.ClassImposterizer; import org.mockito.internal.util.reflection.LenientCopyTool; @SuppressWarnings("unchecked") public class MockUtil {', 'Class<?>[] interfaces = settings.getExtraInterfaces(); Class<?>[] ancillaryTypes; ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces; Object spiedInstance = settings.getSpiedInstance();'], ['private Object spiedInstance; private Answer<Object> defaultAnswer; private MockName mockName; private boolean serializable; public MockSettings serializable() { this.serializable = true; return this; } public MockSettings extraInterfaces(Class<?>... extraInterfaces) {', '} public boolean isSerializable() { return serializable; } public void initiateMockName(Class classToMock) {', 'import org.mockito.internal.creation.jmock.ClassImposterizer; import org.mockito.internal.util.reflection.LenientCopyTool; import java.io.Serializable; @SuppressWarnings("unchecked") public class MockUtil {', 'Class<?>[] interfaces = settings.getExtraInterfaces(); Class<?>[] ancillaryTypes; if (settings.isSerializable()) { ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class); } else { ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces; } Object spiedInstance = settings.getSpiedInstance();'], ['return this.extraInterfaces(java.io.Serializable.class);', 'return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);', '', ''], ['private boolean serializable; this.serializable = true; return this;', 'return serializable;', 'import java.io.Serializable;', 'if (settings.isSerializable()) { ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class); } else { }'], 'a/src/org/mockito/internal/util/MockUtil.java', 'b/src/org/mockito/internal/util/MockUtil.java']
['Mockito-18', 1, 1, 1, 1, ['return Primitives.defaultValueForPrimitiveOrWrapper(type); //new instances are used instead of Collections.emptyList(), etc. //to avoid UnsupportedOperationException if code under test modifies returned collection } else if (type == Collection.class) { return new LinkedList<Object>(); } else if (type == Set.class) {'], ['return Primitives.defaultValueForPrimitiveOrWrapper(type); //new instances are used instead of Collections.emptyList(), etc. //to avoid UnsupportedOperationException if code under test modifies returned collection } else if (type == Iterable.class) { return new ArrayList<Object>(0); } else if (type == Collection.class) { return new LinkedList<Object>(); } else if (type == Set.class) {'], [''], ['} else if (type == Iterable.class) { return new ArrayList<Object>(0);'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java']
['Mockito-19', 9, 9, 9, 9, ['private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) { for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) { Field field = it.next(); Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject(); if (injected != null) { injectionOccurred |= true; mocks.remove(injected);', ' import java.lang.reflect.Field; import java.util.Collection; /** * This node returns an actual injecter which will be either :', '* </ul> */ public class FinalMockCandidateFilter implements MockCandidateFilter { public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) { if(mocks.size() == 1) { final Object matchingMock = mocks.iterator().next();', ' import java.lang.reflect.Field; import java.util.Collection; public interface MockCandidateFilter { OngoingInjecter filterCandidate( Collection<Object> mocks, Field fieldToBeInjected, Object fieldInstance ); }', '} public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) { List<Object> mockNameMatches = new ArrayList<Object>(); if (mocks.size() > 1) { for (Object mock : mocks) {', 'mockNameMatches.add(mock); } } return next.filterCandidate(mockNameMatches, field, fieldInstance); /* * In this case we have to check whether we have conflicting naming', '* whenever we find a field that does match its name with the mock * name, we should take that field instead. */ } return next.filterCandidate(mocks, field, fieldInstance); } }', 'this.next = next; } public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) { List<Object> mockTypeMatches = new ArrayList<Object>(); for (Object mock : mocks) { if (field.getType().isAssignableFrom(mock.getClass())) {', '} } return next.filterCandidate(mockTypeMatches, field, fieldInstance); } }'], ['private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) { for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) { Field field = it.next(); Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject(); if (injected != null) { injectionOccurred |= true; mocks.remove(injected);', ' import java.lang.reflect.Field; import java.util.Collection; import java.util.List; /** * This node returns an actual injecter which will be either :', '* </ul> */ public class FinalMockCandidateFilter implements MockCandidateFilter { public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) { if(mocks.size() == 1) { final Object matchingMock = mocks.iterator().next();', ' import java.lang.reflect.Field; import java.util.Collection; import java.util.List; public interface MockCandidateFilter { OngoingInjecter filterCandidate( Collection<Object> mocks, Field fieldToBeInjected, List<Field> fields, Object instance ); }', '} public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) { List<Object> mockNameMatches = new ArrayList<Object>(); if (mocks.size() > 1) { for (Object mock : mocks) {', 'mockNameMatches.add(mock); } } return next.filterCandidate(mockNameMatches, field, fields, fieldInstance); /* * In this case we have to check whether we have conflicting naming', '* whenever we find a field that does match its name with the mock * name, we should take that field instead. */ } else if (mocks.size() == 1) { String mockName = mockUtil.getMockName(mocks.iterator().next()) .toString(); for (Field otherField : fields) { if (!otherField.equals(field) && otherField.getType().equals(field.getType()) && otherField.getName().equals(mockName)) { return new OngoingInjecter() { public Object thenInject() { return null; } }; } } } return next.filterCandidate(mocks, field, fields, fieldInstance); } }', 'this.next = next; } public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) { List<Object> mockTypeMatches = new ArrayList<Object>(); for (Object mock : mocks) { if (field.getType().isAssignableFrom(mock.getClass())) {', '} } return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance); } }'], ['Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();', '', 'public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {', 'Object fieldInstance', 'Field field, Object fieldInstance) {', 'return next.filterCandidate(mockNameMatches, field,', 'return next.filterCandidate(mocks, field, fieldInstance);', 'public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {', 'return next.filterCandidate(mockTypeMatches, field, fieldInstance);'], ['Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();', 'import java.util.List;', 'public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {', 'import java.util.List; List<Field> fields, Object instance', 'Field field, List<Field> fields, Object fieldInstance) {', 'return next.filterCandidate(mockNameMatches, field, fields,', '} else if (mocks.size() == 1) { String mockName = mockUtil.getMockName(mocks.iterator().next()) .toString(); for (Field otherField : fields) { if (!otherField.equals(field) && otherField.getType().equals(field.getType()) && otherField.getName().equals(mockName)) { return new OngoingInjecter() { public Object thenInject() { return null; } }; } } return next.filterCandidate(mocks, field, fields, fieldInstance);', 'public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {', 'return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);'], 'a/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java', 'b/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java']
['Mockito-20', 2, 2, 2, 2, ['settings.getTypeToMock(), settings.getExtraInterfaces() ); T mockInstance = null; try { mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));', '" class to mock : " + describeClass(mockedProxyType), " created class : " + describeClass(settings.getTypeToMock()), " proxy instance class : " + describeClass(mockInstance), " instance creation by : " + classInstantiator.getClass().getSimpleName(), "", "You might experience classloading issues, please ask the mockito mailing-list.", ""'], ['settings.getTypeToMock(), settings.getExtraInterfaces() ); Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings); T mockInstance = null; try { mockInstance = instantiator.newInstance(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));', '" class to mock : " + describeClass(mockedProxyType), " created class : " + describeClass(settings.getTypeToMock()), " proxy instance class : " + describeClass(mockInstance), " instance creation by : " + instantiator.getClass().getSimpleName(), "", "You might experience classloading issues, please ask the mockito mailing-list.", ""'], ['mockInstance = classInstantiator.instantiate(mockedProxyType);', '" instance creation by : " + classInstantiator.getClass().getSimpleName(),'], ['Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings); mockInstance = instantiator.newInstance(mockedProxyType);', '" instance creation by : " + instantiator.getClass().getSimpleName(),'], 'a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java', 'b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java']
['Mockito-21', 2, 2, 2, 2, ["if (outerClassInstance == null) { return noArgConstructor(cls); } return withOuterClass(cls); } private <T> T withOuterClass(Class<T> cls) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance); } catch (Exception e) { throw paramsException(cls, e); } } private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", '+ cls.getSimpleName() + "\'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.", e); } private static <T> T noArgConstructor(Class<T> cls) { try {'], ["if (outerClassInstance == null) { return noArgConstructor(cls); } return withParams(cls, outerClassInstance); } private static <T> T withParams(Class<T> cls, Object... params) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) for (Constructor<?> constructor : cls.getDeclaredConstructors()) { Class<?>[] types = constructor.getParameterTypes(); if (paramsMatch(types, params)) { return (T) constructor.newInstance(params); } } } catch (Exception e) { throw paramsException(cls, e); } throw paramsException(cls, null); } private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", '+ cls.getSimpleName() + "\'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.", e); } private static boolean paramsMatch(Class<?>[] types, Object[] params) { if (params.length != types.length) { return false; } for (int i = 0; i < params.length; i++) { if (!types[i].isInstance(params[i])) { return false; } } return true; } private static <T> T noArgConstructor(Class<T> cls) { try {'], ['return withOuterClass(cls); private <T> T withOuterClass(Class<T> cls) { Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance);', ''], ['return withParams(cls, outerClassInstance); private static <T> T withParams(Class<T> cls, Object... params) { for (Constructor<?> constructor : cls.getDeclaredConstructors()) { Class<?>[] types = constructor.getParameterTypes(); if (paramsMatch(types, params)) { return (T) constructor.newInstance(params); } } throw paramsException(cls, null);', 'private static boolean paramsMatch(Class<?>[] types, Object[] params) { if (params.length != types.length) { return false; } for (int i = 0; i < params.length; i++) { if (!types[i].isInstance(params[i])) { return false; } } return true; }'], 'a/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java', 'b/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java']
['Mockito-22', 1, 1, 1, 1, ['public class Equality { public static boolean areEqual(Object o1, Object o2) { if (o1 == null || o2 == null) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2);'], ['public class Equality { public static boolean areEqual(Object o1, Object o2) { if (o1 == o2 ) { return true; } else if (o1 == null || o2 == null) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2);'], ['if (o1 == null || o2 == null) {'], ['if (o1 == o2 ) { return true; } else if (o1 == null || o2 == null) {'], 'a/src/org/mockito/internal/matchers/Equality.java', 'b/src/org/mockito/internal/matchers/Equality.java']
['Mockito-23', 5, 5, 5, 5, [' private static final long serialVersionUID = -7105341425736035847L; private MockitoCore mockitoCore = new MockitoCore(); private ReturnsEmptyValues delegate = new ReturnsEmptyValues(); public Object answer(InvocationOnMock invocation) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod()); Class<?> rawType = returnTypeGenericMetadata.rawType(); if (!mockitoCore.isTypeMockable(rawType)) { return delegate.returnValueFor(rawType); }', 'return getMock(invocation, returnTypeGenericMetadata); } private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable { InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());', ': withSettings(); return mockSettings .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); }', ' private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable { container.addAnswer(new Answer<Object>() { public Object answer(InvocationOnMock invocation) throws Throwable { return mock; }', 'return mock; } protected GenericMetadataSupport actualParameterizedType(Object mock) {'], [' private static final long serialVersionUID = -7105341425736035847L; private transient MockitoCore mockitoCore; private transient ReturnsEmptyValues delegate; public Object answer(InvocationOnMock invocation) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod()); Class<?> rawType = returnTypeGenericMetadata.rawType(); instantiateMockitoCoreIfNeeded(); instantiateDelegateIfNeeded(); if (!mockitoCore.isTypeMockable(rawType)) { return delegate.returnValueFor(rawType); }', 'return getMock(invocation, returnTypeGenericMetadata); } private synchronized void instantiateMockitoCoreIfNeeded() { if (mockitoCore == null) { mockitoCore = new MockitoCore(); } } private synchronized void instantiateDelegateIfNeeded() { if (delegate == null) { delegate = new ReturnsEmptyValues(); } } private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable { InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());', ': withSettings(); return mockSettings .serializable() .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); }', ' private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable { container.addAnswer(new SerializableAnswer() { public Object answer(InvocationOnMock invocation) throws Throwable { return mock; }', 'return mock; } abstract class SerializableAnswer implements Answer<Object>, Serializable { } protected GenericMetadataSupport actualParameterizedType(Object mock) {'], ['private MockitoCore mockitoCore = new MockitoCore(); private ReturnsEmptyValues delegate = new ReturnsEmptyValues();', '', '', 'container.addAnswer(new Answer<Object>() {', ''], ['private transient MockitoCore mockitoCore; private transient ReturnsEmptyValues delegate; instantiateMockitoCoreIfNeeded(); instantiateDelegateIfNeeded();', 'private synchronized void instantiateMockitoCoreIfNeeded() { if (mockitoCore == null) { mockitoCore = new MockitoCore(); } } private synchronized void instantiateDelegateIfNeeded() { if (delegate == null) { delegate = new ReturnsEmptyValues(); } }', '.serializable()', 'container.addAnswer(new SerializableAnswer() {', 'abstract class SerializableAnswer implements Answer<Object>, Serializable { }'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java']
['Mockito-24', 1, 1, 1, 1, ['//see issue 184. //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good). //Only for compareTo() method by the Comparable interface return 1; } Class<?> returnType = invocation.getMethod().getReturnType();'], ['//see issue 184. //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good). //Only for compareTo() method by the Comparable interface return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1; } Class<?> returnType = invocation.getMethod().getReturnType();'], ['return 1;'], ['return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java']
['Mockito-25', 5, 5, 5, 5, ['*/ package org.mockito.internal.stubbing.defaultanswers; import org.mockito.internal.InternalMockHandler; import org.mockito.internal.creation.settings.CreationSettings; import org.mockito.internal.stubbing.InvocationContainerImpl;', ' import java.io.Serializable; /** * Returning deep stub implementation.', 'return delegate.returnValueFor(rawType); } return getMock(invocation); } private Object getMock(InvocationOnMock invocation) throws Throwable { InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock()); InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();', '} // deep stub return recordDeepStubMock(invocation, container); } /**', '* @param returnTypeGenericMetadata The metadata to use to create the new mock. * @return The mock */ private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) { Class<?> clz = invocation.getMethod().getReturnType(); final Object mock = org.mockito.Mockito.mock(clz, this); container.addAnswer(new Answer<Object>() { public Object answer(InvocationOnMock invocation) throws Throwable {'], ['*/ package org.mockito.internal.stubbing.defaultanswers; import org.mockito.MockSettings; import org.mockito.internal.InternalMockHandler; import org.mockito.internal.creation.settings.CreationSettings; import org.mockito.internal.stubbing.InvocationContainerImpl;', ' import java.io.Serializable; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.withSettings; /** * Returning deep stub implementation.', 'return delegate.returnValueFor(rawType); } return getMock(invocation, returnTypeGenericMetadata); } private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable { InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock()); InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();', '} // deep stub return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container); } /**', '* @param returnTypeGenericMetadata The metadata to use to create the new mock. * @return The mock */ private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) { return mock( returnTypeGenericMetadata.rawType(), withSettingsUsing(returnTypeGenericMetadata) ); } private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) { MockSettings mockSettings = returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ? withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) : withSettings(); return mockSettings .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); } private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) { return new ReturnsDeepStubs() { @Override protected GenericMetadataSupport actualParameterizedType(Object mock) { return returnTypeGenericMetadata; } }; } private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable { container.addAnswer(new Answer<Object>() { public Object answer(InvocationOnMock invocation) throws Throwable {'], ['', '', 'return getMock(invocation); private Object getMock(InvocationOnMock invocation) throws Throwable {', 'return recordDeepStubMock(invocation, container);', 'private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) { Class<?> clz = invocation.getMethod().getReturnType(); final Object mock = org.mockito.Mockito.mock(clz, this);'], ['import org.mockito.MockSettings;', 'import static org.mockito.Mockito.mock; import static org.mockito.Mockito.withSettings;', 'return getMock(invocation, returnTypeGenericMetadata); private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {', 'return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);', 'private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) { return mock( returnTypeGenericMetadata.rawType(), withSettingsUsing(returnTypeGenericMetadata) ); } private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) { MockSettings mockSettings = returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ? withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces()) : withSettings(); return mockSettings .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata)); } private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) { return new ReturnsDeepStubs() { @Override protected GenericMetadataSupport actualParameterizedType(Object mock) { return returnTypeGenericMetadata; } }; } private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java']
['Mockito-26', 1, 1, 1, 1, ['primitiveValues.put(int.class, 0); primitiveValues.put(long.class, 0L); primitiveValues.put(float.class, 0F); primitiveValues.put(double.class, 0); } } No newline at end of file'], ['primitiveValues.put(int.class, 0); primitiveValues.put(long.class, 0L); primitiveValues.put(float.class, 0F); primitiveValues.put(double.class, 0D); } } No newline at end of file'], ['primitiveValues.put(double.class, 0);'], ['primitiveValues.put(double.class, 0D);'], 'a/src/org/mockito/internal/util/Primitives.java', 'b/src/org/mockito/internal/util/Primitives.java']
['Mockito-27', 1, 1, 1, 1, [' public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); ((Factory) mock).setCallback(0, newFilter); }'], [' public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings()); ((Factory) mock).setCallback(0, newFilter); }'], ['MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));'], ['MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());'], 'a/src/org/mockito/internal/util/MockUtil.java', 'b/src/org/mockito/internal/util/MockUtil.java']
['Mockito-28', 1, 1, 1, 1, [' private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); } }'], [' private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); mocks.remove(injected); } }'], ['mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();'], ['Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); mocks.remove(injected);'], 'a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java', 'b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java']
['Mockito-29', 1, 1, 1, 1, ['public void describeTo(Description description) { description.appendText("same("); appendQuoting(description); description.appendText(wanted.toString()); appendQuoting(description); description.appendText(")"); }'], ['public void describeTo(Description description) { description.appendText("same("); appendQuoting(description); description.appendText(wanted == null ? "null" : wanted.toString()); appendQuoting(description); description.appendText(")"); }'], ['description.appendText(wanted.toString());'], ['description.appendText(wanted == null ? "null" : wanted.toString());'], 'a/src/org/mockito/internal/matchers/Same.java', 'b/src/org/mockito/internal/matchers/Same.java']
['Mockito-30', 2, 2, 2, 2, [')); } public void smartNullPointerException(Location location) { throw new SmartNullPointerException(join( "You have a NullPointerException here:", new Location(), "Because this method was *not* stubbed correctly:", location, ""', 'return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock"; } new Reporter().smartNullPointerException(location); return null; }'], [')); } public void smartNullPointerException(Object obj, Location location) { throw new SmartNullPointerException(join( "You have a NullPointerException here:", new Location(), obj, "Because this method was *not* stubbed correctly:", location, ""', 'return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock"; } new Reporter().smartNullPointerException(obj, location); return null; }'], ['public void smartNullPointerException(Location location) {', 'new Reporter().smartNullPointerException(location);'], ['public void smartNullPointerException(Object obj, Location location) { obj,', 'new Reporter().smartNullPointerException(obj, location);'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java']
['Mockito-31', 2, 2, 2, 2, [' import java.io.Serializable; import java.lang.reflect.Method; import org.mockito.Mockito; import org.mockito.cglib.proxy.MethodInterceptor;', '} private String formatMethodCall() { return invocation.getMethod().getName() + "()"; } }'], [' import java.io.Serializable; import java.lang.reflect.Method; import java.util.Arrays; import org.mockito.Mockito; import org.mockito.cglib.proxy.MethodInterceptor;', '} private String formatMethodCall() { String args = Arrays.toString(invocation.getArguments()); return invocation.getMethod().getName() + "(" + args.substring(1, args.length() - 1) +\t")"; } }'], ['', 'return invocation.getMethod().getName() + "()";'], ['import java.util.Arrays;', 'String args = Arrays.toString(invocation.getArguments()); return invocation.getMethod().getName() + "(" + args.substring(1, args.length() - 1) +\t")";'], 'a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java', 'b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java']
['Mockito-32', 2, 2, 2, 2, ['import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.MockUtil; @SuppressWarnings({"unchecked"}) public class SpyAnnotationEngine implements AnnotationEngine {', '// instance has been spied earlier Mockito.reset(instance); } else { field.set(testClass, Mockito.spy(instance)); } } catch (IllegalAccessException e) { throw new MockitoException("Problems initiating spied field " + field.getName(), e);'], ['import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.MockUtil; import static org.mockito.Mockito.withSettings; @SuppressWarnings({"unchecked"}) public class SpyAnnotationEngine implements AnnotationEngine {', '// instance has been spied earlier Mockito.reset(instance); } else { field.set(testClass, Mockito.mock(instance.getClass(), withSettings() .spiedInstance(instance) .defaultAnswer(Mockito.CALLS_REAL_METHODS) .name(field.getName()))); } } catch (IllegalAccessException e) { throw new MockitoException("Problems initiating spied field " + field.getName(), e);'], ['', 'field.set(testClass, Mockito.spy(instance));'], ['import static org.mockito.Mockito.withSettings;', 'field.set(testClass, Mockito.mock(instance.getClass(), withSettings() .spiedInstance(instance) .defaultAnswer(Mockito.CALLS_REAL_METHODS) .name(field.getName())));'], 'a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java', 'b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java']
['Mockito-33', 1, 1, 1, 1, ['Method m1 = invocation.getMethod(); Method m2 = candidate.getMethod(); /* Avoid unnecessary cloning */ return m1.equals(m2); } public Location getLocation() {'], ['Method m1 = invocation.getMethod(); Method m2 = candidate.getMethod(); if (m1.getName() != null && m1.getName().equals(m2.getName())) { /* Avoid unnecessary cloning */ Class[] params1 = m1.getParameterTypes(); Class[] params2 = m2.getParameterTypes(); if (params1.length == params2.length) { for (int i = 0; i < params1.length; i++) { if (params1[i] != params2[i]) return false; } return true; } } return false; } public Location getLocation() {'], ['return m1.equals(m2);'], ['if (m1.getName() != null && m1.getName().equals(m2.getName())) { Class[] params1 = m1.getParameterTypes(); Class[] params2 = m2.getParameterTypes(); if (params1.length == params2.length) { for (int i = 0; i < params1.length; i++) { if (params1[i] != params2[i]) return false; } return true; } } return false;'], 'a/src/org/mockito/internal/invocation/InvocationMatcher.java', 'b/src/org/mockito/internal/invocation/InvocationMatcher.java']
['Mockito-34', 1, 1, 1, 1, ['public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++;'], ['public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { if (m instanceof CapturesArguments && i.getArguments().length > k) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++;'], ['if (m instanceof CapturesArguments) {'], ['if (m instanceof CapturesArguments && i.getArguments().length > k) {'], 'a/src/org/mockito/internal/invocation/InvocationMatcher.java', 'b/src/org/mockito/internal/invocation/InvocationMatcher.java']
['Mockito-35', 3, 3, 3, 3, ['* @return <code>null</code>. */ public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull(); } /**', '* @return <code>null</code>. */ public static <T> T eq(T value) { return reportMatcher(new Equals(value)).<T>returnNull(); } /**', '* @return <code>null</code>. */ public static <T> T same(T value) { return reportMatcher(new Same(value)).<T>returnNull(); } /**'], ['* @return <code>null</code>. */ public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz); } /**', '* @return <code>null</code>. */ public static <T> T eq(T value) { return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass()); } /**', '* @return <code>null</code>. */ public static <T> T same(T value) { return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass()); } /**'], ['return reportMatcher(new InstanceOf(clazz)).<T>returnNull();', 'return reportMatcher(new Equals(value)).<T>returnNull();', 'return reportMatcher(new Same(value)).<T>returnNull();'], ['return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);', 'return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());', 'return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());'], 'a/src/org/mockito/Matchers.java', 'b/src/org/mockito/Matchers.java']
['Mockito-36', 2, 2, 2, 2, [' import org.hamcrest.Matcher; import org.mockito.exceptions.PrintableInvocation; import org.mockito.internal.debugging.Location; import org.mockito.internal.invocation.realmethod.RealMethod; import org.mockito.internal.matchers.*;', '} public Object callRealMethod() throws Throwable { return realMethod.invoke(mock, rawArguments); }'], [' import org.hamcrest.Matcher; import org.mockito.exceptions.PrintableInvocation; import org.mockito.exceptions.Reporter; import org.mockito.internal.debugging.Location; import org.mockito.internal.invocation.realmethod.RealMethod; import org.mockito.internal.matchers.*;', '} public Object callRealMethod() throws Throwable { if (this.getMethod().getDeclaringClass().isInterface()) { new Reporter().cannotCallRealMethodOnInterface(); } return realMethod.invoke(mock, rawArguments); }'], ['', ''], ['import org.mockito.exceptions.Reporter;', 'if (this.getMethod().getDeclaringClass().isInterface()) { new Reporter().cannotCallRealMethodOnInterface(); }'], 'a/src/org/mockito/internal/invocation/Invocation.java', 'b/src/org/mockito/internal/invocation/Invocation.java']
['Mockito-37', 1, 1, 1, 1, ['validateDoNothing((DoesNothing) answer, invocation); } } private void validateDoNothing(DoesNothing answer, Invocation invocation) { if (!invocation.isVoid()) {'], ['validateDoNothing((DoesNothing) answer, invocation); } if (answer instanceof CallsRealMethods) { validateMockingConcreteClass((CallsRealMethods) answer, invocation); } } private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) { if (invocation.getMethod().getDeclaringClass().isInterface()) { reporter.cannotCallRealMethodOnInterface(); } } private void validateDoNothing(DoesNothing answer, Invocation invocation) { if (!invocation.isVoid()) {'], [''], ['if (answer instanceof CallsRealMethods) { validateMockingConcreteClass((CallsRealMethods) answer, invocation); } private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) { if (invocation.getMethod().getDeclaringClass().isInterface()) { reporter.cannotCallRealMethodOnInterface(); } }'], 'a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java', 'b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java']
['Mockito-38', 1, 1, 1, 1, ['} private boolean toStringEquals(Matcher m, Object arg) { return StringDescription.toString(m).equals(arg.toString()); } }'], ['} private boolean toStringEquals(Matcher m, Object arg) { return StringDescription.toString(m).equals(arg == null? "null" : arg.toString()); } }'], ['return StringDescription.toString(m).equals(arg.toString());'], ['return StringDescription.toString(m).equals(arg == null? "null" : arg.toString());'], 'a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java', 'b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java']
['Collections-1', 2, 2, 2, 2, ['switch (nextIndex) { case 3: parent.value3 = value; case 2: parent.value2 = value; case 1: parent.value1 = value; } return old; }', 'switch (nextIndex) { case 3: parent.value3 = value; case 2: parent.value2 = value; case 1: parent.value1 = value; } return old; }'], ['switch (nextIndex) { case 3: parent.value3 = value; break; case 2: parent.value2 = value; break; case 1: parent.value1 = value; break; } return old; }', 'switch (nextIndex) { case 3: parent.value3 = value; break; case 2: parent.value2 = value; break; case 1: parent.value1 = value; break; } return old; }'], ['', ''], ['break; break; break;', 'break; break; break;'], 'a/src/java/org/apache/commons/collections/map/Flat3Map.java', 'b/src/java/org/apache/commons/collections/map/Flat3Map.java']
['Collections-2', 5, 5, 5, 5, ['* This is the name of the property that can point to other * properties file for including other properties files. */ /** * This is the default name of the property that can point to other', '* @return the property name which includes another property */ public String getInclude() { return include; // backwards compatability } /**', '* @param inc the property name which includes another property, empty converted to null */ public void setInclude(String inc) { include = inc; } /**', '} try { while (true) { String line = reader.readProperty(); if (line == null) {', 'continue; } if (getInclude() != null && key.equalsIgnoreCase(getInclude())) { // Recursively load properties files. File file = null;'], ['* This is the name of the property that can point to other * properties file for including other properties files. */ private String includePropertyName = null; /** * This is the default name of the property that can point to other', '* @return the property name which includes another property */ public String getInclude() { if (includePropertyName == null) { return include; // backwards compatability } if ("".equals(includePropertyName)) { return null; // hack to allow backwards compatability } return includePropertyName; } /**', '* @param inc the property name which includes another property, empty converted to null */ public void setInclude(String inc) { if (inc == null) { inc = ""; // hack to allow backwards compatability } includePropertyName = inc; } /**', '} try { String includeProperty = getInclude(); while (true) { String line = reader.readProperty(); if (line == null) {', 'continue; } if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) { // Recursively load properties files. File file = null;'], ['', '', 'include = inc;', '', 'if (getInclude() != null && key.equalsIgnoreCase(getInclude())) {'], ['private String includePropertyName = null;', 'if (includePropertyName == null) { } if ("".equals(includePropertyName)) { return null; // hack to allow backwards compatability } return includePropertyName;', 'if (inc == null) { inc = ""; // hack to allow backwards compatability } includePropertyName = inc;', 'String includeProperty = getInclude();', 'if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-3', 1, 1, 1, 1, ['* @since Commons Collections 3.3 (method existed in 3.2 but was completely broken) */ public static Collection removeAll(Collection collection, Collection remove) { return ListUtils.retainAll(collection, remove); } //-----------------------------------------------------------------------'], ['* @since Commons Collections 3.3 (method existed in 3.2 but was completely broken) */ public static Collection removeAll(Collection collection, Collection remove) { return ListUtils.removeAll(collection, remove); } //-----------------------------------------------------------------------'], ['return ListUtils.retainAll(collection, remove);'], ['return ListUtils.removeAll(collection, remove);'], 'a/src/java/org/apache/commons/collections/CollectionUtils.java', 'b/src/java/org/apache/commons/collections/CollectionUtils.java']
['Collections-4', 2, 2, 2, 2, ['Collection coll = getCollection(key); if (coll == null) { coll = createCollection(1); // might produce a non-empty collection result = coll.add(value); if (coll.size() > 0) { // only add if non-zero size to maintain class state getMap().put(key, coll); result = false; } } else { result = coll.add(value);', 'if (values == null || values.size() == 0) { return false; } Collection coll = getCollection(key); if (coll == null) { coll = createCollection(values.size()); // might produce a non-empty collection boolean result = coll.addAll(values); if (coll.size() > 0) { // only add if non-zero size to maintain class state getMap().put(key, coll); result = false; } return result; } else { return coll.addAll(values); } } /**'], ['Collection coll = getCollection(key); if (coll == null) { coll = createCollection(1); // might produce a non-empty collection coll.add(value); if (coll.size() > 0) { // only add if non-zero size to maintain class state getMap().put(key, coll); result = true; // map definitely changed } } else { result = coll.add(value);', 'if (values == null || values.size() == 0) { return false; } boolean result = false; Collection coll = getCollection(key); if (coll == null) { coll = createCollection(values.size()); // might produce a non-empty collection coll.addAll(values); if (coll.size() > 0) { // only add if non-zero size to maintain class state getMap().put(key, coll); result = true; // map definitely changed } } else { result = coll.addAll(values); } return result; } /**'], ['result = coll.add(value); result = false;', 'boolean result = coll.addAll(values); result = false; return result; return coll.addAll(values);'], ['coll.add(value); result = true; // map definitely changed', 'boolean result = false; coll.addAll(values); result = true; // map definitely changed result = coll.addAll(values); return result;'], 'a/src/java/org/apache/commons/collections/map/MultiValueMap.java', 'b/src/java/org/apache/commons/collections/map/MultiValueMap.java']
['Collections-5', 1, 1, 1, 1, [' // adds all elements for (final Iterator it = coll.iterator(); it.hasNext();) { add(it.next()); // if it was inserted, then increase the target index } // compares sizes to detect if collection changed'], [' // adds all elements for (final Iterator it = coll.iterator(); it.hasNext();) { int sizeBeforeAddNext = size(); add(index, it.next()); // if it was inserted, then increase the target index if (sizeBeforeAddNext != size()) { index++; } } // compares sizes to detect if collection changed'], ['add(it.next());'], ['int sizeBeforeAddNext = size(); add(index, it.next()); if (sizeBeforeAddNext != size()) { index++; }'], 'a/src/java/org/apache/commons/collections/list/SetUniqueList.java', 'b/src/java/org/apache/commons/collections/list/SetUniqueList.java']
['Collections-6', 6, 6, 6, 6, ['return old; } if (key2 == null) { Object old = value3; hash2 = hash3; key2 = key3; value2 = value3;', 'return old; } if (key1 == null) { Object old = value3; hash1 = hash3; key1 = key3; value1 = value3;', 'return old; } if (key1 == null) { Object old = value2; hash1 = hash2; key1 = key2; value1 = value2;', 'return old; } if (hash2 == hashCode && key.equals(key2)) { Object old = value3; hash2 = hash3; key2 = key3; value2 = value3;', 'return old; } if (hash1 == hashCode && key.equals(key1)) { Object old = value3; hash1 = hash3; key1 = key3; value1 = value3;', 'return old; } if (hash1 == hashCode && key.equals(key1)) { Object old = value2; hash1 = hash2; key1 = key2; value1 = value2;'], ['return old; } if (key2 == null) { Object old = value2; hash2 = hash3; key2 = key3; value2 = value3;', 'return old; } if (key1 == null) { Object old = value1; hash1 = hash3; key1 = key3; value1 = value3;', 'return old; } if (key1 == null) { Object old = value1; hash1 = hash2; key1 = key2; value1 = value2;', 'return old; } if (hash2 == hashCode && key.equals(key2)) { Object old = value2; hash2 = hash3; key2 = key3; value2 = value3;', 'return old; } if (hash1 == hashCode && key.equals(key1)) { Object old = value1; hash1 = hash3; key1 = key3; value1 = value3;', 'return old; } if (hash1 == hashCode && key.equals(key1)) { Object old = value1; hash1 = hash2; key1 = key2; value1 = value2;'], ['Object old = value3;', 'Object old = value3;', 'Object old = value2;', 'Object old = value3;', 'Object old = value3;', 'Object old = value2;'], ['Object old = value2;', 'Object old = value1;', 'Object old = value1;', 'Object old = value2;', 'Object old = value1;', 'Object old = value1;'], 'a/src/java/org/apache/commons/collections/map/Flat3Map.java', 'b/src/java/org/apache/commons/collections/map/Flat3Map.java']
['Collections-7', 16, 16, 16, 16, ["*/ public Object getProperty(String key) { // first, try to get from the 'user value' store Object obj = this.get(key); if (obj == null) { // if there isn't a value there, get it from the", 'if (!containsKey(key)) { keysAsListed.add(key); } put(key, value); } /**', 'List values = new Vector(2); values.add(current); values.add(value); put(key, values); } else if (current instanceof List) { // already a list - just add the new token', 'if (!containsKey(key)) { keysAsListed.add(key); } put(key, value); } }', 'break; } } remove(key); } }', '} else if (value instanceof String) { Vector values = new Vector(1); values.add(value); put(key, values); return values; } else if (value == null) {', '} else if (value instanceof String) { List values = new ArrayList(1); values.add(value); put(key, values); return values; } else if (value == null) {', '} else if (value instanceof String) { String s = testBoolean((String) value); Boolean b = new Boolean(s); put(key, b); return b; } else if (value == null) {', ' } else if (value instanceof String) { Byte b = new Byte((String) value); put(key, b); return b; } else if (value == null) {', ' } else if (value instanceof String) { Short s = new Short((String) value); put(key, s); return s; } else if (value == null) {', ' } else if (value instanceof String) { Integer i = new Integer((String) value); put(key, i); return i; } else if (value == null) {', ' } else if (value instanceof String) { Long l = new Long((String) value); put(key, l); return l; } else if (value == null) {', ' } else if (value instanceof String) { Float f = new Float((String) value); put(key, f); return f; } else if (value == null) {', ' } else if (value instanceof String) { Double d = new Double((String) value); put(key, d); return d; } else if (value == null) {', '* @param value for the property * @return old value of the property */ /** * Add a map full of key/value pairs to the ExtendedProperties.', '* @param key specifying the property * @return old value of the property */ }'], ["*/ public Object getProperty(String key) { // first, try to get from the 'user value' store Object obj = super.get(key); if (obj == null) { // if there isn't a value there, get it from the", 'if (!containsKey(key)) { keysAsListed.add(key); } super.put(key, value); } /**', 'List values = new Vector(2); values.add(current); values.add(value); super.put(key, values); } else if (current instanceof List) { // already a list - just add the new token', 'if (!containsKey(key)) { keysAsListed.add(key); } super.put(key, value); } }', 'break; } } super.remove(key); } }', '} else if (value instanceof String) { Vector values = new Vector(1); values.add(value); super.put(key, values); return values; } else if (value == null) {', '} else if (value instanceof String) { List values = new ArrayList(1); values.add(value); super.put(key, values); return values; } else if (value == null) {', '} else if (value instanceof String) { String s = testBoolean((String) value); Boolean b = new Boolean(s); super.put(key, b); return b; } else if (value == null) {', ' } else if (value instanceof String) { Byte b = new Byte((String) value); super.put(key, b); return b; } else if (value == null) {', ' } else if (value instanceof String) { Short s = new Short((String) value); super.put(key, s); return s; } else if (value == null) {', ' } else if (value instanceof String) { Integer i = new Integer((String) value); super.put(key, i); return i; } else if (value == null) {', ' } else if (value instanceof String) { Long l = new Long((String) value); super.put(key, l); return l; } else if (value == null) {', ' } else if (value instanceof String) { Float f = new Float((String) value); super.put(key, f); return f; } else if (value == null) {', ' } else if (value instanceof String) { Double d = new Double((String) value); super.put(key, d); return d; } else if (value == null) {', '* @param value for the property * @return old value of the property */ public Object put(Object key, Object value) { String strKey = String.valueOf(key); Object ret = getProperty(strKey); addProperty(strKey, value); return ret; } /** * Add a map full of key/value pairs to the ExtendedProperties.', '* @param key specifying the property * @return old value of the property */ public Object remove(Object key) { String strKey = String.valueOf(key); Object ret = getProperty(strKey); clearProperty(strKey); return ret; } }'], ['Object obj = this.get(key);', 'put(key, value);', 'put(key, values);', 'put(key, value);', 'remove(key);', 'put(key, values);', 'put(key, values);', 'put(key, b);', 'put(key, b);', 'put(key, s);', 'put(key, i);', 'put(key, l);', 'put(key, f);', 'put(key, d);', '', ''], ['Object obj = super.get(key);', 'super.put(key, value);', 'super.put(key, values);', 'super.put(key, value);', 'super.remove(key);', 'super.put(key, values);', 'super.put(key, values);', 'super.put(key, b);', 'super.put(key, b);', 'super.put(key, s);', 'super.put(key, i);', 'super.put(key, l);', 'super.put(key, f);', 'super.put(key, d);', 'public Object put(Object key, Object value) { String strKey = String.valueOf(key); Object ret = getProperty(strKey); addProperty(strKey, value); return ret; }', 'public Object remove(Object key) { String strKey = String.valueOf(key); Object ret = getProperty(strKey); clearProperty(strKey); return ret; }'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-8', 2, 2, 2, 2, ['private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeInt(size()); for (Iterator it = iterator(); it.hasNext();) { out.writeObject(it.next()); }', 'private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); int size = in.readInt(); buffer = new Object[size + 1]; for (int i = 0; i < size; i++) { buffer[i] = in.readObject(); }'], ['private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeInt(size()); out.writeInt(buffer.length); for (Iterator it = iterator(); it.hasNext();) { out.writeObject(it.next()); }', 'private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); int size = in.readInt(); int length = in.readInt(); buffer = new Object[length]; for (int i = 0; i < size; i++) { buffer[i] = in.readObject(); }'], ['', 'buffer = new Object[size + 1];'], ['out.writeInt(buffer.length);', 'int length = in.readInt(); buffer = new Object[length];'], 'a/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java', 'b/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java']
['Collections-9', 1, 1, 1, 1, ['public void combine(ExtendedProperties props) { for (Iterator it = props.getKeys(); it.hasNext();) { String key = (String) it.next(); setProperty(key, props.get(key)); } }'], ['public void combine(ExtendedProperties props) { for (Iterator it = props.getKeys(); it.hasNext();) { String key = (String) it.next(); super.put(key, props.get(key)); } }'], ['setProperty(key, props.get(key));'], ['super.put(key, props.get(key));'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-10', 2, 2, 2, 2, ['* @version $Revision$ $Date$ * @since Commons Collections 3.2 */ public class MultiValueMap extends AbstractMapDecorator implements MultiMap { /** Serialization version */ /** The factory for creating value collections. */ private final Factory collectionFactory;', '/** * Inner class that provides a simple reflection factory. */ private static class ReflectionFactory implements Factory { private final Class clazz; public ReflectionFactory(Class clazz) {'], ['* @version $Revision$ $Date$ * @since Commons Collections 3.2 */ public class MultiValueMap extends AbstractMapDecorator implements MultiMap, Serializable { /** Serialization version */ private static final long serialVersionUID = -2214159910087182007L; /** The factory for creating value collections. */ private final Factory collectionFactory;', '/** * Inner class that provides a simple reflection factory. */ private static class ReflectionFactory implements Factory, Serializable { private final Class clazz; public ReflectionFactory(Class clazz) {'], ['public class MultiValueMap extends AbstractMapDecorator implements MultiMap {', 'private static class ReflectionFactory implements Factory {'], ['public class MultiValueMap extends AbstractMapDecorator implements MultiMap, Serializable { private static final long serialVersionUID = -2214159910087182007L;', 'private static class ReflectionFactory implements Factory, Serializable {'], 'a/src/java/org/apache/commons/collections/map/MultiValueMap.java', 'b/src/java/org/apache/commons/collections/map/MultiValueMap.java']
['Collections-11', 1, 1, 1, 1, ['* only stable for the same process). * @return the instance with recalculated hash code */ }'], ['* only stable for the same process). * @return the instance with recalculated hash code */ private Object readResolve() { calculateHashCode(keys); return this; } }'], [''], ['private Object readResolve() { calculateHashCode(keys); return this; }'], 'a/src/java/org/apache/commons/collections/keyvalue/MultiKey.java', 'b/src/java/org/apache/commons/collections/keyvalue/MultiKey.java']
['Collections-12', 1, 1, 1, 1, ['public void combine(ExtendedProperties props) { for (Iterator it = props.getKeys(); it.hasNext();) { String key = (String) it.next(); super.put(key, props.get(key)); } }'], ['public void combine(ExtendedProperties props) { for (Iterator it = props.getKeys(); it.hasNext();) { String key = (String) it.next(); clearProperty(key); addPropertyDirect(key, props.get(key)); } }'], ['super.put(key, props.get(key));'], ['clearProperty(key); addPropertyDirect(key, props.get(key));'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-13', 1, 1, 1, 1, [' for (Enumeration e = props.propertyNames(); e.hasMoreElements();) { String s = (String) e.nextElement(); c.setProperty(s, props.getProperty(s)); } return c;'], [' for (Enumeration e = props.propertyNames(); e.hasMoreElements();) { String s = (String) e.nextElement(); String value = props.getProperty(s); if(value != null) { c.setProperty(s, value); } } return c;'], ['c.setProperty(s, props.getProperty(s));'], ['String value = props.getProperty(s); if(value != null) { c.setProperty(s, value); }'], 'a/src/java/org/apache/commons/collections/ExtendedProperties.java', 'b/src/java/org/apache/commons/collections/ExtendedProperties.java']
['Collections-14', 1, 1, 1, 1, ['*/ protected Object convertKey(Object key) { if (key != null) { return key.toString().toLowerCase(); } else { return AbstractHashedMap.NULL; }'], ['*/ protected Object convertKey(Object key) { if (key != null) { char[] chars = key.toString().toCharArray(); for (int i = chars.length - 1; i >= 0; i--) { chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i])); } return new String(chars); } else { return AbstractHashedMap.NULL; }'], ['return key.toString().toLowerCase();'], ['char[] chars = key.toString().toCharArray(); for (int i = chars.length - 1; i >= 0; i--) { chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i])); } return new String(chars);'], 'a/src/java/org/apache/commons/collections/map/CaseInsensitiveMap.java', 'b/src/java/org/apache/commons/collections/map/CaseInsensitiveMap.java']
['Collections-15', 1, 1, 1, 1, ["int pos = indexOf(object); Object removed = super.set(index, object); if (pos == -1 || pos == index) { // the object is already in the uniq list // (and it hasn't been swapped with itself) return removed; } super.remove(pos); set.remove(removed); // remove the item deleted by the set return removed; // return the item deleted by the set"], ["int pos = indexOf(object); Object removed = super.set(index, object); if (pos != -1 && pos != index) { // the object is already in the uniq list // (and it hasn't been swapped with itself) super.remove(pos); // remove the duplicate by index } set.add(object); // add the new item to the unique set set.remove(removed); // remove the item deleted by the set return removed; // return the item deleted by the set"], ['if (pos == -1 || pos == index) { return removed; super.remove(pos);'], ['if (pos != -1 && pos != index) { super.remove(pos); // remove the duplicate by index set.add(object); // add the new item to the unique set'], 'a/src/java/org/apache/commons/collections/list/SetUniqueList.java', 'b/src/java/org/apache/commons/collections/list/SetUniqueList.java']
['Collections-16', 1, 1, 1, 1, ['} public List subList(int fromIndex, int toIndex) { return new SetUniqueList(super.subList(fromIndex, toIndex), set); } //-----------------------------------------------------------------------'], ['} public List subList(int fromIndex, int toIndex) { List superSubList = super.subList(fromIndex, toIndex); Set subSet = createSetBasedOnList(set, superSubList); return new SetUniqueList(superSubList, subSet); } protected Set createSetBasedOnList(Set set, List list) { Set subSet = null; if(set.getClass().equals(HashSet.class)) { subSet = new HashSet(); } else { try { subSet = (Set) set.getClass().newInstance(); } catch(InstantiationException ie) { subSet = new HashSet(); } catch(IllegalAccessException iae) { subSet = new HashSet(); } } subSet.addAll(list); return subSet; } //-----------------------------------------------------------------------'], ['return new SetUniqueList(super.subList(fromIndex, toIndex), set);'], ['List superSubList = super.subList(fromIndex, toIndex); Set subSet = createSetBasedOnList(set, superSubList); return new SetUniqueList(superSubList, subSet); } protected Set createSetBasedOnList(Set set, List list) { Set subSet = null; if(set.getClass().equals(HashSet.class)) { subSet = new HashSet(); } else { try { subSet = (Set) set.getClass().newInstance(); } catch(InstantiationException ie) { subSet = new HashSet(); } catch(IllegalAccessException iae) { subSet = new HashSet(); } } subSet.addAll(list); return subSet;'], 'a/src/java/org/apache/commons/collections/list/SetUniqueList.java', 'b/src/java/org/apache/commons/collections/list/SetUniqueList.java']
['Collections-17', 2, 2, 2, 2, ['public EqualPredicate(T object) { // do not use the DefaultEquator to keep backwards compatibility // the DefaultEquator returns also true if the two object references are equal this(object, new DefaultEquator<T>()); } /**', '* @return true if input object equals stored value */ public boolean evaluate(T object) { return equator.equate(iValue, object); } /**'], ['public EqualPredicate(T object) { // do not use the DefaultEquator to keep backwards compatibility // the DefaultEquator returns also true if the two object references are equal this(object, null); } /**', '* @return true if input object equals stored value */ public boolean evaluate(T object) { if (equator != null) { return equator.equate(iValue, object); } else { return iValue.equals(object); } } /**'], ['this(object, new DefaultEquator<T>());', ''], ['this(object, null);', 'if (equator != null) { } else { return iValue.equals(object); }'], 'a/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java', 'b/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java']
['Collections-18', 1, 1, 1, 1, [' @Override public boolean retainAll(Collection<?> coll) { boolean result = collection.retainAll(coll); if (result == false) { return false; } if (collection.size() == 0) { setOrder.clear(); } else { for (Iterator<E> it = setOrder.iterator(); it.hasNext();) { if (!collection.contains(it.next())) { it.remove(); } } } return result; } @Override'], [' @Override public boolean retainAll(Collection<?> coll) { Set<Object> collectionRetainAll = new HashSet<Object>(); for (Iterator<?> it = coll.iterator(); it.hasNext();) { Object next = it.next(); if (collection.contains(next)) { collectionRetainAll.add(next); } } if (collectionRetainAll.size() == collection.size()) { return false; } if (collectionRetainAll.size() == 0) { clear(); } else { for (Iterator<E> it = iterator(); it.hasNext();) { if (!collectionRetainAll.contains(it.next())) { it.remove(); } } } return true; } @Override'], ['boolean result = collection.retainAll(coll); if (result == false) { if (collection.size() == 0) { setOrder.clear(); for (Iterator<E> it = setOrder.iterator(); it.hasNext();) { if (!collection.contains(it.next())) { return result;'], ['Set<Object> collectionRetainAll = new HashSet<Object>(); for (Iterator<?> it = coll.iterator(); it.hasNext();) { Object next = it.next(); if (collection.contains(next)) { collectionRetainAll.add(next); } } if (collectionRetainAll.size() == collection.size()) { if (collectionRetainAll.size() == 0) { clear(); for (Iterator<E> it = iterator(); it.hasNext();) { if (!collectionRetainAll.contains(it.next())) { return true;'], 'a/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java', 'b/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java']
['Collections-19', 1, 1, 1, 1, ["// the object is already in the uniq list // (and it hasn't been swapped with itself) super.remove(pos); // remove the duplicate by index } set.add(object); set.remove(removed); return removed; // return the item deleted by the set }"], ["// the object is already in the uniq list // (and it hasn't been swapped with itself) super.remove(pos); // remove the duplicate by index set.remove(removed); // remove the item deleted by the set } else if (pos == -1) { set.add(object); // add the new item to the unique set set.remove(removed); // remove the item deleted by the set } return removed; // return the item deleted by the set }"], ['set.add(object); set.remove(removed);'], ['set.remove(removed); // remove the item deleted by the set } else if (pos == -1) { set.add(object); // add the new item to the unique set set.remove(removed); // remove the item deleted by the set'], 'a/src/main/java/org/apache/commons/collections/list/SetUniqueList.java', 'b/src/main/java/org/apache/commons/collections/list/SetUniqueList.java']
['Collections-20', 1, 1, 1, 1, ['if (currentIndex == -1) { throw new IllegalStateException(); } if (nextIndex == currentIndex) { next = next.next(); parent.remove(currentIndex); } else { // remove() following next() parent.remove(currentIndex); nextIndex--; } // the AVL node referenced by next may have become stale after a remove // reset it now: will be retrieved by next call to next()/previous() via nextIndex current = null; currentIndex = -1; expectedModCount++;'], ['if (currentIndex == -1) { throw new IllegalStateException(); } parent.remove(currentIndex); if (nextIndex != currentIndex) { // remove() following next() nextIndex--; } // the AVL node referenced by next may have become stale after a remove // reset it now: will be retrieved by next call to next()/previous() via nextIndex next = null; current = null; currentIndex = -1; expectedModCount++;'], ['if (nextIndex == currentIndex) { next = next.next(); parent.remove(currentIndex); } else { parent.remove(currentIndex);'], ['parent.remove(currentIndex); if (nextIndex != currentIndex) { next = null;'], 'a/src/main/java/org/apache/commons/collections/list/TreeList.java', 'b/src/main/java/org/apache/commons/collections/list/TreeList.java']
['Collections-21', 2, 2, 2, 2, ['import java.util.ListIterator; import java.util.Set; import org.apache.commons.collections4.set.UnmodifiableSet; import org.apache.commons.collections4.iterators.AbstractIteratorDecorator; import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;', 'public List<E> subList(final int fromIndex, final int toIndex) { final List<E> superSubList = super.subList(fromIndex, toIndex); final Set<E> subSet = createSetBasedOnList(set, superSubList); return new SetUniqueList<E>(superSubList, subSet); } /**'], ['import java.util.ListIterator; import java.util.Set; import org.apache.commons.collections4.ListUtils; import org.apache.commons.collections4.set.UnmodifiableSet; import org.apache.commons.collections4.iterators.AbstractIteratorDecorator; import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;', 'public List<E> subList(final int fromIndex, final int toIndex) { final List<E> superSubList = super.subList(fromIndex, toIndex); final Set<E> subSet = createSetBasedOnList(set, superSubList); return ListUtils.unmodifiableList(new SetUniqueList<E>(superSubList, subSet)); } /**'], ['', 'return new SetUniqueList<E>(superSubList, subSet);'], ['import org.apache.commons.collections4.ListUtils;', 'return ListUtils.unmodifiableList(new SetUniqueList<E>(superSubList, subSet));'], 'a/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java', 'b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java']
['Collections-22', 1, 1, 1, 1, ['*/ public void putAll(int index, final Map<? extends K, ? extends V> map) { for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) { final V old = put(index, entry.getKey(), entry.getValue()); if (old == null) { // The return value of put is null if the key did not exist OR the value was null // so it cannot be used to determine whether the key was added // if no key was replaced, increment the index index++; } else {'], ['*/ public void putAll(int index, final Map<? extends K, ? extends V> map) { for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) { final K key = entry.getKey(); final boolean contains = containsKey(key); // The return value of put is null if the key did not exist OR the value was null // so it cannot be used to determine whether the key was added put(index, entry.getKey(), entry.getValue()); if (!contains) { // if no key was replaced, increment the index index++; } else {'], ['final V old = put(index, entry.getKey(), entry.getValue()); if (old == null) {'], ['final K key = entry.getKey(); final boolean contains = containsKey(key); put(index, entry.getKey(), entry.getValue()); if (!contains) {'], 'a/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java', 'b/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java']
['Collections-23', 1, 1, 1, 1, ['* @return a new unmodifiable trie * @throws IllegalArgumentException if trie is null */ public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) { return new UnmodifiableTrie<K, V>(trie); }'], ['* @return a new unmodifiable trie * @throws IllegalArgumentException if trie is null */ public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) { if (trie instanceof Unmodifiable) { @SuppressWarnings("unchecked") // safe to upcast final Trie<K, V> tmpTrie = (Trie<K, V>) trie; return tmpTrie; } return new UnmodifiableTrie<K, V>(trie); }'], ['public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {'], ['public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) { if (trie instanceof Unmodifiable) { @SuppressWarnings("unchecked") // safe to upcast final Trie<K, V> tmpTrie = (Trie<K, V>) trie; return tmpTrie; }'], 'a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java', 'b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java']
['Collections-24', 3, 3, 3, 3, ['import java.util.Iterator; import org.apache.commons.collections4.BoundedCollection; import org.apache.commons.collections4.iterators.UnmodifiableIterator; /**', '* @version $Id$ */ public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E> implements BoundedCollection<E> { /** Serialization version */ private static final long serialVersionUID = -7112672385450340330L;', '* @since 4.0 */ public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) { return new UnmodifiableBoundedCollection<E>(coll); }'], ['import java.util.Iterator; import org.apache.commons.collections4.BoundedCollection; import org.apache.commons.collections4.Unmodifiable; import org.apache.commons.collections4.iterators.UnmodifiableIterator; /**', '* @version $Id$ */ public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E> implements BoundedCollection<E>, Unmodifiable { /** Serialization version */ private static final long serialVersionUID = -7112672385450340330L;', '* @since 4.0 */ public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) { if (coll instanceof Unmodifiable) { @SuppressWarnings("unchecked") // safe to upcast final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll; return tmpColl; } return new UnmodifiableBoundedCollection<E>(coll); }'], ['', 'implements BoundedCollection<E> {', ''], ['import org.apache.commons.collections4.Unmodifiable;', 'implements BoundedCollection<E>, Unmodifiable {', 'if (coll instanceof Unmodifiable) { @SuppressWarnings("unchecked") // safe to upcast final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll; return tmpColl; }'], 'a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java', 'b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java']
['Collections-25', 3, 3, 3, 3, ['public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) { return new CollatingIterator<E>(comparator, iterator1, iterator2); } /**', '*/ public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) { return new CollatingIterator<E>(comparator, iterators); } /**', '*/ public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) { return new CollatingIterator<E>(comparator, iterators); } // Object Graph'], ['public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) { @SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterator1, iterator2); } /**', '*/ public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) { @SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterators); } /**', '*/ public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) { @SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterators); } // Object Graph'], ['return new CollatingIterator<E>(comparator, iterator1, iterator2);', 'return new CollatingIterator<E>(comparator, iterators);', 'return new CollatingIterator<E>(comparator, iterators);'], ['@SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterator1, iterator2);', '@SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterators);', '@SuppressWarnings("unchecked") final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator; return new CollatingIterator<E>(comp, iterators);'], 'a/src/main/java/org/apache/commons/collections4/IteratorUtils.java', 'b/src/main/java/org/apache/commons/collections4/IteratorUtils.java']
['Collections-26', 1, 1, 1, 1, ['* only stable for the same process). * @return the instance with recalculated hash code */ private Object readResolve() { calculateHashCode(keys); return this; }'], ['* only stable for the same process). * @return the instance with recalculated hash code */ protected Object readResolve() { calculateHashCode(keys); return this; }'], ['private Object readResolve() {'], ['protected Object readResolve() {'], 'a/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java', 'b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java']
['Collections-27', 0, 1, 1, 1, [], ['} } private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); // ensure that the de-serialized class is a Collection, COLLECTIONS-580 if (clazz != null && !Collection.class.isAssignableFrom(clazz)) { throw new UnsupportedOperationException(); } } } }'], [''], ['private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); // ensure that the de-serialized class is a Collection, COLLECTIONS-580 if (clazz != null && !Collection.class.isAssignableFrom(clazz)) { throw new UnsupportedOperationException(); } }'], 'a/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java', 'b/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java']
['Collections-28', 1, 1, 1, 1, ['return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } } /**'], ['return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } @Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } } } /**'], [''], ['@Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } }'], 'a/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java', 'b/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java']
['JacksonDatabind-1', 1, 1, 1, 1, ['} else { // can NOT suppress entries in tabular output jgen.writeNull(); } } // otherwise find serializer to use JsonSerializer<Object> ser = _serializer;'], ['} else { // can NOT suppress entries in tabular output jgen.writeNull(); } return; } // otherwise find serializer to use JsonSerializer<Object> ser = _serializer;'], [''], ['return;'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java']
['JacksonDatabind-2', 1, 1, 1, 1, ['@Override public void writeObject(Object value) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); /* 28-May-2014, tatu: Tricky choice here; if no codec, should we * err out, or just embed? For now, do latter. */ // throw new JsonMappingException("No ObjectCodec configured for TokenBuffer, writeObject() called"); } @Override public void writeTree(TreeNode node) throws IOException { // as with \'writeObject()\', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } /*'], ['@Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } else if (_objectCodec == null) { /* 28-May-2014, tatu: Tricky choice here; if no codec, should we * err out, or just embed? For now, do latter. */ // throw new JsonMappingException("No ObjectCodec configured for TokenBuffer, writeObject() called"); _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { // as with \'writeObject()\', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); } } /*'], [''], ['if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class) { return; } else if (_objectCodec == null) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } if (node == null) { writeNull(); return; } if (_objectCodec == null) { } else { _objectCodec.writeTree(this, node); }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java']
['JacksonDatabind-3', 2, 2, 2, 2, ['if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); } else { value = _parseString(jp, ctxt); }', ' while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt); if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;'], ["if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = null; // since we have established that '_elementDeserializer == null' earlier } else { value = _parseString(jp, ctxt); }", ' while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt); if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;'], ['value = _elementDeserializer.getNullValue();', 'String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);'], ["value = null; // since we have established that '_elementDeserializer == null' earlier", 'String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java']
['JacksonDatabind-4', 4, 4, 4, 4, ['int ix = 0; JsonToken t; while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value;', '} chunk[ix++] = value; } // note: pass String.class, not String[].class, as we need element type for error info String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result;', 'int ix = 0; JsonToken t; while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);', '} chunk[ix++] = value; } // note: pass String.class, not String[].class, as we need element type for error info String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result;'], ['int ix = 0; JsonToken t; try { while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value;', '} chunk[ix++] = value; } } catch (Exception e) { // note: pass String.class, not String[].class, as we need element type for error info throw JsonMappingException.wrapWithPath(e, String.class, ix); } String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result;', 'int ix = 0; JsonToken t; try { while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { // Ok: no need to convert Strings, but must recognize nulls String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);', '} chunk[ix++] = value; } } catch (Exception e) { // note: pass String.class, not String[].class, as we need element type for error info throw JsonMappingException.wrapWithPath(e, String.class, ix); } String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result;'], ['', '', '', ''], ['try {', '} catch (Exception e) { throw JsonMappingException.wrapWithPath(e, String.class, ix); }', 'try {', '} catch (Exception e) { throw JsonMappingException.wrapWithPath(e, String.class, ix); }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java']
['JacksonDatabind-5', 1, 1, 1, 1, ['*/ } else { // Well, or, as per [Issue#515], multi-level merge within mixins... mixIns.add(_constructMethod(m)); } } }'], ['*/ } else { // Well, or, as per [Issue#515], multi-level merge within mixins... am = mixIns.find(m); if (am != null) { _addMixUnders(m, am); } else { mixIns.add(_constructMethod(m)); } } } }'], [''], ['am = mixIns.find(m); if (am != null) { _addMixUnders(m, am); } else { }'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java']
['JacksonDatabind-6', 2, 2, 2, 2, ['// Milliseconds partial or missing; and even seconds are optional len = dateStr.length(); // remove \'T\', \'+\'/\'-\' and 4-digit timezone-offset c = dateStr.charAt(len-9); if (Character.isDigit(c)) { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-5, ".000"); dateStr = sb.toString(); } df = _formatISO8601;', 'StringBuilder sb = new StringBuilder(dateStr); // And possible also millisecond part if missing int timeLen = len - dateStr.lastIndexOf(\'T\') - 1; if (timeLen <= 8) { sb.append(".000"); } sb.append(\'Z\'); dateStr = sb.toString();'], ['// Milliseconds partial or missing; and even seconds are optional len = dateStr.length(); // remove \'T\', \'+\'/\'-\' and 4-digit timezone-offset int timeLen = len - dateStr.lastIndexOf(\'T\') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.insert(offset, \'0\'); break; case 10: sb.insert(offset, "00"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, "000"); break; case 8: sb.insert(offset, ".000"); break; case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let\'s allow sb.insert(offset, "00.000"); case 5: // is legal to omit seconds sb.insert(offset, ":00.000"); } dateStr = sb.toString(); } df = _formatISO8601;', 'StringBuilder sb = new StringBuilder(dateStr); // And possible also millisecond part if missing int timeLen = len - dateStr.lastIndexOf(\'T\') - 1; if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append(\'0\'); case 10: sb.append(\'0\'); case 9: sb.append(\'0\'); break; default: sb.append(".000"); } } sb.append(\'Z\'); dateStr = sb.toString();'], ['c = dateStr.charAt(len-9); if (Character.isDigit(c)) { sb.insert(len-5, ".000");', 'if (timeLen <= 8) {'], ['int timeLen = len - dateStr.lastIndexOf(\'T\') - 6; if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss int offset = len - 5; // insertion offset, before tz-offset switch (timeLen) { case 11: sb.insert(offset, \'0\'); break; case 10: sb.insert(offset, "00"); break; case 9: // is this legal? (just second fraction marker) sb.insert(offset, "000"); break; case 8: sb.insert(offset, ".000"); break; case 7: // not legal to have single-digit second break; case 6: // probably not legal, but let\'s allow sb.insert(offset, "00.000"); case 5: // is legal to omit seconds sb.insert(offset, ":00.000"); }', "if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default: }"], 'a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java']
['JacksonDatabind-7', 1, 1, 1, 1, ['*/ public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { copyCurrentStructure(jp); /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from * FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need * to assume one did exist. */ return this; }'], ['*/ public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(jp); return this; } /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from * FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need * to assume one did exist. */ JsonToken t; writeStartObject(); do { copyCurrentStructure(jp); } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException("Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got "+t); } writeEndObject(); return this; }'], [''], ['if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { return this; } JsonToken t; writeStartObject(); do { copyCurrentStructure(jp); } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException("Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got "+t); } writeEndObject();'], 'a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java']
['JacksonDatabind-8', 2, 2, 2, 2, ['AnnotatedWithParams oldOne = _creators[typeIndex]; // already had an explicitly marked one? if (oldOne != null) { if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated', 'return; } // both explicit: verify // otherwise only verify if neither explicitly annotated. } // one more thing: ok to override in sub-class if (oldOne.getClass() == newOne.getClass()) { // [databind#667]: avoid one particular class of bogus problems throw new IllegalArgumentException("Conflicting "+TYPE_DESCS[typeIndex] +" creators: already had explicitly marked "+oldOne+", encountered "+newOne); // otherwise, which one to choose? // new type more generic, use old // new type more specific, use it } }'], ['AnnotatedWithParams oldOne = _creators[typeIndex]; // already had an explicitly marked one? if (oldOne != null) { boolean verify; if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated', 'return; } // both explicit: verify verify = true; } else { // otherwise only verify if neither explicitly annotated. verify = !explicit; } // one more thing: ok to override in sub-class if (verify && (oldOne.getClass() == newOne.getClass())) { // [databind#667]: avoid one particular class of bogus problems Class<?> oldType = oldOne.getRawParameterType(0); Class<?> newType = newOne.getRawParameterType(0); if (oldType == newType) { throw new IllegalArgumentException("Conflicting "+TYPE_DESCS[typeIndex] +" creators: already had explicitly marked "+oldOne+", encountered "+newOne); } // otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return; } // new type more specific, use it } }'], ['', 'if (oldOne.getClass() == newOne.getClass()) {'], ['boolean verify;', 'verify = true; } else { verify = !explicit; if (verify && (oldOne.getClass() == newOne.getClass())) { Class<?> oldType = oldOne.getRawParameterType(0); Class<?> newType = newOne.getRawParameterType(0); if (oldType == newType) { } if (newType.isAssignableFrom(oldType)) { return; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java']
['JacksonDatabind-9', 1, 1, 1, 1, ['@Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { String str; if (value instanceof Date) { provider.defaultSerializeDateKey((Date) value, jgen); return; } else { str = value.toString(); }'], ['@Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { String str; Class<?> cls = value.getClass(); if (cls == String.class) { str = (String) value; } else if (Date.class.isAssignableFrom(cls)) { provider.defaultSerializeDateKey((Date) value, jgen); return; } else if (cls == Class.class) { str = ((Class<?>) value).getName(); } else { str = value.toString(); }'], ['if (value instanceof Date) {'], ['Class<?> cls = value.getClass(); if (cls == String.class) { str = (String) value; } else if (Date.class.isAssignableFrom(cls)) { } else if (cls == Class.class) { str = ((Class<?>) value).getName();'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java']
['JacksonDatabind-10', 5, 5, 5, 5, ['*/ protected final AnnotatedMember _accessor; protected MapSerializer _mapSerializer; @SuppressWarnings("unchecked") public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) { _accessor = accessor; _property = property; _mapSerializer = (MapSerializer) serializer; } public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)', '_mapSerializer.serializeFields((Map<?,?>) value, gen, provider); return; } } /**', 'return; } // ... not sure how custom handler would do it } // Note: NOT part of ResolvableSerializer...', 'public void resolve(SerializerProvider provider) throws JsonMappingException { // 05-Sep-2013, tatu: I _think_ this can be considered a primary property... _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property); } }', "TypeSerializer typeSer = createTypeSerializer(config, valueType); // last 2 nulls; don't know key, value serializers (yet) // 23-Feb-2015, tatu: As per [#705], need to support custom serializers MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null); // TODO: support '@JsonIgnoreProperties' with any setter? // TODO: can we find full PropertyName? PropertyName name = new PropertyName(anyGetter.getName()); BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,"], ['*/ protected final AnnotatedMember _accessor; protected JsonSerializer<Object> _serializer; protected MapSerializer _mapSerializer; @SuppressWarnings("unchecked") public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, JsonSerializer<?> serializer) { _accessor = accessor; _property = property; _serializer = (JsonSerializer<Object>) serializer; if (serializer instanceof MapSerializer) { _mapSerializer = (MapSerializer) serializer; } } public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)', '_mapSerializer.serializeFields((Map<?,?>) value, gen, provider); return; } _serializer.serialize(value, gen, provider); } /**', 'return; } // ... not sure how custom handler would do it _serializer.serialize(value, gen, provider); } // Note: NOT part of ResolvableSerializer...', 'public void resolve(SerializerProvider provider) throws JsonMappingException { // 05-Sep-2013, tatu: I _think_ this can be considered a primary property... if (_serializer instanceof ContextualSerializer) { JsonSerializer<?> ser = provider.handlePrimaryContextualization(_serializer, _property); _serializer = (JsonSerializer<Object>) ser; if (ser instanceof MapSerializer) { _mapSerializer = (MapSerializer) ser; } } } }', "TypeSerializer typeSer = createTypeSerializer(config, valueType); // last 2 nulls; don't know key, value serializers (yet) // 23-Feb-2015, tatu: As per [#705], need to support custom serializers JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter); if (anySer == null) { // TODO: support '@JsonIgnoreProperties' with any setter? anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping, typeSer, null, null, /*filterId*/ null); } // TODO: can we find full PropertyName? PropertyName name = new PropertyName(anyGetter.getName()); BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,"], ['AnnotatedMember accessor, MapSerializer serializer)', '', '', '_mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);', 'MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);'], ['protected JsonSerializer<Object> _serializer; AnnotatedMember accessor, JsonSerializer<?> serializer) _serializer = (JsonSerializer<Object>) serializer; if (serializer instanceof MapSerializer) { }', '_serializer.serialize(value, gen, provider);', '_serializer.serialize(value, gen, provider);', 'if (_serializer instanceof ContextualSerializer) { JsonSerializer<?> ser = provider.handlePrimaryContextualization(_serializer, _property); _serializer = (JsonSerializer<Object>) ser; if (ser instanceof MapSerializer) { _mapSerializer = (MapSerializer) ser; } }', 'JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter); if (anySer == null) { anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping, typeSer, null, null, /*filterId*/ null); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java']
['JacksonDatabind-11', 1, 1, 1, 1, ["// 19-Mar-2015: Without context, all we can check are bounds. if (context == null) { // And to prevent infinite loops, now need this: return _unknownType(); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name); if (actualType != null) { return actualType; }"], ["// 19-Mar-2015: Without context, all we can check are bounds. if (context == null) { // And to prevent infinite loops, now need this: context = new TypeBindings(this, (Class<?>) null); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name, false); if (actualType != null) { return actualType; }"], ['return _unknownType(); JavaType actualType = context.findType(name);'], ['context = new TypeBindings(this, (Class<?>) null); JavaType actualType = context.findType(name, false);'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-12', 1, 1, 1, 1, ['/* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueTypeDeserializer == null) && (_ignorableProperties == null); }'], ['/* As per [databind#735], existence of value or key deserializer (only passed * if annotated to use non-standard one) should also prevent caching. */ return (_valueDeserializer == null) && (_keyDeserializer == null) && (_valueTypeDeserializer == null) && (_ignorableProperties == null); }'], ['return (_valueTypeDeserializer == null)'], ['return (_valueDeserializer == null) && (_keyDeserializer == null) && (_valueTypeDeserializer == null)'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java']
['JacksonDatabind-13', 2, 2, 2, 2, ["/* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how * missing id already works. */ final ObjectIdGenerator.IdKey key = gen.key(id);", '* will be generated externally, at a later point, and is not available * quite yet. Typical use case is with DB inserts. */ ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance);'], ["/* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how * missing id already works. */ if (id == null) { return null; } final ObjectIdGenerator.IdKey key = gen.key(id);", '* will be generated externally, at a later point, and is not available * quite yet. Typical use case is with DB inserts. */ if (id == null) { return null; } ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance);'], ['', ''], ['if (id == null) { return null; }', 'if (id == null) { return null; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java']
['JacksonDatabind-14', 2, 2, 2, 2, ['result = NullNode.instance; } else { DeserializationContext ctxt = createDeserializationContext(jp, _config); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE); if (_unwrapRoot) { result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); } else {', '/** * @since 2.6 */ // Nope: need to ask provider to resolve it /** * Method called to locate deserializer ahead of time, if permitted'], ['result = NullNode.instance; } else { DeserializationContext ctxt = createDeserializationContext(jp, _config); JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt); if (_unwrapRoot) { result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); } else {', '/** * @since 2.6 */ protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException { JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE); if (deser == null) { // Nope: need to ask provider to resolve it deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE); if (deser == null) { // can this happen? throw new JsonMappingException("Can not find a deserializer for type "+JSON_NODE_TYPE); } _rootDeserializers.put(JSON_NODE_TYPE, deser); } return deser; } /** * Method called to locate deserializer ahead of time, if permitted'], ['JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);', ''], ['JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);', 'protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt) throws JsonMappingException { JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE); if (deser == null) { deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE); if (deser == null) { // can this happen? throw new JsonMappingException("Can not find a deserializer for type "+JSON_NODE_TYPE); } _rootDeserializers.put(JSON_NODE_TYPE, deser); } return deser; }'], 'a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java', 'b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java']
['JacksonDatabind-15', 11, 11, 11, 11, ['* * @since 2.5 */ /** * Accessor for checking whether handlers for dealing with values of', 'ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); } // [databind#731]: Should skip if nominally java.lang.Object if (ser == null) { ser = _createSerializer2(prov, delegateType, beanDesc, true); } return new StdDelegatingSerializer(conv, delegateType, ser);', 'Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); // [databind#731]: Should skip if nominally java.lang.Object JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); return new StdDelegatingSerializer(conv, delegateType, ser); } }', '/* 02-Apr-2015, tatu: For "dynamic case", where type is only specified as * java.lang.Object (or missing generic), [databind#731] */ delSer = provider.findValueSerializer(delegateType); } if (delSer instanceof ContextualSerializer) { delSer = provider.handleSecondaryContextualization(delSer, property); } return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer); } /*', 'return; } // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup _delegateSerializer.serialize(delegateValue, gen, provider); } @Override', "* let's give it a chance? */ Object delegateValue = convertValue(value); _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer); } @Override", 'public boolean isEmpty(Object value) { Object delegateValue = convertValue(value); return _delegateSerializer.isEmpty(delegateValue); }', 'public boolean isEmpty(SerializerProvider prov, Object value) { Object delegateValue = convertValue(value); return _delegateSerializer.isEmpty(prov, delegateValue); }', '* properly... but for now, try this: */ // 02-Apr-2015, tatu: For dynamic case, very little we can do _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint); } /*', '* * @since 2.6 */ // NOTE: will NOT call contextualization }', 'Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); // [databind#731]: Should skip if nominally java.lang.Object if (existingSerializer == null) { existingSerializer = provider.findValueSerializer(delegateType); } return new StdDelegatingSerializer(conv, delegateType, existingSerializer);'], ['* * @since 2.5 */ public final boolean isJavaLangObject() { return _class == Object.class; } /** * Accessor for checking whether handlers for dealing with values of', 'ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); } // [databind#731]: Should skip if nominally java.lang.Object if (ser == null && !delegateType.isJavaLangObject()) { ser = _createSerializer2(prov, delegateType, beanDesc, true); } return new StdDelegatingSerializer(conv, delegateType, ser);', 'Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); // [databind#731]: Should skip if nominally java.lang.Object JsonSerializer<?> ser = delegateType.isJavaLangObject() ? null : provider.findValueSerializer(delegateType, prop); return new StdDelegatingSerializer(conv, delegateType, ser); } }', '/* 02-Apr-2015, tatu: For "dynamic case", where type is only specified as * java.lang.Object (or missing generic), [databind#731] */ if (!delegateType.isJavaLangObject()) { delSer = provider.findValueSerializer(delegateType); } } if (delSer instanceof ContextualSerializer) { delSer = provider.handleSecondaryContextualization(delSer, property); } if (delSer == _delegateSerializer && delegateType == _delegateType) { return this; } return withDelegate(_converter, delegateType, delSer); } /*', 'return; } // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup JsonSerializer<Object> ser = _delegateSerializer; if (ser == null) { ser = _findSerializer(delegateValue, provider); } ser.serialize(delegateValue, gen, provider); } @Override', "* let's give it a chance? */ Object delegateValue = convertValue(value); JsonSerializer<Object> ser = _delegateSerializer; if (ser == null) { ser = _findSerializer(value, provider); } ser.serializeWithType(delegateValue, gen, provider, typeSer); } @Override", 'public boolean isEmpty(Object value) { Object delegateValue = convertValue(value); if (_delegateSerializer == null) { // best we can do for now, too costly to look up return (value == null); } return _delegateSerializer.isEmpty(delegateValue); }', 'public boolean isEmpty(SerializerProvider prov, Object value) { Object delegateValue = convertValue(value); if (_delegateSerializer == null) { // best we can do for now, too costly to look up return (value == null); } return _delegateSerializer.isEmpty(prov, delegateValue); }', '* properly... but for now, try this: */ // 02-Apr-2015, tatu: For dynamic case, very little we can do if (_delegateSerializer != null) { _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint); } } /*', '* * @since 2.6 */ protected JsonSerializer<Object> _findSerializer(Object value, SerializerProvider serializers) throws JsonMappingException { // NOTE: will NOT call contextualization return serializers.findValueSerializer(value.getClass()); } }', 'Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); // [databind#731]: Should skip if nominally java.lang.Object if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) { existingSerializer = provider.findValueSerializer(delegateType); } return new StdDelegatingSerializer(conv, delegateType, existingSerializer);'], ['', 'if (ser == null) {', 'JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);', 'return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);', '_delegateSerializer.serialize(delegateValue, gen, provider);', '_delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);', '', '', '_delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);', '', 'if (existingSerializer == null) {'], ['public final boolean isJavaLangObject() { return _class == Object.class; }', 'if (ser == null && !delegateType.isJavaLangObject()) {', 'JsonSerializer<?> ser = delegateType.isJavaLangObject() ? null : provider.findValueSerializer(delegateType, prop);', 'if (!delegateType.isJavaLangObject()) { } if (delSer == _delegateSerializer && delegateType == _delegateType) { return this; } return withDelegate(_converter, delegateType, delSer);', 'JsonSerializer<Object> ser = _delegateSerializer; if (ser == null) { ser = _findSerializer(delegateValue, provider); } ser.serialize(delegateValue, gen, provider);', 'JsonSerializer<Object> ser = _delegateSerializer; if (ser == null) { ser = _findSerializer(value, provider); } ser.serializeWithType(delegateValue, gen, provider, typeSer);', 'if (_delegateSerializer == null) { // best we can do for now, too costly to look up return (value == null); }', 'if (_delegateSerializer == null) { // best we can do for now, too costly to look up return (value == null); }', 'if (_delegateSerializer != null) { _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint); }', 'protected JsonSerializer<Object> _findSerializer(Object value, SerializerProvider serializers) throws JsonMappingException { return serializers.findValueSerializer(value.getClass()); }', 'if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) {'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java']
['JacksonDatabind-16', 1, 1, 1, 1, ['_annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); return (previous != null) && previous.equals(ann); } }'], ['_annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); return (previous == null) || !previous.equals(ann); } }'], ['return (previous != null) && previous.equals(ann);'], ['return (previous == null) || !previous.equals(ann);'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java']
['JacksonDatabind-17', 1, 1, 1, 1, ['return (t.getRawClass() == Object.class) || (!t.isConcrete() // [databind#88] Should not apply to JSON tree models: || TreeNode.class.isAssignableFrom(t.getRawClass())); case NON_FINAL: while (t.isArrayType()) {'], ['return (t.getRawClass() == Object.class) || (!t.isConcrete() // [databind#88] Should not apply to JSON tree models: && !TreeNode.class.isAssignableFrom(t.getRawClass())); case NON_FINAL: while (t.isArrayType()) {'], ['|| TreeNode.class.isAssignableFrom(t.getRawClass()));'], ['&& !TreeNode.class.isAssignableFrom(t.getRawClass()));'], 'a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java', 'b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java']
['JacksonDatabind-18', 9, 9, 9, 9, ['/** * State in which iterator is closed */ /** * State in which value read failed */ /** * State in which no recovery is needed, but "hasNextValue()" needs * to be called first */ /** * State in which "hasNextValue()" has been succesfully called * and deserializer can be called to fetch value */ /* /**********************************************************', '* as not <code>null</code> but set as <code>null</null> when * iterator is closed, to denote closing. */ protected JsonParser _parser; /** * Context to resynchronize to, in case an exception is encountered * but caller wants to try to read more elements. */ /** * If not null, "value to update" instead of creating a new instance', '/** * State of the iterator */ protected boolean _hasNextChecked; /* /**********************************************************', "* and if not, caller needs to hand us JsonParser instead, pointing to * the first token of the first element. */ if (managedParser && (p != null) && p.isExpectedStartArrayToken()) { // If pointing to START_ARRAY, context should be that ARRAY p.clearCurrentToken(); // regardless, recovery context should be whatever context we have now, // with sole exception of pointing to a start marker, in which case it's // the parent } }", ' @Override public void close() throws IOException { if (_parser != null) { _parser.close(); } } /*', "*/ public boolean hasNextValue() throws IOException { if (_parser == null) { return false; // fall-through } if (!_hasNextChecked) { JsonToken t = _parser.getCurrentToken(); _hasNextChecked = true; if (t == null) { // un-initialized or cleared; find next t = _parser.nextToken(); // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token). if (t == null || t == JsonToken.END_ARRAY) { JsonParser jp = _parser; _parser = null; if (_closeParser) { jp.close(); } return false; } } // fall through } return true;", ' public T nextValue() throws IOException { if (!_hasNextChecked) { if (!hasNextValue()) { return _throwNoSuchElement(); } } if (_parser == null) { return _throwNoSuchElement(); } _hasNextChecked = false; try { T value; if (_updatedValue == null) {', '_deserializer.deserialize(_parser, _context, _updatedValue); value = _updatedValue; } return value; } finally { /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no * matter what, to avoid infinite loop for certain failure cases. * For 2.6 need to improve further.', '/********************************************************** */ // First, a quick check to see if we might have been lucky and no re-sync needed protected <R> R _throwNoSuchElement() { throw new NoSuchElementException();'], ['/** * State in which iterator is closed */ protected final static int STATE_CLOSED = 0; /** * State in which value read failed */ protected final static int STATE_NEED_RESYNC = 1; /** * State in which no recovery is needed, but "hasNextValue()" needs * to be called first */ protected final static int STATE_MAY_HAVE_VALUE = 2; /** * State in which "hasNextValue()" has been succesfully called * and deserializer can be called to fetch value */ protected final static int STATE_HAS_VALUE = 3; /* /**********************************************************', '* as not <code>null</code> but set as <code>null</null> when * iterator is closed, to denote closing. */ protected final JsonParser _parser; /** * Context to resynchronize to, in case an exception is encountered * but caller wants to try to read more elements. */ protected final JsonStreamContext _seqContext; /** * If not null, "value to update" instead of creating a new instance', '/** * State of the iterator */ protected int _state; /* /**********************************************************', "* and if not, caller needs to hand us JsonParser instead, pointing to * the first token of the first element. */ if (p == null) { // can this occur? _seqContext = null; _state = STATE_CLOSED; } else { JsonStreamContext sctxt = p.getParsingContext(); if (managedParser && p.isExpectedStartArrayToken()) { // If pointing to START_ARRAY, context should be that ARRAY p.clearCurrentToken(); } else { // regardless, recovery context should be whatever context we have now, // with sole exception of pointing to a start marker, in which case it's // the parent JsonToken t = p.getCurrentToken(); if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) { sctxt = sctxt.getParent(); } } _seqContext = sctxt; _state = STATE_MAY_HAVE_VALUE; } }", ' @Override public void close() throws IOException { if (_state != STATE_CLOSED) { _state = STATE_CLOSED; if (_parser != null) { _parser.close(); } } } /*', "*/ public boolean hasNextValue() throws IOException { switch (_state) { case STATE_CLOSED: return false; case STATE_NEED_RESYNC: _resync(); // fall-through case STATE_MAY_HAVE_VALUE: JsonToken t = _parser.getCurrentToken(); if (t == null) { // un-initialized or cleared; find next t = _parser.nextToken(); // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token). if (t == null || t == JsonToken.END_ARRAY) { _state = STATE_CLOSED; if (_closeParser && (_parser != null)) { _parser.close(); } return false; } } _state = STATE_HAS_VALUE; return true; case STATE_HAS_VALUE: // fall through } return true;", ' public T nextValue() throws IOException { switch (_state) { case STATE_CLOSED: return _throwNoSuchElement(); case STATE_NEED_RESYNC: // fall-through, will do re-sync case STATE_MAY_HAVE_VALUE: if (!hasNextValue()) { return _throwNoSuchElement(); } break; case STATE_HAS_VALUE: break; } int nextState = STATE_NEED_RESYNC; try { T value; if (_updatedValue == null) {', '_deserializer.deserialize(_parser, _context, _updatedValue); value = _updatedValue; } nextState = STATE_MAY_HAVE_VALUE; return value; } finally { _state = nextState; /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no * matter what, to avoid infinite loop for certain failure cases. * For 2.6 need to improve further.', '/********************************************************** */ protected void _resync() throws IOException { final JsonParser p = _parser; // First, a quick check to see if we might have been lucky and no re-sync needed if (p.getParsingContext() == _seqContext) { return; } while (true) { JsonToken t = p.nextToken(); if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) { if (p.getParsingContext() == _seqContext) { p.clearCurrentToken(); return; } } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) { p.skipChildren(); } else if (t == null) { return; } } } protected <R> R _throwNoSuchElement() { throw new NoSuchElementException();'], ['', 'protected JsonParser _parser;', 'protected boolean _hasNextChecked;', 'if (managedParser && (p != null) && p.isExpectedStartArrayToken()) {', '', 'if (_parser == null) { } if (!_hasNextChecked) { _hasNextChecked = true; JsonParser jp = _parser; _parser = null; if (_closeParser) { jp.close();', 'if (!_hasNextChecked) { if (_parser == null) { return _throwNoSuchElement(); } _hasNextChecked = false;', '', ''], ['protected final static int STATE_CLOSED = 0; protected final static int STATE_NEED_RESYNC = 1; protected final static int STATE_MAY_HAVE_VALUE = 2; protected final static int STATE_HAS_VALUE = 3;', 'protected final JsonParser _parser; protected final JsonStreamContext _seqContext;', 'protected int _state;', 'if (p == null) { // can this occur? _seqContext = null; _state = STATE_CLOSED; } else { JsonStreamContext sctxt = p.getParsingContext(); if (managedParser && p.isExpectedStartArrayToken()) { } else { JsonToken t = p.getCurrentToken(); if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) { sctxt = sctxt.getParent(); } } _seqContext = sctxt; _state = STATE_MAY_HAVE_VALUE;', 'if (_state != STATE_CLOSED) { _state = STATE_CLOSED; }', 'switch (_state) { case STATE_CLOSED: case STATE_NEED_RESYNC: _resync(); case STATE_MAY_HAVE_VALUE: _state = STATE_CLOSED; if (_closeParser && (_parser != null)) { _parser.close(); _state = STATE_HAS_VALUE; return true; case STATE_HAS_VALUE:', 'switch (_state) { case STATE_CLOSED: return _throwNoSuchElement(); case STATE_NEED_RESYNC: // fall-through, will do re-sync case STATE_MAY_HAVE_VALUE: break; case STATE_HAS_VALUE: break; int nextState = STATE_NEED_RESYNC;', 'nextState = STATE_MAY_HAVE_VALUE; _state = nextState;', 'protected void _resync() throws IOException { final JsonParser p = _parser; if (p.getParsingContext() == _seqContext) { return; } while (true) { JsonToken t = p.nextToken(); if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) { if (p.getParsingContext() == _seqContext) { p.clearCurrentToken(); return; } } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) { p.skipChildren(); } else if (t == null) { return; } } }'], 'a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java', 'b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java']
['JacksonDatabind-19', 1, 1, 1, 1, ['private JavaType _mapType(Class<?> rawClass) { // 28-May-2015, tatu: Properties are special, as per [databind#810] JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types ("raw") if (typeParams == null) {'], ['private JavaType _mapType(Class<?> rawClass) { // 28-May-2015, tatu: Properties are special, as per [databind#810] if (rawClass == Properties.class) { return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING); } JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types ("raw") if (typeParams == null) {'], [''], ['if (rawClass == Properties.class) { return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING); }'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-20', 2, 2, 2, 2, ['package com.fasterxml.jackson.databind.node; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.SerializerProvider;', '* * @since 2.1 */ public JsonNode setAll(Map<String,? extends JsonNode> properties) { for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {'], ['package com.fasterxml.jackson.databind.node; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.SerializerProvider;', '* * @since 2.1 */ @JsonIgnore // work-around for [databind#815] public JsonNode setAll(Map<String,? extends JsonNode> properties) { for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {'], ['', ''], ['import com.fasterxml.jackson.annotation.JsonIgnore;', '@JsonIgnore // work-around for [databind#815]'], 'a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java', 'b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java']
['JacksonDatabind-21', 2, 2, 2, 2, ['package com.fasterxml.jackson.databind.introspect; import java.lang.annotation.Annotation; import java.util.*; import com.fasterxml.jackson.annotation.*;', '* Since 2.6, we have supported use of {@link JsonProperty} for specifying * explicit serialized name */ // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming. // Unfortunately can not quite use standard AnnotatedClass here (due to various // reasons, including odd representation JVM uses); has to do for now // We know that values are actually static fields with matching name so: // no such field, or access; neither which we can do much about /* /**********************************************************'], ['package com.fasterxml.jackson.databind.introspect; import java.lang.annotation.Annotation; import java.lang.reflect.Field; import java.util.*; import com.fasterxml.jackson.annotation.*;', '* Since 2.6, we have supported use of {@link JsonProperty} for specifying * explicit serialized name */ @Override public String findEnumValue(Enum<?> value) { // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming. // Unfortunately can not quite use standard AnnotatedClass here (due to various // reasons, including odd representation JVM uses); has to do for now try { // We know that values are actually static fields with matching name so: Field f = value.getClass().getField(value.name()); if (f != null) { JsonProperty prop = f.getAnnotation(JsonProperty.class); String n = prop.value(); if (n != null && !n.isEmpty()) { return n; } } } catch (Exception e) { // no such field, or access; neither which we can do much about } return value.name(); } /* /**********************************************************'], ['', ''], ['import java.lang.reflect.Field;', '@Override public String findEnumValue(Enum<?> value) { try { Field f = value.getClass().getField(value.name()); if (f != null) { JsonProperty prop = f.getAnnotation(JsonProperty.class); String n = prop.value(); if (n != null && !n.isEmpty()) { return n; } } } catch (Exception e) { } return value.name(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java']
['JacksonDatabind-22', 12, 12, 12, 12, ['*/ JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } // With Map-like, just 2 options: (1) Custom, (2) Annotations JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom MapLikeType mlType = (MapLikeType) type; ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } return ser; } } return null; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } // With Map-like, just 2 options: (1) Custom, (2) Annotations', 'for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } return ser; } } return null; } if (type.isArrayType()) { return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null;', '* * @since 2.1 */ protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; // Order of lookups: // 1. Custom serializers', '} if (ser == null) { // We may also want to use serialize Collections "as beans", if (and only if) // this is specified with `@JsonFormat(shape=Object)` JsonFormat.Value format = beanDesc.findExpectedFormat(null);', 'if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } }', '* Helper method that handles configuration details when constructing serializers for * {@link java.util.Map} types. */ protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { JsonSerializer<?> ser = null; // Order of lookups:', 'if (ser != null) { break; } } if (ser == null) { // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer /* if (EnumMap.class.isAssignableFrom(type.getRawClass())', '} ser = mapSer; } // [databind#120]: Allow post-processing if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {', '* Helper method that handles configuration details when constructing serializers for * <code>Object[]</code> (and subtypes, except for String). */ protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)', '// types can not be annotated (in theory I guess we could have mix-ins but... ?) // so we need not do primary annotation lookup here. // So all we need is (1) Custom, (2) Default array serializers JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom', 'JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); if (ser != null) { return ser; } final SerializationConfig config = prov.getConfig(); // Container types differ from non-container types', '} // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6, // this call was BEFORE custom serializer lookup, which was wrong. } if (ser == null) {'], ['*/ JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); if (mlt.isTrueMapType()) { return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); } // With Map-like, just 2 options: (1) Custom, (2) Annotations JsonSerializer<?> ser = null; MapLikeType mlType = (MapLikeType) type; for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); } if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); } } } return ser; } if (type.isCollectionLikeType()) { CollectionLikeType clt = (CollectionLikeType) type; if (clt.isTrueCollectionType()) { return buildCollectionSerializer(prov, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } // With Map-like, just 2 options: (1) Custom, (2) Annotations', 'for (Serializers serializers : customSerializers()) { // (1) Custom ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); } if (ser != null) { if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); } } } return ser; } if (type.isArrayType()) { return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); } return null;', '* * @since 2.1 */ protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { SerializationConfig config = prov.getConfig(); JsonSerializer<?> ser = null; // Order of lookups: // 1. Custom serializers', '} if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) { // We may also want to use serialize Collections "as beans", if (and only if) // this is specified with `@JsonFormat(shape=Object)` JsonFormat.Value format = beanDesc.findExpectedFormat(null);', 'if (ser == null) { ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); } } } }', '* Helper method that handles configuration details when constructing serializers for * {@link java.util.Map} types. */ protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { final SerializationConfig config = prov.getConfig(); JsonSerializer<?> ser = null; // Order of lookups:', 'if (ser != null) { break; } } if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) { // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer /* if (EnumMap.class.isAssignableFrom(type.getRawClass())', '} ser = mapSer; } } // [databind#120]: Allow post-processing if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {', '* Helper method that handles configuration details when constructing serializers for * <code>Object[]</code> (and subtypes, except for String). */ protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)', '// types can not be annotated (in theory I guess we could have mix-ins but... ?) // so we need not do primary annotation lookup here. // So all we need is (1) Custom, (2) Default array serializers SerializationConfig config = prov.getConfig(); JsonSerializer<?> ser = null; for (Serializers serializers : customSerializers()) { // (1) Custom', 'JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { JsonSerializer<?> ser = null; final SerializationConfig config = prov.getConfig(); // Container types differ from non-container types', '} // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6, // this call was BEFORE custom serializer lookup, which was wrong. if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); } } if (ser == null) {'], ['return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, MapLikeType mlType = (MapLikeType) type; } return ser; return null; return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping,', '} return ser; return null; return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,', 'protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,', '', '', 'protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,', '', '', 'protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,', '', 'JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); if (ser != null) { return ser; }', ''], ['return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping, MapLikeType mlType = (MapLikeType) type; if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); } return ser; return buildCollectionSerializer(prov, (CollectionType) clt, beanDesc, staticTyping,', 'if (ser != null) { break; } } if (ser == null) { // (2) Annotations-based ones: ser = findSerializerByAnnotations(prov, type, beanDesc); } return ser; return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,', 'protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov, SerializationConfig config = prov.getConfig();', 'ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) {', '}', 'protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov, final SerializationConfig config = prov.getConfig();', 'ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations if (ser == null) {', '}', 'protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov,', 'SerializationConfig config = prov.getConfig();', 'JsonSerializer<?> ser = null;', 'if (ser == null) { ser = findSerializerByAnnotations(prov, type, beanDesc); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java']
['JacksonDatabind-23', 7, 7, 7, 7, ['protected abstract static class Base<T> extends StdScalarSerializer<T> implements ContextualSerializer { protected final JsonParser.NumberType _numberType; protected final String _schemaType;', '@JacksonStdImpl public final static class ShortSerializer extends Base<Short> { final static ShortSerializer instance = new ShortSerializer(); public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, "number"); } @Override public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {', 'serialize(value, gen, provider); } } /**', 'super(Number.class, JsonParser.NumberType.INT, "integer"); } @Override public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class LongSerializer extends Base<Object> { final static LongSerializer instance = new LongSerializer(); public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, "number"); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class FloatSerializer extends Base<Object> { final static FloatSerializer instance = new FloatSerializer(); public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, "number"); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class DoubleSerializer extends Base<Object> { final static DoubleSerializer instance = new DoubleSerializer(); public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, "number"); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {'], ['protected abstract static class Base<T> extends StdScalarSerializer<T> implements ContextualSerializer { protected final static Integer EMPTY_INTEGER = Integer.valueOf(0); protected final JsonParser.NumberType _numberType; protected final String _schemaType;', '@JacksonStdImpl public final static class ShortSerializer extends Base<Short> { private final static Short EMPTY = (short) 0; final static ShortSerializer instance = new ShortSerializer(); public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, "number"); } @Override public boolean isEmpty(SerializerProvider prov, Short value) { return EMPTY.equals(value); } @Override public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {', 'serialize(value, gen, provider); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY_INTEGER.equals(value); } } /**', 'super(Number.class, JsonParser.NumberType.INT, "integer"); } @Override public boolean isEmpty(SerializerProvider prov, Number value) { return value.intValue() == 0; } @Override public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class LongSerializer extends Base<Object> { private final static Long EMPTY = 0L; final static LongSerializer instance = new LongSerializer(); public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, "number"); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class FloatSerializer extends Base<Object> { private final static Float EMPTY = 0f; final static FloatSerializer instance = new FloatSerializer(); public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, "number"); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {', '@JacksonStdImpl public final static class DoubleSerializer extends Base<Object> { private final static Double EMPTY = 0d; final static DoubleSerializer instance = new DoubleSerializer(); public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, "number"); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {'], ['', '', '', '', '', '', ''], ['protected final static Integer EMPTY_INTEGER = Integer.valueOf(0);', 'private final static Short EMPTY = (short) 0; @Override public boolean isEmpty(SerializerProvider prov, Short value) { return EMPTY.equals(value); }', '@Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY_INTEGER.equals(value); }', '@Override public boolean isEmpty(SerializerProvider prov, Number value) { return value.intValue() == 0; }', 'private final static Long EMPTY = 0L; @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); }', 'private final static Float EMPTY = 0f; @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); }', 'private final static Double EMPTY = 0d; @Override public boolean isEmpty(SerializerProvider prov, Object value) { return EMPTY.equals(value); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java']
['JacksonDatabind-24', 1, 1, 1, 1, ['if (_dateFormat == df) { return this; } TimeZone tz = (df == null) ? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64); } public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {'], ['if (_dateFormat == df) { return this; } return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64); } public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {'], ['TimeZone tz = (df == null) ? _timeZone : df.getTimeZone(); tz, _defaultBase64);'], ['_timeZone, _defaultBase64);'], 'a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java', 'b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java']
['JacksonDatabind-25', 4, 4, 4, 4, ['Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = (T) type.narrowBy(subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method \'"+a.getName()+"\': "+iae.getMessage(), null, iae); }', 'Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = type.narrowBy(subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method \'"+a.getName()+"\': "+iae.getMessage(), null, iae); }', '* important for some reason? * Disabling the check will break 2 Enum-related tests. */ type = _baseType.narrowBy(type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(type, _property); }', 'return null; } // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory return type.narrowBy(dst); }'], ['Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method \'"+a.getName()+"\': "+iae.getMessage(), null, iae); }', 'Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = ctxt.getTypeFactory().constructSpecializedType(type, subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method \'"+a.getName()+"\': "+iae.getMessage(), null, iae); }', '* important for some reason? * Disabling the check will break 2 Enum-related tests. */ type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(type, _property); }', 'return null; } // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory return config.getTypeFactory().constructSpecializedType(type, dst); }'], ['type = (T) type.narrowBy(subclass);', 'type = type.narrowBy(subclass);', 'type = _baseType.narrowBy(type.getRawClass());', 'return type.narrowBy(dst);'], ['type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);', 'type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);', 'type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());', 'return config.getTypeFactory().constructSpecializedType(type, dst);'], 'a/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java', 'b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java']
['JacksonDatabind-26', 1, 1, 1, 1, ['*/ @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not public class BeanPropertyWriter extends PropertyWriter implements BeanProperty { // as of 2.6.2 /** * Marker object used to indicate "do not serialize if empty"'], ['*/ @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not public class BeanPropertyWriter extends PropertyWriter implements BeanProperty, java.io.Serializable // since 2.6.2 { // as of 2.6.2 private static final long serialVersionUID = 4603296144163950020L; /** * Marker object used to indicate "do not serialize if empty"'], ['implements BeanProperty'], ['implements BeanProperty, java.io.Serializable // since 2.6.2 private static final long serialVersionUID = 4603296144163950020L;'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java']
['JacksonDatabind-27', 1, 1, 1, 1, ["// first: let's check to see if this might be part of value with external type id: // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null, // since it is not the bean if (ext.handlePropertyValue(p, ctxt, propName, buffer)) { ; } else { // Last creator property to set?"], ["// first: let's check to see if this might be part of value with external type id: // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null, // since it is not the bean if (ext.handlePropertyValue(p, ctxt, propName, null)) { ; } else { // Last creator property to set?"], ['if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {'], ['if (ext.handlePropertyValue(p, ctxt, propName, null)) {'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java']
['JacksonDatabind-28', 1, 1, 1, 1, ['@Override public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.getCurrentToken() == JsonToken.START_OBJECT) { p.nextToken(); return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.getCurrentToken() == JsonToken.FIELD_NAME) { return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } throw ctxt.mappingException(ObjectNode.class); }'], ['@Override public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) { return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.hasToken(JsonToken.END_OBJECT)) { return ctxt.getNodeFactory().objectNode(); } throw ctxt.mappingException(ObjectNode.class); }'], ['if (p.getCurrentToken() == JsonToken.START_OBJECT) { p.nextToken(); if (p.getCurrentToken() == JsonToken.FIELD_NAME) { return deserializeObject(p, ctxt, ctxt.getNodeFactory());'], ['if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) { if (p.hasToken(JsonToken.END_OBJECT)) { return ctxt.getNodeFactory().objectNode();'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java']
['JacksonDatabind-29', 2, 2, 2, 2, ['JsonParser p2 = _tokens[index].asParser(p); JsonToken t = p2.nextToken(); // 29-Sep-2015, tatu: As per [databind#942], nulls need special support TokenBuffer merged = new TokenBuffer(p); merged.writeStartArray();', 'JsonParser p2 = _tokens[index].asParser(p); JsonToken t = p2.nextToken(); // 29-Sep-2015, tatu: As per [databind#942], nulls need special support TokenBuffer merged = new TokenBuffer(p); merged.writeStartArray(); merged.writeString(typeId);'], ['JsonParser p2 = _tokens[index].asParser(p); JsonToken t = p2.nextToken(); // 29-Sep-2015, tatu: As per [databind#942], nulls need special support if (t == JsonToken.VALUE_NULL) { return null; } TokenBuffer merged = new TokenBuffer(p); merged.writeStartArray();', 'JsonParser p2 = _tokens[index].asParser(p); JsonToken t = p2.nextToken(); // 29-Sep-2015, tatu: As per [databind#942], nulls need special support if (t == JsonToken.VALUE_NULL) { _properties[index].getProperty().set(bean, null); return; } TokenBuffer merged = new TokenBuffer(p); merged.writeStartArray(); merged.writeString(typeId);'], ['', ''], ['if (t == JsonToken.VALUE_NULL) { return null; }', 'if (t == JsonToken.VALUE_NULL) { _properties[index].getProperty().set(bean, null); return; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java']
['JacksonDatabind-30', 6, 6, 6, 6, ['{ if (fromValue == null) return null; TokenBuffer buf = new TokenBuffer(this, false); JsonNode result; try { writeValue(buf, fromValue);', " // Then use TokenBuffer, which is a JsonGenerator: TokenBuffer buf = new TokenBuffer(this, false); try { // inlined 'writeValue' with minor changes: // first: disable wrapping when writing", '* * @since 2.7 */ /* /**********************************************************', '_hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; } /** * @since 2.7 */ @Override public Version version() {', '} break; case VALUE_NUMBER_FLOAT: /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying * number is already decoded into a number (in which case might as well * access as number); or is still retained as text (in which case we * should further defer decoding that may not need BigDecimal): */ switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue());', 'break; default: writeNumber(p.getDoubleValue()); } break; case VALUE_TRUE:'], ['{ if (fromValue == null) return null; TokenBuffer buf = new TokenBuffer(this, false); if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); } JsonNode result; try { writeValue(buf, fromValue);', " // Then use TokenBuffer, which is a JsonGenerator: TokenBuffer buf = new TokenBuffer(this, false); if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); } try { // inlined 'writeValue' with minor changes: // first: disable wrapping when writing", '* * @since 2.7 */ protected boolean _forceBigDecimal; /* /**********************************************************', '_hasNativeTypeIds = p.canReadTypeId(); _hasNativeObjectIds = p.canReadObjectId(); _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds; _forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); } /** * @since 2.7 */ public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; } @Override public Version version() {', '} break; case VALUE_NUMBER_FLOAT: if (_forceBigDecimal) { /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying * number is already decoded into a number (in which case might as well * access as number); or is still retained as text (in which case we * should further defer decoding that may not need BigDecimal): */ writeNumber(p.getDecimalValue()); } else { switch (p.getNumberType()) { case BIG_DECIMAL: writeNumber(p.getDecimalValue());', 'break; default: writeNumber(p.getDoubleValue()); } } break; case VALUE_TRUE:'], ['', '', '', '', '', ''], ['if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); }', 'if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { buf = buf.forceUseOfBigDecimal(true); }', 'protected boolean _forceBigDecimal;', '_forceBigDecimal = (ctxt == null) ? false : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); public TokenBuffer forceUseOfBigDecimal(boolean b) { _forceBigDecimal = b; return this; }', 'if (_forceBigDecimal) { writeNumber(p.getDecimalValue()); } else {', '}'], 'a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java']
['JacksonDatabind-31', 13, 13, 13, 13, ['if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }', 'if (text == null) { writeNull(); } else { _append(JsonToken.VALUE_STRING, text); } }', ' @Override public void writeRawValue(String text) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override', 'if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } /*', ' @Override public void writeNumber(short i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override', 'if (dec == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_FLOAT, dec); } }', 'if (v == null) { writeNull(); } else { _append(JsonToken.VALUE_NUMBER_INT, v); } }', '/* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric * identity as long as possible */ _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _append(JsonToken.VALUE_NULL); } /*', '} Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) {', '* err out, or just embed? For now, do latter. */ // throw new JsonMappingException("No ObjectCodec configured for TokenBuffer, writeObject() called"); _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); }', " if (_objectCodec == null) { // as with 'writeObject()', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); }", '* * @since 2.6.4 */ /** * Similar to {@link #_append(JsonToken,Object)} but also updates context with', '* * @since 2.6.4 */ protected final void _appendRaw(int rawType, Object value) {'], ['if (text == null) { writeNull(); } else { _appendValue(JsonToken.VALUE_STRING, text); } }', 'if (text == null) { writeNull(); } else { _appendValue(JsonToken.VALUE_STRING, text); } }', ' @Override public void writeRawValue(String text) throws IOException { _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override', 'if (offset > 0 || len != text.length()) { text = text.substring(offset, offset+len); } _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len)); } /*', ' @Override public void writeNumber(short i) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); } @Override public void writeNumber(int i) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); } @Override public void writeNumber(long l) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); } @Override public void writeNumber(double d) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); } @Override', 'if (dec == null) { writeNull(); } else { _appendValue(JsonToken.VALUE_NUMBER_FLOAT, dec); } }', 'if (v == null) { writeNull(); } else { _appendValue(JsonToken.VALUE_NUMBER_INT, v); } }', '/* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric * identity as long as possible */ _appendValue(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); } @Override public void writeBoolean(boolean state) throws IOException { _appendValue(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); } @Override public void writeNull() throws IOException { _appendValue(JsonToken.VALUE_NULL); } /*', '} Class<?> raw = value.getClass(); if (raw == byte[].class || (value instanceof RawValue)) { _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } if (_objectCodec == null) {', '* err out, or just embed? For now, do latter. */ // throw new JsonMappingException("No ObjectCodec configured for TokenBuffer, writeObject() called"); _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); }', " if (_objectCodec == null) { // as with 'writeObject()', is codec optional? _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); }", '* * @since 2.6.4 */ protected final void _appendValue(JsonToken type) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } } /** * Similar to {@link #_append(JsonToken,Object)} but also updates context with', '* * @since 2.6.4 */ protected final void _appendValue(JsonToken type, Object value) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } } protected final void _appendRaw(int rawType, Object value) {'], ['_append(JsonToken.VALUE_STRING, text);', '_append(JsonToken.VALUE_STRING, text);', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));', '_append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));', '_append(JsonToken.VALUE_NUMBER_FLOAT, dec);', '_append(JsonToken.VALUE_NUMBER_INT, v);', '_append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); _append(JsonToken.VALUE_NULL);', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, value);', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, value);', '_append(JsonToken.VALUE_EMBEDDED_OBJECT, node);', '', ''], ['_appendValue(JsonToken.VALUE_STRING, text);', '_appendValue(JsonToken.VALUE_STRING, text);', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text)); _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));', '_appendValue(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); _appendValue(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); _appendValue(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));', '_appendValue(JsonToken.VALUE_NUMBER_FLOAT, dec);', '_appendValue(JsonToken.VALUE_NUMBER_INT, v);', '_appendValue(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); _appendValue(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); _appendValue(JsonToken.VALUE_NULL);', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);', '_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, node);', 'protected final void _appendValue(JsonToken type) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, _objectId, _typeId) : _last.append(_appendAt, type); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; // since we added first at 0 } }', 'protected final void _appendValue(JsonToken type, Object value) { _writeContext.writeValue(); Segment next = _hasNativeId ? _last.append(_appendAt, type, value, _objectId, _typeId) : _last.append(_appendAt, type, value); if (next == null) { ++_appendAt; } else { _last = next; _appendAt = 1; } }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java']
['JacksonDatabind-32', 2, 2, 2, 2, ['case JsonTokenId.ID_FIELD_NAME: // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (_mapDeserializer != null) { return _mapDeserializer.deserialize(p, ctxt); }', 'case JsonTokenId.ID_NULL: // should not get this but... return null; // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object //case JsonTokenId.ID_END_ARRAY: // invalid default:'], ['case JsonTokenId.ID_FIELD_NAME: // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object case JsonTokenId.ID_END_OBJECT: if (_mapDeserializer != null) { return _mapDeserializer.deserialize(p, ctxt); }', 'case JsonTokenId.ID_NULL: // should not get this but... return null; case JsonTokenId.ID_END_OBJECT: // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object return new LinkedHashMap<String,Object>(2); //case JsonTokenId.ID_END_ARRAY: // invalid default:'], ['', ''], ['case JsonTokenId.ID_END_OBJECT:', 'case JsonTokenId.ID_END_OBJECT: return new LinkedHashMap<String,Object>(2);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java']
['JacksonDatabind-33', 1, 1, 1, 1, ['*/ } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) || _hasAnnotation(a, JsonRawValue.class)) { name = ""; } else { return null;'], ['*/ } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) || _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonUnwrapped.class) || _hasAnnotation(a, JsonBackReference.class) || _hasAnnotation(a, JsonManagedReference.class)) { name = ""; } else { return null;'], ['|| _hasAnnotation(a, JsonRawValue.class)) {'], ['|| _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonUnwrapped.class) || _hasAnnotation(a, JsonBackReference.class) || _hasAnnotation(a, JsonManagedReference.class)) {'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java']
['JacksonDatabind-34', 1, 1, 1, 1, ["} else { Class<?> h = handledType(); if (h == BigDecimal.class) { visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { // otherwise bit unclear what to call... but let's try: /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);"], ["} else { Class<?> h = handledType(); if (h == BigDecimal.class) { visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL); } else { // otherwise bit unclear what to call... but let's try: /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);"], ['visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);'], ['visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java']
['JacksonDatabind-35', 1, 1, 1, 1, ['} } // first, sanity checks if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName()); } // should always get field name, but just in case... if (p.nextToken() != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of "+baseTypeName()+")"); } final String typeId = p.getText(); JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); p.nextToken();'], ['} } // first, sanity checks JsonToken t = p.getCurrentToken(); if (t == JsonToken.START_OBJECT) { // should always get field name, but just in case... if (p.nextToken() != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of "+baseTypeName()+")"); } } else if (t != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName()); } final String typeId = p.getText(); JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); p.nextToken();'], ['if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName()); }'], ['JsonToken t = p.getCurrentToken(); if (t == JsonToken.START_OBJECT) { } else if (t != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName()); }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java']
['JacksonDatabind-36', 2, 2, 2, 2, ['* and not via underlying {@link Calendar} instance like base class * does. */ // and since leniency settings may have been used: @Override // since 2.7 public boolean isLenient() {', 'df.setTimeZone(tz); } } return df; }'], ['* and not via underlying {@link Calendar} instance like base class * does. */ @Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; // and since leniency settings may have been used: _clearFormats(); } } @Override // since 2.7 public boolean isLenient() {', 'df.setTimeZone(tz); } } if (lenient != null) { df.setLenient(lenient.booleanValue()); } return df; }'], ['', ''], ['@Override // since 2.7 public void setLenient(boolean enabled) { Boolean newValue = enabled; if (_lenient != newValue) { _lenient = newValue; _clearFormats(); } }', 'if (lenient != null) { df.setLenient(lenient.booleanValue()); }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java']
['JacksonDatabind-37', 1, 1, 1, 1, ['} */ // 15-Jan-2015, tatu: Not correct; should really re-resolve... return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic); }'], ['} */ // 15-Jan-2015, tatu: Not correct; should really re-resolve... return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); }'], ['return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,'], ['return new SimpleType(subclass, _bindings, this, _superInterfaces,'], 'a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java']
['JacksonDatabind-38', 6, 6, 6, 6, ['package com.fasterxml.jackson.databind.type; import com.fasterxml.jackson.databind.JavaType;', 'public static CollectionType construct(Class<?> rawType, JavaType elemT) { // First: may need to fabricate TypeBindings (needed for refining into // concrete collection types, as per [databind#1102]) return new CollectionType(rawType, null, // !!! TODO: Wrong, does have supertypes, but: _bogusSuperClass(rawType), null, elemT, null, null, false);', 'package com.fasterxml.jackson.databind.type; import com.fasterxml.jackson.databind.JavaType;', '{ // First: may need to fabricate TypeBindings (needed for refining into // concrete collection types, as per [databind#1102]) // !!! TODO: Wrong, does have supertypes return new MapType(rawType, null, _bogusSuperClass(rawType), null, keyT, valueT, null, null, false); }', 'if (cls.isArray()) { throw new IllegalArgumentException("Can not construct SimpleType for an array (class: "+cls.getName()+")"); } return new SimpleType(cls, TypeBindings.emptyBindings(), _bogusSuperClass(cls), null, null, null, false); } @Override', '* * @since 2.7 -- remove when not needed (2.8?) */ /* /**********************************************************'], ['package com.fasterxml.jackson.databind.type; import java.lang.reflect.TypeVariable; import com.fasterxml.jackson.databind.JavaType;', 'public static CollectionType construct(Class<?> rawType, JavaType elemT) { // First: may need to fabricate TypeBindings (needed for refining into // concrete collection types, as per [databind#1102]) TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 1)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, elemT); } return new CollectionType(rawType, bindings, // !!! TODO: Wrong, does have supertypes, but: _bogusSuperClass(rawType), null, elemT, null, null, false);', 'package com.fasterxml.jackson.databind.type; import java.lang.reflect.TypeVariable; import com.fasterxml.jackson.databind.JavaType;', '{ // First: may need to fabricate TypeBindings (needed for refining into // concrete collection types, as per [databind#1102]) TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 2)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, keyT, valueT); } // !!! TODO: Wrong, does have supertypes return new MapType(rawType, bindings, _bogusSuperClass(rawType), null, keyT, valueT, null, null, false); }', 'if (cls.isArray()) { throw new IllegalArgumentException("Can not construct SimpleType for an array (class: "+cls.getName()+")"); } TypeBindings b = TypeBindings.emptyBindings(); return new SimpleType(cls, b, _buildSuperClass(cls.getSuperclass(), b), null, null, null, false); } @Override', '* * @since 2.7 -- remove when not needed (2.8?) */ private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b) { if (superClass == null) { return null; } if (superClass == Object.class) { return TypeFactory.unknownType(); } JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b); return new SimpleType(superClass, b, superSuper, null, null, null, false); } /* /**********************************************************'], ['', 'return new CollectionType(rawType, null,', '', 'return new MapType(rawType, null, _bogusSuperClass(rawType), null,', 'return new SimpleType(cls, TypeBindings.emptyBindings(), _bogusSuperClass(cls), null, null, null, false);', ''], ['import java.lang.reflect.TypeVariable;', 'TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 1)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, elemT); } return new CollectionType(rawType, bindings,', 'import java.lang.reflect.TypeVariable;', 'TypeVariable<?>[] vars = rawType.getTypeParameters(); TypeBindings bindings; if ((vars == null) || (vars.length != 2)) { bindings = TypeBindings.emptyBindings(); } else { bindings = TypeBindings.create(rawType, keyT, valueT); } return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,', 'TypeBindings b = TypeBindings.emptyBindings(); return new SimpleType(cls, b, _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);', 'private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b) { if (superClass == null) { return null; } if (superClass == Object.class) { return TypeFactory.unknownType(); } JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b); return new SimpleType(superClass, b, superSuper, null, null, null, false); }'], 'a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java']
['JacksonDatabind-39', 1, 1, 1, 1, ['{ // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit // special unfortunately p.skipChildren(); return null; }'], ['{ // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit // special unfortunately if (p.hasToken(JsonToken.FIELD_NAME)) { while (true) { JsonToken t = p.nextToken(); if ((t == null) || (t == JsonToken.END_OBJECT)) { break; } p.skipChildren(); } } else { p.skipChildren(); } return null; }'], [''], ['if (p.hasToken(JsonToken.FIELD_NAME)) { while (true) { JsonToken t = p.nextToken(); if ((t == null) || (t == JsonToken.END_OBJECT)) { break; } p.skipChildren(); } } else { }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java']
['JacksonDatabind-40', 1, 1, 1, 1, ['return _nullValue; } // [databind#1095]: Should not allow coercion from into null from Empty String // either, if `null` not allowed } /*'], ['return _nullValue; } @Override public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException { // [databind#1095]: Should not allow coercion from into null from Empty String // either, if `null` not allowed if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { throw ctxt.mappingException( "Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to \'false\' to allow)", handledType().toString()); } return _nullValue; } } /*'], [''], ['@Override public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException { if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { throw ctxt.mappingException( "Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to \'false\' to allow)", handledType().toString()); } return _nullValue; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java']
['JacksonDatabind-41', 2, 2, 2, 2, ['*/ @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { return constructType(type, constructType(contextClass)); } /**', '*/ @Deprecated public JavaType constructType(Type type, JavaType contextType) { return _fromAny(null, type, contextType.getBindings()); } /*'], ['*/ @Deprecated public JavaType constructType(Type type, Class<?> contextClass) { TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } /**', '*/ @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings); } /*'], ['return constructType(type, constructType(contextClass));', 'return _fromAny(null, type, contextType.getBindings());'], ['TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings);', 'TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings);'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-42', 1, 1, 1, 1, ['return URI.create(""); } // As per [databind#1123], Locale too return super._deserializeFromEmptyString(); } }'], ['return URI.create(""); } // As per [databind#1123], Locale too if (_kind == STD_LOCALE) { return Locale.ROOT; } return super._deserializeFromEmptyString(); } }'], [''], ['if (_kind == STD_LOCALE) { return Locale.ROOT; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java']
['JacksonDatabind-43', 2, 2, 2, 2, ['import java.lang.annotation.Annotation; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.*; import com.fasterxml.jackson.databind.introspect.AnnotatedMember;', 'public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException { Object id = _valueDeserializer.deserialize(p, ctxt); /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be; * missing or null id is needed for some cases, such as cases where id * will be generated externally, at a later point, and is not available * quite yet. Typical use case is with DB inserts. */ // note: no null checks (unlike usually); deserializer should fail if one found if (id == null) { return null; } ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance); // also: may need to set a property value as well'], ['import java.lang.annotation.Annotation; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonToken; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.*; import com.fasterxml.jackson.databind.introspect.AnnotatedMember;', 'public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException { /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be; * missing or null id is needed for some cases, such as cases where id * will be generated externally, at a later point, and is not available * quite yet. Typical use case is with DB inserts. */ // note: no null checks (unlike usually); deserializer should fail if one found if (p.hasToken(JsonToken.VALUE_NULL)) { return null; } Object id = _valueDeserializer.deserialize(p, ctxt); ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance); // also: may need to set a property value as well'], ['', 'Object id = _valueDeserializer.deserialize(p, ctxt); if (id == null) {'], ['import com.fasterxml.jackson.core.JsonToken;', 'if (p.hasToken(JsonToken.VALUE_NULL)) { Object id = _valueDeserializer.deserialize(p, ctxt);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java']
['JacksonDatabind-44', 1, 1, 1, 1, ['// 15-Jan-2016, tatu: Almost yes, but there are some complications with // placeholder values (`Void`, `NoClass`), so can not quite do yet. // TODO: fix in 2.8 /* throw new IllegalArgumentException("Class "+subclass.getName()+" not sub-type of " +_class.getName()); */ return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); // Otherwise, stitch together the hierarchy. First, super-class // if not found, try a super-interface // should not get here but... } @Override'], ['// 15-Jan-2016, tatu: Almost yes, but there are some complications with // placeholder values (`Void`, `NoClass`), so can not quite do yet. // TODO: fix in 2.8 if (!_class.isAssignableFrom(subclass)) { /* throw new IllegalArgumentException("Class "+subclass.getName()+" not sub-type of " +_class.getName()); */ return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } // Otherwise, stitch together the hierarchy. First, super-class Class<?> next = subclass.getSuperclass(); if (next == _class) { // straight up parent class? Great. return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } if ((next != null) && _class.isAssignableFrom(next)) { JavaType superb = _narrow(next); return new SimpleType(subclass, _bindings, superb, null, _valueHandler, _typeHandler, _asStatic); } // if not found, try a super-interface Class<?>[] nextI = subclass.getInterfaces(); for (Class<?> iface : nextI) { if (iface == _class) { // directly implemented return new SimpleType(subclass, _bindings, null, new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic); } if (_class.isAssignableFrom(iface)) { // indirect, so recurse JavaType superb = _narrow(iface); return new SimpleType(subclass, _bindings, null, new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic); } } // should not get here but... throw new IllegalArgumentException("Internal error: Can not resolve sub-type for Class "+subclass.getName()+" to " +_class.getName()); } @Override'], [''], ['if (!_class.isAssignableFrom(subclass)) { } Class<?> next = subclass.getSuperclass(); if (next == _class) { // straight up parent class? Great. return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } if ((next != null) && _class.isAssignableFrom(next)) { JavaType superb = _narrow(next); return new SimpleType(subclass, _bindings, superb, null, _valueHandler, _typeHandler, _asStatic); } Class<?>[] nextI = subclass.getInterfaces(); for (Class<?> iface : nextI) { if (iface == _class) { // directly implemented return new SimpleType(subclass, _bindings, null, new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic); } if (_class.isAssignableFrom(iface)) { // indirect, so recurse JavaType superb = _narrow(iface); return new SimpleType(subclass, _bindings, null, new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic); } } throw new IllegalArgumentException("Internal error: Can not resolve sub-type for Class "+subclass.getName()+" to " +_class.getName());'], 'a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java']
['JacksonDatabind-45', 1, 1, 1, 1, ['return withFormat(Boolean.TRUE, null); } if (format.getShape() == JsonFormat.Shape.STRING) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern()'], ['return withFormat(Boolean.TRUE, null); } if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern()'], ['if (format.getShape() == JsonFormat.Shape.STRING) {'], ['if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java']
['JacksonDatabind-46', 1, 1, 1, 1, ["_classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); sb.append(';'); return sb; }"], ['_classSignature(_class, sb, false); sb.append(\'<\'); sb = _referencedType.getGenericSignature(sb); sb.append(">;"); return sb; }'], ["sb.append(';');"], ['sb.append(">;");'], 'a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java']
['JacksonDatabind-47', 1, 1, 1, 1, ['// static typing this way type = type.withStaticTyping(); } else { try { // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`, // may be needed here too in future? type = tf.constructGeneralizedType(type, serClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format("Failed to widen type %s with annotation (value %s), from \'%s\': %s",'], ['// static typing this way type = type.withStaticTyping(); } else { Class<?> currRaw = type.getRawClass(); try { // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`, // may be needed here too in future? if (serClass.isAssignableFrom(currRaw)) { // common case type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else { throw new JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related", type, serClass.getName())); } } catch (IllegalArgumentException iae) { throw new JsonMappingException(null, String.format("Failed to widen type %s with annotation (value %s), from \'%s\': %s",'], [''], ['Class<?> currRaw = type.getRawClass(); if (serClass.isAssignableFrom(currRaw)) { // common case } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else { throw new JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related", type, serClass.getName())); }'], 'a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java', 'b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java']
['JacksonDatabind-48', 2, 2, 2, 2, ['if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { vchecker = vchecker.withCreatorVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { vchecker = vchecker.withFieldVisibility(Visibility.NONE); }', '{ VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); // then global overrides (disabling) if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { vchecker = vchecker.withGetterVisibility(Visibility.NONE); }'], ['if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { vchecker = vchecker.withCreatorVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { vchecker = vchecker.withGetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { vchecker = vchecker.withFieldVisibility(Visibility.NONE); }', '{ VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); // then global overrides (disabling) if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { vchecker = vchecker.withSetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { vchecker = vchecker.withCreatorVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { vchecker = vchecker.withGetterVisibility(Visibility.NONE); }'], ['', ''], ['if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { vchecker = vchecker.withGetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); }', 'if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { vchecker = vchecker.withSetterVisibility(Visibility.NONE); } if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { vchecker = vchecker.withCreatorVisibility(Visibility.NONE); }'], 'a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java', 'b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java']
['JacksonDatabind-49', 1, 1, 1, 1, ['// 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of // id being generated for "alwaysAsId", but not being written as POJO; regardless, // need to use existing id if there is one: id = generator.generateId(forPojo); return id; }'], ['// 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of // id being generated for "alwaysAsId", but not being written as POJO; regardless, // need to use existing id if there is one: if (id == null) { id = generator.generateId(forPojo); } return id; }'], [''], ['if (id == null) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java']
['JacksonDatabind-50', 6, 6, 6, 6, ['import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.impl.*; import com.fasterxml.jackson.databind.util.NameTransformer; import com.fasterxml.jackson.databind.util.TokenBuffer;', 'TokenBuffer unknown = null; JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); // to point to value', '// regular property? needs buffering SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop)); // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional // handling of forward references here. Not exactly sure why existing // facilities did not cover, but this does appear to solve the problem continue; } // Things marked as ignorable should not be passed to any setter', 'wrapInstantiationProblem(e, ctxt); bean = null; // never gets here } if (unknown != null) { // polymorphic? if (bean.getClass() != _beanType.getRawClass()) {', '/** * @since 2.8 */ protected final Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt, SettableBeanProperty prop)', '/** * @since 2.8 */ }'], ['import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.impl.*; import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring; import com.fasterxml.jackson.databind.util.NameTransformer; import com.fasterxml.jackson.databind.util.TokenBuffer;', 'TokenBuffer unknown = null; JsonToken t = p.getCurrentToken(); List<BeanReferring> referrings = null; for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); // to point to value', '// regular property? needs buffering SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { try { buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop)); } catch (UnresolvedForwardReference reference) { // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional // handling of forward references here. Not exactly sure why existing // facilities did not cover, but this does appear to solve the problem BeanReferring referring = handleUnresolvedReference(p, prop, buffer, reference); if (referrings == null) { referrings = new ArrayList<BeanReferring>(); } referrings.add(referring); } continue; } // Things marked as ignorable should not be passed to any setter', 'wrapInstantiationProblem(e, ctxt); bean = null; // never gets here } if (referrings != null) { for (BeanReferring referring : referrings) { referring.setBean(bean); } } if (unknown != null) { // polymorphic? if (bean.getClass() != _beanType.getRawClass()) {', '/** * @since 2.8 */ private BeanReferring handleUnresolvedReference(JsonParser p, SettableBeanProperty prop, PropertyValueBuffer buffer, UnresolvedForwardReference reference) throws JsonMappingException { BeanReferring referring = new BeanReferring(reference, prop.getType().getRawClass(), buffer, prop); reference.getRoid().appendReferring(referring); return referring; } protected final Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt, SettableBeanProperty prop)', '/** * @since 2.8 */ static class BeanReferring extends Referring { private final SettableBeanProperty _prop; private Object _bean; public void setBean(Object bean) { _bean = bean; } BeanReferring(UnresolvedForwardReference ref, Class<?> valueType, PropertyValueBuffer buffer, SettableBeanProperty prop) { super(ref, valueType); _prop = prop; } @Override public void handleResolvedForwardReference(Object id, Object value) throws IOException { _prop.set(_bean, value); } } }'], ['', '', '', '', '', ''], ['import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;', 'List<BeanReferring> referrings = null;', 'try { } catch (UnresolvedForwardReference reference) { BeanReferring referring = handleUnresolvedReference(p, prop, buffer, reference); if (referrings == null) { referrings = new ArrayList<BeanReferring>(); } referrings.add(referring); }', 'if (referrings != null) { for (BeanReferring referring : referrings) { referring.setBean(bean); } }', 'private BeanReferring handleUnresolvedReference(JsonParser p, SettableBeanProperty prop, PropertyValueBuffer buffer, UnresolvedForwardReference reference) throws JsonMappingException { BeanReferring referring = new BeanReferring(reference, prop.getType().getRawClass(), buffer, prop); reference.getRoid().appendReferring(referring); return referring; }', 'static class BeanReferring extends Referring { private final SettableBeanProperty _prop; private Object _bean; public void setBean(Object bean) { _bean = bean; } BeanReferring(UnresolvedForwardReference ref, Class<?> valueType, PropertyValueBuffer buffer, SettableBeanProperty prop) { super(ref, valueType); _prop = prop; } @Override public void handleResolvedForwardReference(Object id, Object value) throws IOException { _prop.set(_bean, value); } }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java']
['JacksonDatabind-51', 1, 1, 1, 1, ['// generic type with custom type resolvers. If so, should try to retain them. // Whether this is sufficient to avoid problems remains to be seen, but for // now it should improve things. type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(type, _property); }'], ['// generic type with custom type resolvers. If so, should try to retain them. // Whether this is sufficient to avoid problems remains to be seen, but for // now it should improve things. if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); }'], [''], ['if (!type.hasGenericTypes()) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java']
['JacksonDatabind-52', 2, 2, 2, 2, ['if (extTypes != null) { // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too, // so need to pass collected properties _externalTypeIdHandler = extTypes.build(); // we consider this non-standard, to offline handling _nonStandardCreation = true; }', '* * @since 2.8 */ // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also @Deprecated // since 2.8; may be removed as early as 2.9 public ExternalTypeHandler build() {'], ['if (extTypes != null) { // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too, // so need to pass collected properties _externalTypeIdHandler = extTypes.build(_beanProperties); // we consider this non-standard, to offline handling _nonStandardCreation = true; }', '* * @since 2.8 */ public ExternalTypeHandler build(BeanPropertyMap otherProps) { // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also final int len = _properties.size(); ExtTypedProperty[] extProps = new ExtTypedProperty[len]; for (int i = 0; i < len; ++i) { ExtTypedProperty extProp = _properties.get(i); String typePropId = extProp.getTypePropertyName(); SettableBeanProperty typeProp = otherProps.find(typePropId); if (typeProp != null) { extProp.linkTypeProperty(typeProp); } extProps[i] = extProp; } return new ExternalTypeHandler(extProps, _nameToPropertyIndex, null, null); } @Deprecated // since 2.8; may be removed as early as 2.9 public ExternalTypeHandler build() {'], ['_externalTypeIdHandler = extTypes.build();', ''], ['_externalTypeIdHandler = extTypes.build(_beanProperties);', 'public ExternalTypeHandler build(BeanPropertyMap otherProps) { final int len = _properties.size(); ExtTypedProperty[] extProps = new ExtTypedProperty[len]; for (int i = 0; i < len; ++i) { ExtTypedProperty extProp = _properties.get(i); String typePropId = extProp.getTypePropertyName(); SettableBeanProperty typeProp = otherProps.find(typePropId); if (typeProp != null) { extProp.linkTypeProperty(typeProp); } extProps[i] = extProp; } return new ExternalTypeHandler(extProps, _nameToPropertyIndex, null, null); }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java']
['JacksonDatabind-53', 7, 7, 7, 7, ['* * @since 2.8 */ // safe to pass _types array without copy since it is not exposed via // any access, nor modified by this class /* /**********************************************************************', '* * @since 2.8 */ }', '* actual generic types), we will use small cache to avoid repetitive * resolution of core types */ protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100); /* /**********************************************************', "// for a case where this code does get invoked: not ideal // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but // not certain it would reliably work... but let's hope for best for now if (baseType.isInterface()) { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); } // Only SimpleType returns null, but if so just resolve regularly if (newType == null) { TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb); } } while (false);", '*/ } // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy // (hopefully passing null Class for root is ok) // Otherwise, two choices: match N first, or empty. Do latter, for now /** * Method similar to {@link #constructSpecializedType}, but that creates a', 'return result; } // Barring that, we may have recently constructed an instance boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType); if (result != null) { return result; } } // 15-Oct-2015, tatu: recursive reference?', '} } context.resolveSelfReferences(result); if (cachable) { _typeCache.putIfAbsent(rawType, result); } return result; }'], ['* * @since 2.8 */ public Object asKey(Class<?> rawBase) { // safe to pass _types array without copy since it is not exposed via // any access, nor modified by this class return new AsKey(rawBase, _types, _hashCode); } /* /**********************************************************************', '* * @since 2.8 */ final static class AsKey { private final Class<?> _raw; private final JavaType[] _params; private final int _hash; public AsKey(Class<?> raw, JavaType[] params, int hash) { _raw = raw ; _params = params; _hash = hash; } @Override public int hashCode() { return _hash; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != getClass()) return false; AsKey other = (AsKey) o; if ((_hash == other._hash) && (_raw == other._raw)) { final JavaType[] otherParams = other._params; final int len = _params.length; if (len == otherParams.length) { for (int i = 0; i < len; ++i) { if (!_params[i].equals(otherParams[i])) { return false; } } return true; } } return false; } @Override public String toString() { return _raw.getName()+"<>"; } } }', '* actual generic types), we will use small cache to avoid repetitive * resolution of core types */ protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100); /* /**********************************************************', "// for a case where this code does get invoked: not ideal // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but // not certain it would reliably work... but let's hope for best for now TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass); if (baseType.isInterface()) { newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType }); } else { newType = baseType.refine(subclass, tb, baseType, NO_TYPES); } // Only SimpleType returns null, but if so just resolve regularly if (newType == null) { newType = _fromClass(null, subclass, tb); } } while (false);", '*/ } private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) { // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy // (hopefully passing null Class for root is ok) int baseCount = baseType.containedTypeCount(); if (baseCount == typeParamCount) { if (typeParamCount == 1) { return TypeBindings.create(subclass, baseType.containedType(0)); } if (typeParamCount == 2) { return TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } List<JavaType> types = new ArrayList<JavaType>(baseCount); for (int i = 0; i < baseCount; ++i) { types.add(baseType.containedType(i)); } return TypeBindings.create(subclass, types); } // Otherwise, two choices: match N first, or empty. Do latter, for now return TypeBindings.emptyBindings(); } /** * Method similar to {@link #constructSpecializedType}, but that creates a', 'return result; } // Barring that, we may have recently constructed an instance final Object key; if ((bindings == null) || bindings.isEmpty()) { key = rawType; result = _typeCache.get(key); // ok, cache object is synced } else { key = bindings.asKey(rawType); } result = _typeCache.get(key); // ok, cache object is synced if (result != null) { return result; } // 15-Oct-2015, tatu: recursive reference?', '} } context.resolveSelfReferences(result); _typeCache.putIfAbsent(key, result); // cache object syncs return result; }'], ['', '', 'protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);', 'newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType }); newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES); TypeBindings tb = null; if (baseType.containedTypeCount() == typeParamCount) { if (typeParamCount == 1) { tb = TypeBindings.create(subclass, baseType.containedType(0)); } else if (typeParamCount == 2) { tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } } newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);', '', 'boolean cachable = (bindings == null) || bindings.isEmpty(); if (cachable) { result = _typeCache.get(rawType); }', 'if (cachable) { _typeCache.putIfAbsent(rawType, result); }'], ['public Object asKey(Class<?> rawBase) { return new AsKey(rawBase, _types, _hashCode); }', 'final static class AsKey { private final Class<?> _raw; private final JavaType[] _params; private final int _hash; public AsKey(Class<?> raw, JavaType[] params, int hash) { _raw = raw ; _params = params; _hash = hash; } @Override public int hashCode() { return _hash; } @Override public boolean equals(Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != getClass()) return false; AsKey other = (AsKey) o; if ((_hash == other._hash) && (_raw == other._raw)) { final JavaType[] otherParams = other._params; final int len = _params.length; if (len == otherParams.length) { for (int i = 0; i < len; ++i) { if (!_params[i].equals(otherParams[i])) { return false; } } return true; } } return false; } @Override public String toString() { return _raw.getName()+"<>"; } }', 'protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100);', 'TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass); newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType }); newType = baseType.refine(subclass, tb, baseType, NO_TYPES); newType = _fromClass(null, subclass, tb);', 'private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass) { int baseCount = baseType.containedTypeCount(); if (baseCount == typeParamCount) { if (typeParamCount == 1) { return TypeBindings.create(subclass, baseType.containedType(0)); } if (typeParamCount == 2) { return TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1)); } List<JavaType> types = new ArrayList<JavaType>(baseCount); for (int i = 0; i < baseCount; ++i) { types.add(baseType.containedType(i)); } return TypeBindings.create(subclass, types); } return TypeBindings.emptyBindings(); }', 'final Object key; if ((bindings == null) || bindings.isEmpty()) { key = rawType; result = _typeCache.get(key); // ok, cache object is synced } else { key = bindings.asKey(rawType); } result = _typeCache.get(key); // ok, cache object is synced', '_typeCache.putIfAbsent(key, result); // cache object syncs'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-54', 2, 2, 2, 2, ['// always suppress nulls suppressNulls = true; // and for referential types, also "empty", which in their case means "absent" if (declaredType.isReferenceType()) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; } break;', 'case ALWAYS: // default default: // we may still want to suppress empty collections, as per [JACKSON-254]: if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; }'], ['// always suppress nulls suppressNulls = true; // and for referential types, also "empty", which in their case means "absent" if (actualType.isReferenceType()) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; } break;', 'case ALWAYS: // default default: // we may still want to suppress empty collections, as per [JACKSON-254]: if (actualType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; }'], ['if (declaredType.isReferenceType()) {', 'if (declaredType.isContainerType()'], ['if (actualType.isReferenceType()) {', 'if (actualType.isContainerType()'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java']
['JacksonDatabind-55', 3, 3, 3, 3, ['import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap; @SuppressWarnings("serial") public class StdKeySerializers', 'return new Dynamic(); } if (rawKeyType.isEnum()) { return new Default(Default.TYPE_ENUM, rawKeyType); } } return DEFAULT_KEY_SERIALIZER;', '* * @since 2.8 */ }'], ['import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap; import com.fasterxml.jackson.databind.util.EnumValues; @SuppressWarnings("serial") public class StdKeySerializers', 'return new Dynamic(); } if (rawKeyType.isEnum()) { return EnumKeySerializer.construct(rawKeyType, EnumValues.constructFromName(config, (Class<Enum<?>>) rawKeyType)); } } return DEFAULT_KEY_SERIALIZER;', '* * @since 2.8 */ public static class EnumKeySerializer extends StdSerializer<Object> { protected final EnumValues _values; protected EnumKeySerializer(Class<?> enumType, EnumValues values) { super(enumType, false); _values = values; } public static EnumKeySerializer construct(Class<?> enumType, EnumValues enumValues) { return new EnumKeySerializer(enumType, enumValues); } @Override public void serialize(Object value, JsonGenerator g, SerializerProvider serializers) throws IOException { if (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) { g.writeFieldName(value.toString()); return; } Enum<?> en = (Enum<?>) value; g.writeFieldName(_values.serializedValueFor(en)); } } }'], ['', 'return new Default(Default.TYPE_ENUM, rawKeyType);', ''], ['import com.fasterxml.jackson.databind.util.EnumValues;', 'return EnumKeySerializer.construct(rawKeyType, EnumValues.constructFromName(config, (Class<Enum<?>>) rawKeyType));', 'public static class EnumKeySerializer extends StdSerializer<Object> { protected final EnumValues _values; protected EnumKeySerializer(Class<?> enumType, EnumValues values) { super(enumType, false); _values = values; } public static EnumKeySerializer construct(Class<?> enumType, EnumValues enumValues) { return new EnumKeySerializer(enumType, enumValues); } @Override public void serialize(Object value, JsonGenerator g, SerializerProvider serializers) throws IOException { if (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) { g.writeFieldName(value.toString()); return; } Enum<?> en = (Enum<?>) value; g.writeFieldName(_values.serializedValueFor(en)); } }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java']
['JacksonDatabind-56', 1, 2, 2, 2, ["return Pattern.compile(value); case STD_LOCALE: { int ix = value.indexOf('_'); if (ix < 0) { // single argument return new Locale(value); } String first = value.substring(0, ix); value = value.substring(ix+1); ix = value.indexOf('_'); if (ix < 0) { // two pieces return new Locale(first, value); }"], ['return Pattern.compile(value); case STD_LOCALE: { int ix = _firstHyphenOrUnderscore(value); if (ix < 0) { // single argument return new Locale(value); } String first = value.substring(0, ix); value = value.substring(ix+1); ix = _firstHyphenOrUnderscore(value); if (ix < 0) { // two pieces return new Locale(first, value); }', "} protected int _firstHyphenOrUnderscore(String str) { for (int i = 0, end = str.length(); i < end; ++i) { char c = str.charAt(i); if (c == '_' || c == '-') { return i; } } return -1; } } }"], ["int ix = value.indexOf('_'); ix = value.indexOf('_');", ''], ['int ix = _firstHyphenOrUnderscore(value); ix = _firstHyphenOrUnderscore(value);', "protected int _firstHyphenOrUnderscore(String str) { for (int i = 0, end = str.length(); i < end; ++i) { char c = str.charAt(i); if (c == '_' || c == '-') { return i; } } return -1; }"], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java']
['JacksonDatabind-57', 1, 1, 1, 1, ['if (_dataFormatReaders != null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true)); }'], ['if (_dataFormatReaders != null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), true)); }'], ['return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),'], ['return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),'], 'a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java', 'b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java']
['JacksonDatabind-58', 1, 1, 1, 1, ["// [databind#877]: explicitly prevent forced access to `cause` of `Throwable`; // never needed and attempts may cause problems on some platforms. // !!! NOTE: should be handled better for 2.8 and later mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } // note: this works since we know there's exactly one argument for methods BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),"], ['// [databind#877]: explicitly prevent forced access to `cause` of `Throwable`; // never needed and attempts may cause problems on some platforms. // !!! NOTE: should be handled better for 2.8 and later if ((mutator instanceof AnnotatedField) && "cause".equals(mutator.getName())) { ; } else { mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } } // note: this works since we know there\'s exactly one argument for methods BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),'], [''], ['if ((mutator instanceof AnnotatedField) && "cause".equals(mutator.getName())) { ; } else { }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-59', 4, 4, 4, 4, ['* * @since 2.8.4 */ /** * Mutant factory method that may be called on structured types', '_valueHandler, _typeHandler, _asStatic); } @Override public CollectionLikeType withStaticTyping() {', '_valueHandler, _typeHandler, _asStatic); } // "withKeyType()" not part of JavaType, hence must verify: @Override public MapLikeType withStaticTyping() {', ' // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get // copied as well return newType; // 20-Oct-2015, tatu: Old simplistic approach'], ['* * @since 2.8.4 */ public JavaType withHandlersFrom(JavaType src) { JavaType type = this; Object h = src.getTypeHandler(); if (h != _typeHandler) { type = type.withTypeHandler(h); } h = src.getValueHandler(); if (h != _valueHandler) { type = type.withValueHandler(h); } return type; } /** * Mutant factory method that may be called on structured types', '_valueHandler, _typeHandler, _asStatic); } @Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _elementType.withHandlersFrom(srcCt); if (ct != _elementType) { type = type.withContentType(ct); } } return type; } @Override public CollectionLikeType withStaticTyping() {', '_valueHandler, _typeHandler, _asStatic); } @Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcKeyType = src.getKeyType(); // "withKeyType()" not part of JavaType, hence must verify: if (type instanceof MapLikeType) { if (srcKeyType != null) { JavaType ct = _keyType.withHandlersFrom(srcKeyType); if (ct != _keyType) { type = ((MapLikeType) type).withKeyType(ct); } } } JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _valueType.withHandlersFrom(srcCt); if (ct != _valueType) { type = type.withContentType(ct); } } return type; } @Override public MapLikeType withStaticTyping() {', ' // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get // copied as well newType = newType.withHandlersFrom(baseType); return newType; // 20-Oct-2015, tatu: Old simplistic approach'], ['', '', '', ''], ['public JavaType withHandlersFrom(JavaType src) { JavaType type = this; Object h = src.getTypeHandler(); if (h != _typeHandler) { type = type.withTypeHandler(h); } h = src.getValueHandler(); if (h != _valueHandler) { type = type.withValueHandler(h); } return type; }', '@Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _elementType.withHandlersFrom(srcCt); if (ct != _elementType) { type = type.withContentType(ct); } } return type; }', '@Override public JavaType withHandlersFrom(JavaType src) { JavaType type = super.withHandlersFrom(src); JavaType srcKeyType = src.getKeyType(); if (type instanceof MapLikeType) { if (srcKeyType != null) { JavaType ct = _keyType.withHandlersFrom(srcKeyType); if (ct != _keyType) { type = ((MapLikeType) type).withKeyType(ct); } } } JavaType srcCt = src.getContentType(); if (srcCt != null) { JavaType ct = _valueType.withHandlersFrom(srcCt); if (ct != _valueType) { type = type.withContentType(ct); } } return type; }', 'newType = newType.withHandlersFrom(baseType);'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java']
['JacksonDatabind-60', 4, 4, 4, 4, ['import java.util.LinkedHashSet; import java.util.Set; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;', 'import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper; import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor; import com.fasterxml.jackson.databind.jsonschema.SchemaAware; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.BeanSerializer; import com.fasterxml.jackson.databind.ser.ContextualSerializer;', '// 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling // to use different Object for type id (logical type) and actual serialization // (delegat type). ser.serializeWithType(value, gen, provider, typeSer0); } catch (IOException ioe) { throw ioe; } catch (Exception e) {', '* override Object to use for type id (logical type) even when asking serialization * of something else (delegate type) */ }'], ['import java.util.LinkedHashSet; import java.util.Set; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;', 'import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper; import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor; import com.fasterxml.jackson.databind.jsonschema.SchemaAware; import com.fasterxml.jackson.databind.jsontype.TypeIdResolver; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.BeanSerializer; import com.fasterxml.jackson.databind.ser.ContextualSerializer;', '// 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling // to use different Object for type id (logical type) and actual serialization // (delegat type). TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean); ser.serializeWithType(value, gen, provider, rr); } catch (IOException ioe) { throw ioe; } catch (Exception e) {', '* override Object to use for type id (logical type) even when asking serialization * of something else (delegate type) */ static class TypeSerializerRerouter extends TypeSerializer { protected final TypeSerializer _typeSerializer; protected final Object _forObject; public TypeSerializerRerouter(TypeSerializer ts, Object ob) { _typeSerializer = ts; _forObject = ob; } @Override public TypeSerializer forProperty(BeanProperty prop) { // should never get called throw new UnsupportedOperationException(); } @Override public As getTypeInclusion() { return _typeSerializer.getTypeInclusion(); } @Override public String getPropertyName() { return _typeSerializer.getPropertyName(); } @Override public TypeIdResolver getTypeIdResolver() { return _typeSerializer.getTypeIdResolver(); } @Override public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForScalar(_forObject, gen); } @Override public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForObject(_forObject, gen); } @Override public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForArray(_forObject, gen); } @Override public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForScalar(_forObject, gen); } @Override public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForObject(_forObject, gen); } @Override public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForArray(_forObject, gen); } public void writeTypePrefixForScalar(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForScalar(_forObject, gen, type); } public void writeTypePrefixForObject(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForObject(_forObject, gen, type); } public void writeTypePrefixForArray(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForArray(_forObject, gen, type); } @Override public void writeCustomTypePrefixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForScalar(_forObject, gen, typeId); } @Override public void writeCustomTypePrefixForObject(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForObject(_forObject, gen, typeId); } @Override public void writeCustomTypePrefixForArray(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForArray(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForScalar(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForObject(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForObject(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForArray(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForArray(_forObject, gen, typeId); } } }'], ['', '', 'ser.serializeWithType(value, gen, provider, typeSer0);', ''], ['import com.fasterxml.jackson.annotation.JsonTypeInfo.As;', 'import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;', 'TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean); ser.serializeWithType(value, gen, provider, rr);', 'static class TypeSerializerRerouter extends TypeSerializer { protected final TypeSerializer _typeSerializer; protected final Object _forObject; public TypeSerializerRerouter(TypeSerializer ts, Object ob) { _typeSerializer = ts; _forObject = ob; } @Override public TypeSerializer forProperty(BeanProperty prop) { // should never get called throw new UnsupportedOperationException(); } @Override public As getTypeInclusion() { return _typeSerializer.getTypeInclusion(); } @Override public String getPropertyName() { return _typeSerializer.getPropertyName(); } @Override public TypeIdResolver getTypeIdResolver() { return _typeSerializer.getTypeIdResolver(); } @Override public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForScalar(_forObject, gen); } @Override public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForObject(_forObject, gen); } @Override public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypePrefixForArray(_forObject, gen); } @Override public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForScalar(_forObject, gen); } @Override public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForObject(_forObject, gen); } @Override public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException { _typeSerializer.writeTypeSuffixForArray(_forObject, gen); } public void writeTypePrefixForScalar(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForScalar(_forObject, gen, type); } public void writeTypePrefixForObject(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForObject(_forObject, gen, type); } public void writeTypePrefixForArray(Object value, JsonGenerator gen, Class<?> type) throws IOException { _typeSerializer.writeTypePrefixForArray(_forObject, gen, type); } @Override public void writeCustomTypePrefixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForScalar(_forObject, gen, typeId); } @Override public void writeCustomTypePrefixForObject(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForObject(_forObject, gen, typeId); } @Override public void writeCustomTypePrefixForArray(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypePrefixForArray(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForScalar(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForObject(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForObject(_forObject, gen, typeId); } @Override public void writeCustomTypeSuffixForArray(Object value, JsonGenerator gen, String typeId) throws IOException { _typeSerializer.writeCustomTypeSuffixForArray(_forObject, gen, typeId); } }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java']
['JacksonDatabind-61', 3, 3, 3, 3, ['{ // 03-Oct-2016, tatu: As per [databind#1395], need to skip // primitive types too, regardless switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS:', 'if (_idType == JsonTypeInfo.Id.NONE) { return null; } // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives, // regardless of setting TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); switch (_includeAs) { case WRAPPER_ARRAY:', 'if (_idType == JsonTypeInfo.Id.NONE) { return null; } // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives, // regardless of setting TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);'], ['{ // 03-Oct-2016, tatu: As per [databind#1395], need to skip // primitive types too, regardless if (t.isPrimitive()) { return false; } switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS:', 'if (_idType == JsonTypeInfo.Id.NONE) { return null; } // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives, // regardless of setting if (baseType.isPrimitive()) { return null; } TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); switch (_includeAs) { case WRAPPER_ARRAY:', 'if (_idType == JsonTypeInfo.Id.NONE) { return null; } // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives, // regardless of setting if (baseType.isPrimitive()) { return null; } TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);'], ['', '', ''], ['if (t.isPrimitive()) { return false; }', 'if (baseType.isPrimitive()) { return null; }', 'if (baseType.isPrimitive()) { return null; }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java']
['JacksonDatabind-62', 1, 1, 1, 1, ['+") returned true for \'canCreateUsingDelegate()\', but null for \'getDelegateType()\'"); } delegateDeser = findDeserializer(ctxt, delegateType, property); } } // [databind#1043]: allow per-property allow-wrapping of single overrides:'], ['+") returned true for \'canCreateUsingDelegate()\', but null for \'getDelegateType()\'"); } delegateDeser = findDeserializer(ctxt, delegateType, property); } else if (_valueInstantiator.canCreateUsingArrayDelegate()) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException("Invalid array-delegate-creator definition for "+_collectionType +": value instantiator ("+_valueInstantiator.getClass().getName() +") returned true for \'canCreateUsingArrayDelegate()\', but null for \'getArrayDelegateType()\'"); } delegateDeser = findDeserializer(ctxt, delegateType, property); } } // [databind#1043]: allow per-property allow-wrapping of single overrides:'], [''], ['} else if (_valueInstantiator.canCreateUsingArrayDelegate()) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException("Invalid array-delegate-creator definition for "+_collectionType +": value instantiator ("+_valueInstantiator.getClass().getName() +") returned true for \'canCreateUsingArrayDelegate()\', but null for \'getArrayDelegateType()\'"); } delegateDeser = findDeserializer(ctxt, delegateType, property);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java']
['JacksonDatabind-63', 2, 2, 2, 2, [' import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.util.ClassUtil; /** * Checked exception used to signal fatal problems with mapping of', "// butt-ugly for arrays. // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good // as it drops enclosing class. So let's try bit different approach String pkgName = ClassUtil.getPackageName(cls); if (pkgName != null) { sb.append(pkgName); sb.append('.'); } sb.append(cls.getSimpleName()); } sb.append('['); if (_fieldName != null) {"], [' import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; /** * Checked exception used to signal fatal problems with mapping of', '// butt-ugly for arrays. // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good // as it drops enclosing class. So let\'s try bit different approach int arrays = 0; while (cls.isArray()) { cls = cls.getComponentType(); ++arrays; } sb.append(cls.getName()); while (--arrays >= 0) { sb.append("[]"); } /* was: String pkgName = ClassUtil.getPackageName(cls); if (pkgName != null) { sb.append(pkgName); sb.append(\'.\'); } */ } sb.append(\'[\'); if (_fieldName != null) {'], ['import com.fasterxml.jackson.databind.util.ClassUtil;', 'sb.append(cls.getSimpleName());'], ['', 'int arrays = 0; while (cls.isArray()) { cls = cls.getComponentType(); ++arrays; } sb.append(cls.getName()); while (--arrays >= 0) { sb.append("[]"); } /* was: */'], 'a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java', 'b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java']
['JacksonDatabind-64', 1, 1, 1, 1, ['// whereas for global defaults OR per-property overrides, we have more // static definition. Sigh. // First: case of class/type specifying it; try to find POJO property defaults // 16-Oct-2016, tatu: Note: if we can not for some reason create "default instance", // revert logic to the case of general/per-property handling, so both // type-default AND null are to be excluded. // (as per [databind#1417] if (_useRealPropertyDefaults) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType); } else { valueToSuppress = getDefaultValue(actualType); suppressNulls = true;'], ['// whereas for global defaults OR per-property overrides, we have more // static definition. Sigh. // First: case of class/type specifying it; try to find POJO property defaults Object defaultBean; // 16-Oct-2016, tatu: Note: if we can not for some reason create "default instance", // revert logic to the case of general/per-property handling, so both // type-default AND null are to be excluded. // (as per [databind#1417] if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } try { valueToSuppress = am.getValue(defaultBean); } catch (Exception e) { _throwWrapped(e, propDef.getName(), defaultBean); } } else { valueToSuppress = getDefaultValue(actualType); suppressNulls = true;'], ['if (_useRealPropertyDefaults) { valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);'], ['Object defaultBean; if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) { try { valueToSuppress = am.getValue(defaultBean); } catch (Exception e) { _throwWrapped(e, propDef.getName(), defaultBean); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java']
['JacksonDatabind-65', 3, 3, 3, 3, ['return result; } } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: %s", re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;', '// So, of all single-arg static methods: for (AnnotatedMethod am : _classInfo.getStaticMethods()) { // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what if (isFactoryMethod(am)) { // And must take one of expected arg types (or supertype) Class<?> actualArgType = am.getRawParameterType(0); for (Class<?> expArgType : expArgTypes) {', 'final String name = am.getName(); // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg if ("valueOf".equals(name)) { return true; } // [databind#208] Also accept "fromString()", if takes String or CharSequence if ("fromString".equals(name)) {'], ['return result; } } catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: (%s) %s", re.getClass().getName(), re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;', '// So, of all single-arg static methods: for (AnnotatedMethod am : _classInfo.getStaticMethods()) { // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what if (isFactoryMethod(am) && am.getParameterCount() == 1) { // And must take one of expected arg types (or supertype) Class<?> actualArgType = am.getRawParameterType(0); for (Class<?> expArgType : expArgTypes) {', 'final String name = am.getName(); // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg if ("valueOf".equals(name)) { if (am.getParameterCount() == 1) { return true; } } // [databind#208] Also accept "fromString()", if takes String or CharSequence if ("fromString".equals(name)) {'], ['return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: %s", re.getMessage());', 'if (isFactoryMethod(am)) {', ''], ['return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: (%s) %s", re.getClass().getName(), re.getMessage());', 'if (isFactoryMethod(am) && am.getParameterCount() == 1) {', 'if (am.getParameterCount() == 1) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java']
['JacksonDatabind-66', 3, 3, 3, 3, ['import java.net.URL; import java.util.*; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.databind.*;', 'import com.fasterxml.jackson.databind.introspect.AnnotatedMethod; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver; /** * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}', 'if (key == null) { // is this even legal call? return null; } try { // Ugh... should not have to give parser which may or may not be correct one... Object result = _delegate.deserialize(ctxt.getParser(), ctxt); if (result != null) { return result; }'], ['import java.net.URL; import java.util.*; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.databind.*;', 'import com.fasterxml.jackson.databind.introspect.AnnotatedMethod; import com.fasterxml.jackson.databind.util.ClassUtil; import com.fasterxml.jackson.databind.util.EnumResolver; import com.fasterxml.jackson.databind.util.TokenBuffer; /** * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}', 'if (key == null) { // is this even legal call? return null; } TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt); tb.writeString(key); try { // Ugh... should not have to give parser which may or may not be correct one... JsonParser p = tb.asParser(); p.nextToken(); Object result = _delegate.deserialize(p, ctxt); if (result != null) { return result; }'], ['', '', 'Object result = _delegate.deserialize(ctxt.getParser(), ctxt);'], ['import com.fasterxml.jackson.core.JsonParser;', 'import com.fasterxml.jackson.databind.util.TokenBuffer;', 'TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt); tb.writeString(key); JsonParser p = tb.asParser(); p.nextToken(); Object result = _delegate.deserialize(p, ctxt);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java']
['JacksonDatabind-67', 1, 1, 1, 1, ['// the only non-standard thing is this: if (deser == null) { if (type.isEnumType()) { return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); } // and then post-processing if (deser != null) {'], ['// the only non-standard thing is this: if (deser == null) { if (type.isEnumType()) { deser = _createEnumKeyDeserializer(ctxt, type); } else { deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); } } // and then post-processing if (deser != null) {'], ['return _createEnumKeyDeserializer(ctxt, type); deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);'], ['deser = _createEnumKeyDeserializer(ctxt, type); } else { deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java']
['JacksonDatabind-68', 10, 10, 10, 10, ['protected Object deserializeFromObjectUsingNonDefault(JsonParser p, DeserializationContext ctxt) throws IOException { if (_delegateDeserializer != null) { return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); } if (_propertyBasedCreator != null) { return _deserializeUsingPropertyBased(p, ctxt);', 'if (_objectIdReader != null) { return deserializeFromObjectId(p, ctxt); } switch (p.getNumberType()) { case INT: if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromInt()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', '} return _valueInstantiator.createFromInt(ctxt, p.getIntValue()); case LONG: if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromInt()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'return _valueInstantiator.createFromLong(ctxt, p.getLongValue()); } // actually, could also be BigInteger, so: if (_delegateDeserializer != null) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', '/* Bit complicated if we have delegating creator; may need to use it, * or might not... */ if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromString()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'NumberType t = p.getNumberType(); // no separate methods for taking float... if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) { if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromDouble()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue()); } // actually, could also be BigDecimal, so: if (_delegateDeserializer != null) { return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); } return ctxt.handleMissingInstantiator(handledType(), p, "no suitable creator method found to deserialize from Number value (%s)",', '*/ public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException { if (_delegateDeserializer != null) { if (!_valueInstantiator.canCreateFromBoolean()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException { // note: can not call `_delegateDeserializer()` since order reversed here: if (_arrayDelegateDeserializer != null) { try { Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } catch (Exception e) { return wrapInstantiationProblem(e, ctxt); } } // fallback to non-array delegate if (_delegateDeserializer != null) { try { Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } catch (Exception e) { wrapInstantiationProblem(e, ctxt); return null; } } if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { JsonToken t = p.nextToken();', '/** * @since 2.9 */ /* /**********************************************************'], ['protected Object deserializeFromObjectUsingNonDefault(JsonParser p, DeserializationContext ctxt) throws IOException { final JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { return _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); } if (_propertyBasedCreator != null) { return _deserializeUsingPropertyBased(p, ctxt);', 'if (_objectIdReader != null) { return deserializeFromObjectId(p, ctxt); } final JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); switch (p.getNumberType()) { case INT: if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromInt()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', '} return _valueInstantiator.createFromInt(ctxt, p.getIntValue()); case LONG: if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromInt()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'return _valueInstantiator.createFromLong(ctxt, p.getLongValue()); } // actually, could also be BigInteger, so: if (delegateDeser != null) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', '/* Bit complicated if we have delegating creator; may need to use it, * or might not... */ JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromString()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'NumberType t = p.getNumberType(); // no separate methods for taking float... if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) { JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromDouble()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue()); } // actually, could also be BigDecimal, so: JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { return _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); } return ctxt.handleMissingInstantiator(handledType(), p, "no suitable creator method found to deserialize from Number value (%s)",', '*/ public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException { JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { if (!_valueInstantiator.canCreateFromBoolean()) { Object bean = _valueInstantiator.createUsingDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); }', 'public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException { // note: can not call `_delegateDeserializer()` since order reversed here: JsonDeserializer<Object> delegateDeser = _arrayDelegateDeserializer; // fallback to non-array delegate if ((delegateDeser != null) || ((delegateDeser = _delegateDeserializer) != null)) { Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, delegateDeser.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { JsonToken t = p.nextToken();', '/** * @since 2.9 */ private final JsonDeserializer<Object> _delegateDeserializer() { JsonDeserializer<Object> deser = _delegateDeserializer; if (deser == null) { deser = _arrayDelegateDeserializer; } return deser; } /* /**********************************************************'], ['if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_delegateDeserializer != null) { _delegateDeserializer.deserialize(p, ctxt));', 'if (_arrayDelegateDeserializer != null) { try { Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } catch (Exception e) { return wrapInstantiationProblem(e, ctxt); } } if (_delegateDeserializer != null) { try { _delegateDeserializer.deserialize(p, ctxt)); } catch (Exception e) { wrapInstantiationProblem(e, ctxt); return null; }', ''], ['final JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'final JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _delegateDeserializer(); if (delegateDeser != null) { delegateDeser.deserialize(p, ctxt));', 'JsonDeserializer<Object> delegateDeser = _arrayDelegateDeserializer; if ((delegateDeser != null) || ((delegateDeser = _delegateDeserializer) != null)) { delegateDeser.deserialize(p, ctxt));', 'private final JsonDeserializer<Object> _delegateDeserializer() { JsonDeserializer<Object> deser = _delegateDeserializer; if (deser == null) { deser = _arrayDelegateDeserializer; } return deser; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java']
['JacksonDatabind-69', 6, 6, 6, 6, ['SettableBeanProperty[] injectables) { if (creator.getParameterType(0).isCollectionLikeType()) { verifyNonDup(creator, C_ARRAY_DELEGATE, explicit); _arrayDelegateArgs = injectables; } else { verifyNonDup(creator, C_DELEGATE, explicit); _delegateArgs = injectables; } } public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties) { verifyNonDup(creator, C_PROPS, explicit); // Better ensure we have no duplicate names either... if (properties.length > 1) { HashMap<String,Integer> names = new HashMap<String,Integer>();', '} } _propertyBasedArgs = properties; } public void addIncompeteParameter(AnnotatedParameter parameter) {', '/** * @return True if specified Creator is to be used */ protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) { final int mask = (1 << typeIndex); _hasNonDefaultCreator = true;', 'if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated if (!explicit) { return; } // both explicit: verify verify = true;', '// otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return; } // new type more specific, use it }', '_explicitCreators |= mask; } _creators[typeIndex] = _fixAccess(newOne); } /*'], ['SettableBeanProperty[] injectables) { if (creator.getParameterType(0).isCollectionLikeType()) { if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) { _arrayDelegateArgs = injectables; } } else { if (verifyNonDup(creator, C_DELEGATE, explicit)) { _delegateArgs = injectables; } } } public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit, SettableBeanProperty[] properties) { if (verifyNonDup(creator, C_PROPS, explicit)) { // Better ensure we have no duplicate names either... if (properties.length > 1) { HashMap<String,Integer> names = new HashMap<String,Integer>();', '} } _propertyBasedArgs = properties; } } public void addIncompeteParameter(AnnotatedParameter parameter) {', '/** * @return True if specified Creator is to be used */ protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) { final int mask = (1 << typeIndex); _hasNonDefaultCreator = true;', 'if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated if (!explicit) { return false; } // both explicit: verify verify = true;', '// otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return false; } // new type more specific, use it }', '_explicitCreators |= mask; } _creators[typeIndex] = _fixAccess(newOne); return true; } /*'], ['verifyNonDup(creator, C_ARRAY_DELEGATE, explicit); verifyNonDup(creator, C_DELEGATE, explicit); verifyNonDup(creator, C_PROPS, explicit);', '', 'protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)', 'return;', 'return;', ''], ['if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) { } if (verifyNonDup(creator, C_DELEGATE, explicit)) { } if (verifyNonDup(creator, C_PROPS, explicit)) {', '}', 'protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)', 'return false;', 'return false;', 'return true;'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java']
['JacksonDatabind-70', 1, 1, 1, 1, ['if (!found) { // 09-Jan-2017, tatu: Important: must check name slot and NOT property name, // as only former is lower-case in case-insensitive case found = key.equals(prop.getName()); if (found) { // need to leave a hole here _propsInOrder[_findFromOrdered(prop)] = null;'], ['if (!found) { // 09-Jan-2017, tatu: Important: must check name slot and NOT property name, // as only former is lower-case in case-insensitive case found = key.equals(_hashArea[i-1]); if (found) { // need to leave a hole here _propsInOrder[_findFromOrdered(prop)] = null;'], ['found = key.equals(prop.getName());'], ['found = key.equals(_hashArea[i-1]);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java']
['JacksonDatabind-71', 1, 1, 1, 1, ['int kind; // first common types: if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID;'], ['int kind; // first common types: if (raw == String.class || raw == Object.class || raw == CharSequence.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID;'], ['if (raw == String.class || raw == Object.class) {'], ['if (raw == String.class || raw == Object.class || raw == CharSequence.class) {'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java']
['JacksonDatabind-72', 2, 2, 2, 2, ['@Override public int getPropertyIndex() { return _delegate.getPropertyIndex(); } // // // BeanProperty impl', '} return new InnerClassProperty(this, new AnnotatedConstructor(null, _creator, null, null)); } No newline at end of file }'], ['@Override public int getPropertyIndex() { return _delegate.getPropertyIndex(); } @Override public int getCreatorIndex() { return _delegate.getCreatorIndex(); } // // // BeanProperty impl', '} return new InnerClassProperty(this, new AnnotatedConstructor(null, _creator, null, null)); } } No newline at end of file'], ['', '}'], ['@Override public int getCreatorIndex() { return _delegate.getCreatorIndex(); }', '}'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java']
['JacksonDatabind-73', 4, 4, 4, 4, ['import java.util.*; import com.fasterxml.jackson.annotation.JsonAnySetter; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.cfg.HandlerInstantiator; import com.fasterxml.jackson.databind.cfg.MapperConfig;', 'while (it.hasNext()) { POJOPropertyBuilder prop = it.next(); // 26-Jan-2017, tatu: [databind#935]: need to denote removal of prop.removeNonVisible(inferMutators); } }', '* @param inferMutators Whether mutators can be "pulled in" by visible * accessors or not. */ public void removeNonVisible(boolean inferMutators) { /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition * of explicit access type for property; if not "AUTO", it will', '_setters = _removeNonVisible(_setters); } } } /**'], ['import java.util.*; import com.fasterxml.jackson.annotation.JsonAnySetter; import com.fasterxml.jackson.annotation.JsonProperty.Access; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.cfg.HandlerInstantiator; import com.fasterxml.jackson.databind.cfg.MapperConfig;', 'while (it.hasNext()) { POJOPropertyBuilder prop = it.next(); // 26-Jan-2017, tatu: [databind#935]: need to denote removal of Access acc = prop.removeNonVisible(inferMutators); if (!_forSerialization && (acc == Access.READ_ONLY)) { _collectIgnorals(prop.getName()); } } }', '* @param inferMutators Whether mutators can be "pulled in" by visible * accessors or not. */ public JsonProperty.Access removeNonVisible(boolean inferMutators) { /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition * of explicit access type for property; if not "AUTO", it will', '_setters = _removeNonVisible(_setters); } } return acc; } /**'], ['', 'prop.removeNonVisible(inferMutators);', 'public void removeNonVisible(boolean inferMutators)', ''], ['import com.fasterxml.jackson.annotation.JsonProperty.Access;', 'Access acc = prop.removeNonVisible(inferMutators); if (!_forSerialization && (acc == Access.READ_ONLY)) { _collectIgnorals(prop.getName()); }', 'public JsonProperty.Access removeNonVisible(boolean inferMutators)', 'return acc;'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java']
['JacksonDatabind-74', 1, 1, 1, 1, ['// or, something for which "as-property" won\'t work, changed into "wrapper-array" type: if (p.getCurrentToken() == JsonToken.START_ARRAY) { return super.deserializeTypedFromAny(p, ctxt); } ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME, "missing property \'"+_typePropertyName+"\' that is to contain type id (for class "+baseTypeName()+")");'], ['// or, something for which "as-property" won\'t work, changed into "wrapper-array" type: if (p.getCurrentToken() == JsonToken.START_ARRAY) { return super.deserializeTypedFromAny(p, ctxt); } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { String str = p.getText().trim(); if (str.isEmpty()) { return null; } } } ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME, "missing property \'"+_typePropertyName+"\' that is to contain type id (for class "+baseTypeName()+")");'], [''], ['} else if (p.getCurrentToken() == JsonToken.VALUE_STRING) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { String str = p.getText().trim(); if (str.isEmpty()) { return null; } }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java']
['JacksonDatabind-75', 3, 3, 3, 3, ['* handle toString() case dynamically (for example) */ EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass); Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true); return new EnumSerializer(v, serializeAsIndex); }', 'property, handledType()); if (format != null) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); if (serializeAsIndex != _serializeAsIndex) { return new EnumSerializer(_values, serializeAsIndex); }', '* index (number) or not. */ protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { JsonFormat.Shape shape = (format == null) ? null : format.getShape(); if (shape == null) { return null; } // i.e. "default", check dynamically if (shape == Shape.ANY || shape == Shape.SCALAR) { return null; } // 19-May-2016, tatu: also consider "natural" shape if (shape == Shape.STRING || shape == Shape.NATURAL) {'], ['* handle toString() case dynamically (for example) */ EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass); Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true, null); return new EnumSerializer(v, serializeAsIndex); }', 'property, handledType()); if (format != null) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false, _serializeAsIndex); if (serializeAsIndex != _serializeAsIndex) { return new EnumSerializer(_values, serializeAsIndex); }', '* index (number) or not. */ protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass, Boolean defaultValue) { JsonFormat.Shape shape = (format == null) ? null : format.getShape(); if (shape == null) { return defaultValue; } // i.e. "default", check dynamically if (shape == Shape.ANY || shape == Shape.SCALAR) { return defaultValue; } // 19-May-2016, tatu: also consider "natural" shape if (shape == Shape.STRING || shape == Shape.NATURAL) {'], ['Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);', 'format, false);', 'JsonFormat.Value format, boolean fromClass) return null; return null;'], ['Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true, null);', 'format, false, _serializeAsIndex);', 'JsonFormat.Value format, boolean fromClass, Boolean defaultValue) return defaultValue; return defaultValue;'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java']
['JacksonDatabind-76', 1, 1, 1, 1, ['// creator property? SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException("Can not create polymorphic instances with unwrapped values"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } continue; } // Object Id property?'], ['// creator property? SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt)); continue; } // Object Id property?'], ['if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException("Can not create polymorphic instances with unwrapped values"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); }'], ['buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java']
['JacksonDatabind-77', 2, 2, 2, 2, ['return null; } // For checks like [databind#1599] // Use generic bean introspection to build deserializer return buildBeanDeserializer(ctxt, type, beanDesc); }', '/** * @since 2.8.9 */ // There are certain nasty classes that could cause problems, mostly // via default typing -- catch them here. }'], ['return null; } // For checks like [databind#1599] checkIllegalTypes(ctxt, type, beanDesc); // Use generic bean introspection to build deserializer return buildBeanDeserializer(ctxt, type, beanDesc); }', '/** * @since 2.8.9 */ protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { // There are certain nasty classes that could cause problems, mostly // via default typing -- catch them here. Class<?> raw = type.getRawClass(); String name = raw.getSimpleName(); if ("TemplatesImpl".equals(name)) { // [databind#1599] if (raw.getName().startsWith("com.sun.org.apache.xalan")) { throw JsonMappingException.from(ctxt, String.format("Illegal type (%s) to deserialize: prevented for security reasons", name)); } } } }'], ['', ''], ['checkIllegalTypes(ctxt, type, beanDesc);', 'protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> raw = type.getRawClass(); String name = raw.getSimpleName(); if ("TemplatesImpl".equals(name)) { // [databind#1599] if (raw.getName().startsWith("com.sun.org.apache.xalan")) { throw JsonMappingException.from(ctxt, String.format("Illegal type (%s) to deserialize: prevented for security reasons", name)); } } }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-78', 3, 3, 3, 3, ['* * @since 2.8.9 */ // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599] /** * Set of class names of types that are never to be deserialized. * * @since 2.8.9 */ /* /**********************************************************', 'return null; } // For checks like [databind#1599] // Use generic bean introspection to build deserializer return buildBeanDeserializer(ctxt, type, beanDesc); }', '/** * @since 2.8.9 */ // There are certain nasty classes that could cause problems, mostly // via default typing -- catch them here. }'], ['* * @since 2.8.9 */ protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES; static { Set<String> s = new HashSet<>(); // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599] s.add("org.apache.commons.collections.functors.InvokerTransformer"); s.add("org.apache.commons.collections.functors.InstantiateTransformer"); s.add("org.apache.commons.collections4.functors.InvokerTransformer"); s.add("org.apache.commons.collections4.functors.InstantiateTransformer"); s.add("org.codehaus.groovy.runtime.ConvertedClosure"); s.add("org.codehaus.groovy.runtime.MethodClosure"); s.add("org.springframework.beans.factory.ObjectFactory"); s.add("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); } /** * Set of class names of types that are never to be deserialized. * * @since 2.8.9 */ protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES; /* /**********************************************************', 'return null; } // For checks like [databind#1599] checkIllegalTypes(ctxt, type, beanDesc); // Use generic bean introspection to build deserializer return buildBeanDeserializer(ctxt, type, beanDesc); }', '/** * @since 2.8.9 */ protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { // There are certain nasty classes that could cause problems, mostly // via default typing -- catch them here. String full = type.getRawClass().getName(); if (_cfgIllegalClassNames.contains(full)) { ctxt.reportBadTypeDefinition(beanDesc, "Illegal type (%s) to deserialize: prevented for security reasons", full); } } }'], ['', '', ''], ['protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES; static { Set<String> s = new HashSet<>(); s.add("org.apache.commons.collections.functors.InvokerTransformer"); s.add("org.apache.commons.collections.functors.InstantiateTransformer"); s.add("org.apache.commons.collections4.functors.InvokerTransformer"); s.add("org.apache.commons.collections4.functors.InstantiateTransformer"); s.add("org.codehaus.groovy.runtime.ConvertedClosure"); s.add("org.codehaus.groovy.runtime.MethodClosure"); s.add("org.springframework.beans.factory.ObjectFactory"); s.add("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); } protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;', 'checkIllegalTypes(ctxt, type, beanDesc);', 'protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { String full = type.getRawClass().getName(); if (_cfgIllegalClassNames.contains(full)) { ctxt.reportBadTypeDefinition(beanDesc, "Illegal type (%s) to deserialize: prevented for security reasons", full); } }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-79', 4, 4, 4, 4, ['@Override public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class); if (ref != null) { objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); } return objectIdInfo; } /*', '/** * @since 2.8.9 */ public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen, Class<? extends ObjectIdResolver> resolver)', '_resolver = resolver; } public ObjectIdInfo withAlwaysAsId(boolean state) { if (_alwaysAsId == state) {', "if (objectIdInfo == null) { // no ObjectId override, but maybe ObjectIdRef? if (oiw != null) { objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null)); oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); } } else { // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it"], ['@Override public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class); if (ref == null) { return objectIdInfo; } if (objectIdInfo == null) { objectIdInfo = ObjectIdInfo.empty(); } return objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); } /*', '/** * @since 2.8.9 */ private final static ObjectIdInfo EMPTY = new ObjectIdInfo(PropertyName.NO_NAME, Object.class, null, false, null); public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen, Class<? extends ObjectIdResolver> resolver)', '_resolver = resolver; } public static ObjectIdInfo empty() { return EMPTY; } public ObjectIdInfo withAlwaysAsId(boolean state) { if (_alwaysAsId == state) {', "if (objectIdInfo == null) { // no ObjectId override, but maybe ObjectIdRef? if (oiw != null) { objectIdInfo = intr.findObjectReferenceInfo(accessor, null); if (objectIdInfo != null) { oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); } } } else { // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it"], ['if (ref != null) { objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); return objectIdInfo;', '', '', 'objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));'], ['if (ref == null) { return objectIdInfo; if (objectIdInfo == null) { objectIdInfo = ObjectIdInfo.empty(); } return objectIdInfo.withAlwaysAsId(ref.alwaysAsId());', 'private final static ObjectIdInfo EMPTY = new ObjectIdInfo(PropertyName.NO_NAME, Object.class, null, false, null);', 'public static ObjectIdInfo empty() { return EMPTY; }', 'objectIdInfo = intr.findObjectReferenceInfo(accessor, null); if (objectIdInfo != null) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java']
['JacksonDatabind-80', 3, 3, 3, 3, ['} // then annotated types for property itself Collection<NamedType> st = ai.findSubtypes(property); if (st != null) { for (NamedType nt : st) {', 'nt.getType()); _collectAndResolve(ac, nt, config, ai, collected); } } NamedType rootType = new NamedType(rawBase, null);', '_collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName); // then with definitions from property Collection<NamedType> st = ai.findSubtypes(property); if (st != null) { for (NamedType nt : st) { ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType()); _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName); } } // and finally explicit type registrations (highest precedence) if (_registeredSubtypes != null) {'], ['} // then annotated types for property itself if (property != null) { Collection<NamedType> st = ai.findSubtypes(property); if (st != null) { for (NamedType nt : st) {', 'nt.getType()); _collectAndResolve(ac, nt, config, ai, collected); } } } NamedType rootType = new NamedType(rawBase, null);', '_collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName); // then with definitions from property if (property != null) { Collection<NamedType> st = ai.findSubtypes(property); if (st != null) { for (NamedType nt : st) { ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType()); _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName); } } } // and finally explicit type registrations (highest precedence) if (_registeredSubtypes != null) {'], ['', '', ''], ['if (property != null) {', '}', 'if (property != null) { }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java']
['JacksonDatabind-81', 7, 7, 7, 7, ['type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements } else { throw new JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related",', 'keyType = tf.constructGeneralizedType(keyType, keyClass); } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well keyType = tf.constructSpecializedType(keyType, keyClass); // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements } else { throw new JsonMappingException(null, String.format("Can not refine serialization key type %s into %s; types not related",', 'contentType = tf.constructGeneralizedType(contentType, contentClass); } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well contentType = tf.constructSpecializedType(contentType, contentClass); // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements } else { throw new JsonMappingException(null, String.format("Can not refine serialization content type %s into %s; types not related",', ' // Ok: start by refining the main type itself; common to all types final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as()); if ((valueClass != null) && !type.hasRawClass(valueClass)) { try { type = tf.constructSpecializedType(type, valueClass); } catch (IllegalArgumentException iae) {', 'if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs()); if (keyClass != null) { try { keyType = tf.constructSpecializedType(keyType, keyClass); type = ((MapLikeType) type).withKeyType(keyType);', 'if (contentType != null) { // collection[like], map[like], array, reference // And then value types for all containers: final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs()); if (contentClass != null) { try { contentType = tf.constructSpecializedType(contentType, contentClass); type = type.withContentType(contentType);', 'return StdTypeResolverBuilder.noTypeInfoBuilder(); } }'], ['type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else if (_primitiveAndWrapper(currRaw, serClass)) { // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements type = type.withStaticTyping(); } else { throw new JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related",', 'keyType = tf.constructGeneralizedType(keyType, keyClass); } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well keyType = tf.constructSpecializedType(keyType, keyClass); } else if (_primitiveAndWrapper(currRaw, keyClass)) { // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements keyType = keyType.withStaticTyping(); } else { throw new JsonMappingException(null, String.format("Can not refine serialization key type %s into %s; types not related",', 'contentType = tf.constructGeneralizedType(contentType, contentClass); } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well contentType = tf.constructSpecializedType(contentType, contentClass); } else if (_primitiveAndWrapper(currRaw, contentClass)) { // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements contentType = contentType.withStaticTyping(); } else { throw new JsonMappingException(null, String.format("Can not refine serialization content type %s into %s; types not related",', ' // Ok: start by refining the main type itself; common to all types final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as()); if ((valueClass != null) && !type.hasRawClass(valueClass) && !_primitiveAndWrapper(type, valueClass)) { try { type = tf.constructSpecializedType(type, valueClass); } catch (IllegalArgumentException iae) {', 'if (type.isMapLikeType()) { JavaType keyType = type.getKeyType(); final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs()); if ((keyClass != null) && !_primitiveAndWrapper(keyType, keyClass)) { try { keyType = tf.constructSpecializedType(keyType, keyClass); type = ((MapLikeType) type).withKeyType(keyType);', 'if (contentType != null) { // collection[like], map[like], array, reference // And then value types for all containers: final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs()); if ((contentClass != null) && !_primitiveAndWrapper(contentType, contentClass)) { try { contentType = tf.constructSpecializedType(contentType, contentClass); type = type.withContentType(contentType);', 'return StdTypeResolverBuilder.noTypeInfoBuilder(); } private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement) { if (baseType.isPrimitive()) { return baseType == ClassUtil.primitiveType(refinement); } if (refinement.isPrimitive()) { return refinement == ClassUtil.primitiveType(baseType); } return false; } private boolean _primitiveAndWrapper(JavaType baseType, Class<?> refinement) { if (baseType.isPrimitive()) { return baseType.hasRawClass(ClassUtil.primitiveType(refinement)); } if (refinement.isPrimitive()) { return refinement == ClassUtil.primitiveType(baseType.getRawClass()); } return false; } }'], ['', '', '', 'if ((valueClass != null) && !type.hasRawClass(valueClass)) {', 'if (keyClass != null) {', 'if (contentClass != null) {', ''], ['} else if (_primitiveAndWrapper(currRaw, serClass)) { type = type.withStaticTyping();', '} else if (_primitiveAndWrapper(currRaw, keyClass)) { keyType = keyType.withStaticTyping();', '} else if (_primitiveAndWrapper(currRaw, contentClass)) { contentType = contentType.withStaticTyping();', 'if ((valueClass != null) && !type.hasRawClass(valueClass) && !_primitiveAndWrapper(type, valueClass)) {', 'if ((keyClass != null) && !_primitiveAndWrapper(keyType, keyClass)) {', 'if ((contentClass != null) && !_primitiveAndWrapper(contentType, contentClass)) {', 'private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement) { if (baseType.isPrimitive()) { return baseType == ClassUtil.primitiveType(refinement); } if (refinement.isPrimitive()) { return refinement == ClassUtil.primitiveType(baseType); } return false; } private boolean _primitiveAndWrapper(JavaType baseType, Class<?> refinement) { if (baseType.isPrimitive()) { return baseType.hasRawClass(ClassUtil.primitiveType(refinement)); } if (refinement.isPrimitive()) { return refinement == ClassUtil.primitiveType(baseType.getRawClass()); } return false; }'], 'a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java', 'b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java']
['JacksonDatabind-82', 1, 1, 1, 1, ['boolean ignoreAny = ignorals.getIgnoreUnknown(); builder.setIgnoreUnknownProperties(ignoreAny); // Or explicit/implicit definitions? ignored = ignorals.getIgnored(); for (String propName : ignored) { builder.addIgnorable(propName); }'], ['boolean ignoreAny = ignorals.getIgnoreUnknown(); builder.setIgnoreUnknownProperties(ignoreAny); // Or explicit/implicit definitions? ignored = ignorals.findIgnoredForDeserialization(); for (String propName : ignored) { builder.addIgnorable(propName); }'], ['ignored = ignorals.getIgnored();'], ['ignored = ignorals.findIgnoredForDeserialization();'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-83', 1, 1, 1, 1, ['// 19-May-2017, tatu: Used to require non-null result (assuming `null` // indicated error; but that seems wrong. Should be able to return // `null` as value. if (_deserialize(text, ctxt) != null) { return _deserialize(text, ctxt); } } catch (IllegalArgumentException iae) { cause = iae; } catch (MalformedURLException me) {'], ['// 19-May-2017, tatu: Used to require non-null result (assuming `null` // indicated error; but that seems wrong. Should be able to return // `null` as value. return _deserialize(text, ctxt); } catch (IllegalArgumentException iae) { cause = iae; } catch (MalformedURLException me) {'], ['if (_deserialize(text, ctxt) != null) { }'], [''], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java']
['JacksonDatabind-84', 1, 1, 1, 1, ['_referencedType = ref; } public JavaType getSelfReferencedType() { return _referencedType; }'], ['_referencedType = ref; } @Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); } public JavaType getSelfReferencedType() { return _referencedType; }'], [''], ['@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java']
['JacksonDatabind-85', 1, 1, 1, 1, [" // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky.. // First: custom pattern will override things if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: // Jackson's own `StdDateFormat` is quite easy to deal with... // 08-Jun-2017, tatu: Unfortunately there's no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can't config other types // serializers.reportBadDefinition(handledType(), String.format( // Ugh. No way to change `Locale`, create copy; must re-crete completely: return this; } /*"], [' // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky.. // First: custom pattern will override things if (format.hasPattern()) { final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); // Jackson\'s own `StdDateFormat` is quite easy to deal with... if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } // 08-Jun-2017, tatu: Unfortunately there\'s no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can\'t config other types if (!(df0 instanceof SimpleDateFormat)) { // serializers.reportBadDefinition(handledType(), String.format( serializers.reportMappingProblem( "Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`", df0.getClass().getName()); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { // Ugh. No way to change `Locale`, create copy; must re-crete completely: df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); } /*'], ['if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } return this;'], ['if (format.hasPattern()) { SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportMappingProblem( "Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`", df0.getClass().getName()); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df);'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java']
['JacksonDatabind-86', 1, 1, 1, 1, ['_referencedType = ref; } public JavaType getSelfReferencedType() { return _referencedType; }'], ['_referencedType = ref; } @Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); } public JavaType getSelfReferencedType() { return _referencedType; }'], [''], ['@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java']
['JacksonDatabind-87', 8, 8, 8, 8, ['* * @since 2.8.10 */ /** * ISO-8601 with just the Date part, no time', 'protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN };', ' protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_PLAIN;', 'DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); }', 'protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatPlain; /*', "} } else { // If not, plain date, no timezone StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; // And possible also millisecond part if missing if (timeLen < 12) { // missing, or partial switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0');", 'default: sb.append(".000"); } } sb.append(\'Z\'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; if (df == null) { // 10-Jun-2017, tatu: As per [databind#1651], when using this format, // must use UTC, not whatever is configured as default timezone // (because we know `Z` identifier is used) df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient); } } }', '_formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatPlain = null; }'], ['* * @since 2.8.10 */ protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = "yyyy-MM-dd\'T\'HH:mm:ss.SSS"; /** * ISO-8601 with just the Date part, no time', 'protected final static String[] ALL_FORMATS = new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_ISO8601_NO_TZ, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN };', ' protected final static DateFormat DATE_FORMAT_ISO8601; protected final static DateFormat DATE_FORMAT_ISO8601_Z; protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; // since 2.8.10 protected final static DateFormat DATE_FORMAT_PLAIN;', 'DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE); DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE); DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE); }', 'protected transient DateFormat _formatRFC1123; protected transient DateFormat _formatISO8601; protected transient DateFormat _formatISO8601_z; protected transient DateFormat _formatISO8601_noTz; // 2.8.10 protected transient DateFormat _formatPlain; /*', "} } else { // If not, plain date, no timezone int timeLen = len - dateStr.lastIndexOf('T') - 1; // And possible also millisecond part if missing if (timeLen < 12) { // missing, or partial StringBuilder sb = new StringBuilder(dateStr); switch (timeLen) { case 11: sb.append('0'); case 10: sb.append('0');", 'default: sb.append(".000"); } dateStr = sb.toString(); } df = _formatISO8601_noTz; formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ; if (df == null) { // 10-Jun-2017, tatu: As per [databind#1651], when using this format, // must use UTC, not whatever is configured as default timezone // (because we know `Z` identifier is used) df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr, _timezone, _locale, _lenient); } } }', '_formatRFC1123 = null; _formatISO8601 = null; _formatISO8601_z = null; _formatISO8601_noTz = null; _formatPlain = null; }'], ['', '', '', '', '', 'StringBuilder sb = new StringBuilder(dateStr);', "sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; formatStr = DATE_FORMAT_STR_ISO8601_Z; df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);", ''], ['protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = "yyyy-MM-dd\'T\'HH:mm:ss.SSS";', 'DATE_FORMAT_STR_ISO8601_NO_TZ,', 'protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; // since 2.8.10', 'DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE); DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE);', 'protected transient DateFormat _formatISO8601_noTz; // 2.8.10', 'StringBuilder sb = new StringBuilder(dateStr);', 'dateStr = sb.toString(); df = _formatISO8601_noTz; formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ; df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr, _timezone, _locale, _lenient);', '_formatISO8601_noTz = null;'], 'a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java']
['JacksonDatabind-88', 1, 1, 1, 1, ["// compatibility -- needed later anyway, and not doing so may open // security issues. JavaType t = tf.constructFromCanonical(id); // Probably cleaner to have a method in `TypeFactory` but can't add in patch return t; } Class<?> cls;"], ['// compatibility -- needed later anyway, and not doing so may open // security issues. JavaType t = tf.constructFromCanonical(id); if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) { // Probably cleaner to have a method in `TypeFactory` but can\'t add in patch throw new IllegalArgumentException(String.format( "Class %s not subtype of %s", t.getRawClass().getName(), _baseType)); } return t; } Class<?> cls;'], [''], ['if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) { throw new IllegalArgumentException(String.format( "Class %s not subtype of %s", t.getRawClass().getName(), _baseType)); }'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java']
['JacksonDatabind-89', 1, 1, 1, 1, ['// [databind#1680]: may or may not be problem, take no chance s.add("com.sun.rowset.JdbcRowSetImpl"); // [databind#1737]; JDK provided // [databind#1737]; 3rd party DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); }'], ['// [databind#1680]: may or may not be problem, take no chance s.add("com.sun.rowset.JdbcRowSetImpl"); // [databind#1737]; JDK provided s.add("java.util.logging.FileHandler"); s.add("java.rmi.server.UnicastRemoteObject"); // [databind#1737]; 3rd party s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); s.add("org.springframework.beans.factory.config.PropertyPathFactoryBean"); s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); }'], [''], ['s.add("java.util.logging.FileHandler"); s.add("java.rmi.server.UnicastRemoteObject"); s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); s.add("org.springframework.beans.factory.config.PropertyPathFactoryBean"); s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource");'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-90', 2, 2, 2, 2, ['*/ public boolean canInstantiate() { return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean();', 'return (_withArgsCreator != null); } @Override public JavaType getDelegateType(DeserializationConfig config) {'], ['*/ public boolean canInstantiate() { return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateUsingArrayDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean();', 'return (_withArgsCreator != null); } @Override public boolean canInstantiate() { return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateUsingArrayDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean(); } @Override public JavaType getDelegateType(DeserializationConfig config) {'], ['|| canCreateUsingDelegate()', ''], ['|| canCreateUsingDelegate() || canCreateUsingArrayDelegate()', '@Override public boolean canInstantiate() { return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateUsingArrayDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java']
['JacksonDatabind-91', 1, 1, 1, 1, ['// First: value types may have both value and type handlers JavaType ct = t.getContentType(); if (ct != null) { return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null); // Second: map(-like) types may have value handler for key (but not type; keys are untyped) } } return false;'], ['// First: value types may have both value and type handlers JavaType ct = t.getContentType(); if (ct != null) { if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) { return true; } } // Second: map(-like) types may have value handler for key (but not type; keys are untyped) if (t.isMapLikeType()) { JavaType kt = t.getKeyType(); if (kt.getValueHandler() != null) { return true; } } } return false;'], ['return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);'], ['if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) { return true; } } if (t.isMapLikeType()) { JavaType kt = t.getKeyType(); if (kt.getValueHandler() != null) { return true; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java']
['JacksonDatabind-92', 1, 1, 1, 1, ['// [databind#1680]: may or may not be problem, take no chance s.add("com.sun.rowset.JdbcRowSetImpl"); // [databind#1737]; JDK provided // [databind#1737]; 3rd party DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); }'], ['// [databind#1680]: may or may not be problem, take no chance s.add("com.sun.rowset.JdbcRowSetImpl"); // [databind#1737]; JDK provided s.add("java.util.logging.FileHandler"); s.add("java.rmi.server.UnicastRemoteObject"); // [databind#1737]; 3rd party s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); s.add("org.springframework.beans.factory.config.PropertyPathFactoryBean"); s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); }'], [''], ['s.add("java.util.logging.FileHandler"); s.add("java.rmi.server.UnicastRemoteObject"); s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); s.add("org.springframework.beans.factory.config.PropertyPathFactoryBean"); s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource");'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java']
['JacksonDatabind-93', 1, 1, 1, 1, ['// 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling // for some Spring framework types // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); // looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there? if ("AbstractPointcutAdvisor".equals(name)'], ['// 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling // for some Spring framework types // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) { String name = cls.getSimpleName(); // looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there? if ("AbstractPointcutAdvisor".equals(name)'], ['if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {'], ['if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java']
['JacksonDatabind-94', 2, 2, 2, 2, ['{ protected final static String PREFIX_SPRING = "org.springframework."; /** * Set of well-known "nasty classes", deserialization of which is considered dangerous', '|| "AbstractApplicationContext".equals(name)) { break main_check; } // [databind#1737]; more 3rd party // s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); // s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); // [databind#1931]; more 3rd party // com.mchange.v2.c3p0.ComboPooledDataSource // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource } } return;'], ['{ protected final static String PREFIX_SPRING = "org.springframework."; protected final static String PREFIX_C3P0 = "com.mchange.v2.c3p0."; /** * Set of well-known "nasty classes", deserialization of which is considered dangerous', '|| "AbstractApplicationContext".equals(name)) { break main_check; } } } else if (full.startsWith(PREFIX_C3P0)) { // [databind#1737]; more 3rd party // s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); // s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); // [databind#1931]; more 3rd party // com.mchange.v2.c3p0.ComboPooledDataSource // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource if (full.endsWith("DataSource")) { break main_check; } } return;'], ['', ''], ['protected final static String PREFIX_C3P0 = "com.mchange.v2.c3p0.";', '} } else if (full.startsWith(PREFIX_C3P0)) { if (full.endsWith("DataSource")) { break main_check;'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java']
['JacksonDatabind-95', 4, 4, 4, 4, ['// also: if we start from untyped, not much to save do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } if (!rawBase.isAssignableFrom(subclass)) {', ' // (1) Original target type has no generics -- just resolve subtype if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, TypeBindings.emptyBindings()); break; } // (2) A small set of "well-known" List/Map subtypes where can take a short-cut', 'int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], null); } return constructParametricType(parametrized, pt); }', "// can be comma that separates types, or closing '>' tokens.pushBack(token); } return _factory._fromClass(null, base, null); } protected List<JavaType> parseTypes(MyTokenizer tokens)"], ['// also: if we start from untyped, not much to save do { // bogus loop to be able to break if (rawBase == Object.class) { newType = _fromClass(null, subclass, EMPTY_BINDINGS); break; } if (!rawBase.isAssignableFrom(subclass)) {', ' // (1) Original target type has no generics -- just resolve subtype if (baseType.getBindings().isEmpty()) { newType = _fromClass(null, subclass, EMPTY_BINDINGS); break; } // (2) A small set of "well-known" List/Map subtypes where can take a short-cut', 'int len = parameterClasses.length; JavaType[] pt = new JavaType[len]; for (int i = 0; i < len; ++i) { pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS); } return constructParametricType(parametrized, pt); }', "// can be comma that separates types, or closing '>' tokens.pushBack(token); } return _factory._fromClass(null, base, TypeBindings.emptyBindings()); } protected List<JavaType> parseTypes(MyTokenizer tokens)"], ['newType = _fromClass(null, subclass, TypeBindings.emptyBindings());', 'newType = _fromClass(null, subclass, TypeBindings.emptyBindings());', 'pt[i] = _fromClass(null, parameterClasses[i], null);', 'return _factory._fromClass(null, base, null);'], ['newType = _fromClass(null, subclass, EMPTY_BINDINGS);', 'newType = _fromClass(null, subclass, EMPTY_BINDINGS);', 'pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);', 'return _factory._fromClass(null, base, TypeBindings.emptyBindings());'], 'a/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java']
['JacksonDatabind-96', 1, 1, 1, 1, ['// 25-May-2018, tatu: as per [databind#2051], looks like we have to get // not implicit name, but name with possible strategy-based-rename // paramName = candidate.findImplicitParamName(0); paramName = candidate.findImplicitParamName(0); useProps = (paramName != null) && paramDef.couldSerialize(); } if (useProps) {'], ['// 25-May-2018, tatu: as per [databind#2051], looks like we have to get // not implicit name, but name with possible strategy-based-rename // paramName = candidate.findImplicitParamName(0); paramName = candidate.paramName(0); useProps = (paramName != null) && paramDef.couldSerialize(); } if (useProps) {'], ['paramName = candidate.findImplicitParamName(0);'], ['paramName = candidate.paramName(0);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java']
['JacksonDatabind-97', 1, 1, 1, 1, ['} else { // 25-May-2018, tatu: [databind#1991] do not call via generator but through context; // this to preserve contextual information gen.writeObject(_value); } }'], ['} else { // 25-May-2018, tatu: [databind#1991] do not call via generator but through context; // this to preserve contextual information ctxt.defaultSerializeValue(_value, gen); } }'], ['gen.writeObject(_value);'], ['ctxt.defaultSerializeValue(_value, gen);'], 'a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java', 'b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java']
['JacksonDatabind-98', 1, 1, 1, 1, ['if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) { // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to // apply deserializer... fun fun. buffer.assignParameter(typeProp, typeId); } } }'], ['if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) { // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to // apply deserializer... fun fun. final Object v; if (typeProp.getType().hasRawClass(String.class)) { v = typeId; } else { TokenBuffer tb = new TokenBuffer(p, ctxt); tb.writeString(typeId); v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt); tb.close(); } buffer.assignParameter(typeProp, v); } } }'], ['buffer.assignParameter(typeProp, typeId);'], ['final Object v; if (typeProp.getType().hasRawClass(String.class)) { v = typeId; } else { TokenBuffer tb = new TokenBuffer(p, ctxt); tb.writeString(typeId); v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt); tb.close(); } buffer.assignParameter(typeProp, v);'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java']
['JacksonDatabind-99', 1, 1, 1, 1, ["sb.append(_class.getName()); sb.append('<'); sb.append(_referencedType.toCanonical()); return sb.toString(); }"], ["sb.append(_class.getName()); sb.append('<'); sb.append(_referencedType.toCanonical()); sb.append('>'); return sb.toString(); }"], [''], ["sb.append('>');"], 'a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java', 'b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java']
['JacksonDatabind-100', 1, 1, 1, 1, ['if (n != null) { // [databind#2096]: although `binaryValue()` works for real binary node // and embedded "POJO" node, coercion from TextNode may require variant, so: byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; } } } // otherwise return null to mark we have no binary content return null;'], ['if (n != null) { // [databind#2096]: although `binaryValue()` works for real binary node // and embedded "POJO" node, coercion from TextNode may require variant, so: if (n instanceof TextNode) { return ((TextNode) n).getBinaryValue(b64variant); } return n.binaryValue(); } // otherwise return null to mark we have no binary content return null;'], ['byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; }'], ['if (n instanceof TextNode) { return ((TextNode) n).getBinaryValue(b64variant); return n.binaryValue();'], 'a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java', 'b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java']
['JacksonDatabind-101', 1, 1, 1, 1, ["// if so, need to copy all remaining tokens into buffer while (t == JsonToken.FIELD_NAME) { // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some // problems if we maintain invariants tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { // !!! 08-Jul-2011, tatu: Could probably support; but for now"], ['// if so, need to copy all remaining tokens into buffer while (t == JsonToken.FIELD_NAME) { // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that tokens.copyCurrentStructure(p); t = p.nextToken(); } // 28-Aug-2018, tatu: Let\'s add sanity check here, easier to catch off-by-some // problems if we maintain invariants if (t != JsonToken.END_OBJECT) { ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, "Attempted to unwrap \'%s\' value", handledType().getName()); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { // !!! 08-Jul-2011, tatu: Could probably support; but for now'], ['p.nextToken();'], ['if (t != JsonToken.END_OBJECT) { ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, "Attempted to unwrap \'%s\' value", handledType().getName()); }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java']
['JacksonDatabind-102', 1, 1, 1, 1, ["{ // Note! Should not skip if `property` null since that'd skip check // for config overrides, in case of root value if (property == null) { return this; } JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this;"], ["{ // Note! Should not skip if `property` null since that'd skip check // for config overrides, in case of root value JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this;"], ['if (property == null) { return this; }'], [''], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java']
['JacksonDatabind-103', 26, 26, 26, 26, ['throw invalidTypeIdException(baseType, subClass, String.format( "problem: (%s) %s", e.getClass().getName(), e.getMessage())); } if (baseType.isTypeOrSuperTypeOf(cls)) { return getTypeFactory().constructSpecializedType(baseType, cls);', '} catch (ParseException e) { throw new IllegalArgumentException(String.format( "Failed to parse Date value \'%s\': %s", dateStr, e.getMessage())); } }', 'String excMsg; if (cause == null) { excMsg = "N/A"; } else if ((excMsg = cause.getMessage()) == null) { excMsg = ClassUtil.nameOf(cause.getClass()); } String msg = String.format("Cannot construct instance of %s, problem: %s",', ' import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; /** * Checked exception used to signal fatal problems with mapping of', 'return new JsonMappingException(null, String.format("Unexpected IOException (of type %s): %s", src.getClass().getName(), src.getMessage())); } /**', 'jme = (JsonMappingException) src; } else { // [databind#2128]: try to avoid duplication String msg = src.getMessage(); // Let\'s use a more meaningful placeholder if all we have is null if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")";', "// We better only expose checked exceptions, since those // are what caller is expected to handle ser = null; // doesn't matter but compiler whines otherwise reportMappingProblem(iae, iae.getMessage()); } if (ser != null) {", '// We better only expose checked exceptions, since those // are what caller is expected to handle ser = null; reportMappingProblem(iae, iae.getMessage()); } if (ser != null) {', 'return b.buildTypeDeserializer(config, baseType, subtypes); } catch (IllegalArgumentException e0) { InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType); e.initCause(e0); throw e; }', "// to throw proper exception, it doesn't actually have reference to this // instance so... throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null); } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);", "// to throw proper exception, it doesn't actually have reference to this // instance so... throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null); } final DeserializationConfig config = ctxt.getConfig();", '} catch (IllegalArgumentException iae) { // We better only expose checked exceptions, since those // are what caller is expected to handle throw JsonMappingException.from(ctxt, iae.getMessage(), iae); } if (deser == null) { return null;', 'StringBuilder msg = new StringBuilder("Problem deserializing \\"any\\" property \'").append(propName); msg.append("\' of class "+getClassName()+" (expected type: ").append(_type); msg.append("; actual type: ").append(actType).append(")"); String origMsg = e.getMessage(); if (origMsg != null) { msg.append(", problem: ").append(origMsg); } else {', "ClassUtil.throwIfRTE(e); // let's wrap the innermost problem Throwable t = ClassUtil.getRootCause(e); throw new JsonMappingException(null, t.getMessage(), t); } private String getClassName() { return _setter.getDeclaringClass().getName(); }", '.append(getType()) .append("; actual type: ") .append(actType).append(")"); String origMsg = e.getMessage(); if (origMsg != null) { msg.append(", problem: ") .append(origMsg);', "ClassUtil.throwIfRTE(e); // let's wrap the innermost problem Throwable th = ClassUtil.getRootCause(e); throw JsonMappingException.from(p, th.getMessage(), th); } @Deprecated // since 2.7", '} catch (IllegalArgumentException iae) { return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value, "not a valid representation (error: %s)", iae.getMessage()); } }', '} catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: (%s) %s", re.getClass().getName(), re.getMessage()); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;', '// @since 2.9 protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException { return ctxt.handleWeirdKey(_keyClass, key, "problem: %s", e.getMessage()); } /*', '} } return new JsonMappingException(null, "Instantiation of "+getValueTypeDesc()+" value failed: "+t.getMessage(), t); } /**', 'ClassUtil.throwIfRTE(t); throw new IllegalArgumentException("Failed to instantiate bean of type " +_classInfo.getAnnotated().getName()+": ("+t.getClass().getName()+") " +t.getMessage(), t); } }', '} catch (Throwable t) { String msg = String.format( "Problem determining whether filter of type \'%s\' should filter out `null` values: (%s) %s", filter.getClass().getName(), t.getClass().getName(), t.getMessage()); reportBadDefinition(filter.getClass(), msg, t); return false; // never gets here }', 'if (e instanceof IOException) { return (IOException) e; } String msg = e.getMessage(); if (msg == null) { msg = "[no message for "+e.getClass().getName()+"]"; }', 'serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); } catch (JsonMappingException e) { if (propDef == null) { return prov.reportBadDefinition(declaredType, e.getMessage()); } return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage()); } // Container types can have separate type serializers for content (value / element) type', 'import java.util.*; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.JsonMappingException;', '* * @since 2.9.7 */ /* /**********************************************************'], ['throw invalidTypeIdException(baseType, subClass, String.format( "problem: (%s) %s", e.getClass().getName(), ClassUtil.exceptionMessage(e))); } if (baseType.isTypeOrSuperTypeOf(cls)) { return getTypeFactory().constructSpecializedType(baseType, cls);', '} catch (ParseException e) { throw new IllegalArgumentException(String.format( "Failed to parse Date value \'%s\': %s", dateStr, ClassUtil.exceptionMessage(e))); } }', 'String excMsg; if (cause == null) { excMsg = "N/A"; } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) { excMsg = ClassUtil.nameOf(cause.getClass()); } String msg = String.format("Cannot construct instance of %s, problem: %s",', ' import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.util.ClassUtil; /** * Checked exception used to signal fatal problems with mapping of', 'return new JsonMappingException(null, String.format("Unexpected IOException (of type %s): %s", src.getClass().getName(), ClassUtil.exceptionMessage(src))); } /**', 'jme = (JsonMappingException) src; } else { // [databind#2128]: try to avoid duplication String msg = ClassUtil.exceptionMessage(src); // Let\'s use a more meaningful placeholder if all we have is null if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")";', "// We better only expose checked exceptions, since those // are what caller is expected to handle ser = null; // doesn't matter but compiler whines otherwise reportMappingProblem(iae, ClassUtil.exceptionMessage(iae)); } if (ser != null) {", '// We better only expose checked exceptions, since those // are what caller is expected to handle ser = null; reportMappingProblem(iae, ClassUtil.exceptionMessage(iae)); } if (ser != null) {', 'return b.buildTypeDeserializer(config, baseType, subtypes); } catch (IllegalArgumentException e0) { InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, ClassUtil.exceptionMessage(e0), baseType); e.initCause(e0); throw e; }', "// to throw proper exception, it doesn't actually have reference to this // instance so... throw InvalidDefinitionException.from(ctxt.getParser(), ClassUtil.exceptionMessage(e), beanDesc, null); } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);", "// to throw proper exception, it doesn't actually have reference to this // instance so... throw InvalidDefinitionException.from(ctxt.getParser(), ClassUtil.exceptionMessage(e), builderDesc, null); } final DeserializationConfig config = ctxt.getConfig();", '} catch (IllegalArgumentException iae) { // We better only expose checked exceptions, since those // are what caller is expected to handle throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae); } if (deser == null) { return null;', 'StringBuilder msg = new StringBuilder("Problem deserializing \\"any\\" property \'").append(propName); msg.append("\' of class "+getClassName()+" (expected type: ").append(_type); msg.append("; actual type: ").append(actType).append(")"); String origMsg = ClassUtil.exceptionMessage(e); if (origMsg != null) { msg.append(", problem: ").append(origMsg); } else {', "ClassUtil.throwIfRTE(e); // let's wrap the innermost problem Throwable t = ClassUtil.getRootCause(e); throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t); } private String getClassName() { return _setter.getDeclaringClass().getName(); }", '.append(getType()) .append("; actual type: ") .append(actType).append(")"); String origMsg = ClassUtil.exceptionMessage(e); if (origMsg != null) { msg.append(", problem: ") .append(origMsg);', "ClassUtil.throwIfRTE(e); // let's wrap the innermost problem Throwable th = ClassUtil.getRootCause(e); throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th); } @Deprecated // since 2.7", '} catch (IllegalArgumentException iae) { return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value, "not a valid representation (error: %s)", ClassUtil.exceptionMessage(iae)); } }', '} catch (Exception re) { return ctxt.handleWeirdKey(_keyClass, key, "not a valid representation, problem: (%s) %s", re.getClass().getName(), ClassUtil.exceptionMessage(re)); } if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { return null;', '// @since 2.9 protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException { return ctxt.handleWeirdKey(_keyClass, key, "problem: %s", ClassUtil.exceptionMessage(e)); } /*', '} } return new JsonMappingException(null, "Instantiation of "+getValueTypeDesc()+" value failed: "+ClassUtil.exceptionMessage(t), t); } /**', 'ClassUtil.throwIfRTE(t); throw new IllegalArgumentException("Failed to instantiate bean of type " +_classInfo.getAnnotated().getName()+": ("+t.getClass().getName()+") " +ClassUtil.exceptionMessage(t), t); } }', '} catch (Throwable t) { String msg = String.format( "Problem determining whether filter of type \'%s\' should filter out `null` values: (%s) %s", filter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t)); reportBadDefinition(filter.getClass(), msg, t); return false; // never gets here }', 'if (e instanceof IOException) { return (IOException) e; } String msg = ClassUtil.exceptionMessage(e); if (msg == null) { msg = "[no message for "+e.getClass().getName()+"]"; }', 'serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); } catch (JsonMappingException e) { if (propDef == null) { return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e)); } return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e)); } // Container types can have separate type serializers for content (value / element) type', 'import java.util.*; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.JsonMappingException;', '* * @since 2.9.7 */ public static String exceptionMessage(Throwable t) { if (t instanceof JsonProcessingException) { return ((JsonProcessingException) t).getOriginalMessage(); } return t.getMessage(); } /* /**********************************************************'], ['e.getMessage()));', 'e.getMessage()));', '} else if ((excMsg = cause.getMessage()) == null) {', '', 'src.getMessage()));', 'String msg = src.getMessage();', 'reportMappingProblem(iae, iae.getMessage());', 'reportMappingProblem(iae, iae.getMessage());', 'e0.getMessage(), baseType);', 'e.getMessage(),', 'e.getMessage(),', 'throw JsonMappingException.from(ctxt, iae.getMessage(), iae);', 'String origMsg = e.getMessage();', 'throw new JsonMappingException(null, t.getMessage(), t);', 'String origMsg = e.getMessage();', 'throw JsonMappingException.from(p, th.getMessage(), th);', 'iae.getMessage());', 're.getMessage());', 'e.getMessage());', '"Instantiation of "+getValueTypeDesc()+" value failed: "+t.getMessage(), t);', '+t.getMessage(), t);', 'filter.getClass().getName(), t.getClass().getName(), t.getMessage());', 'String msg = e.getMessage();', 'return prov.reportBadDefinition(declaredType, e.getMessage()); return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());', '', ''], ['ClassUtil.exceptionMessage(e)));', 'ClassUtil.exceptionMessage(e)));', '} else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {', 'import com.fasterxml.jackson.databind.util.ClassUtil;', 'ClassUtil.exceptionMessage(src)));', 'String msg = ClassUtil.exceptionMessage(src);', 'reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));', 'reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));', 'ClassUtil.exceptionMessage(e0), baseType);', 'ClassUtil.exceptionMessage(e),', 'ClassUtil.exceptionMessage(e),', 'throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae);', 'String origMsg = ClassUtil.exceptionMessage(e);', 'throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t);', 'String origMsg = ClassUtil.exceptionMessage(e);', 'throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th);', 'ClassUtil.exceptionMessage(iae));', 'ClassUtil.exceptionMessage(re));', 'ClassUtil.exceptionMessage(e));', '"Instantiation of "+getValueTypeDesc()+" value failed: "+ClassUtil.exceptionMessage(t), t);', '+ClassUtil.exceptionMessage(t), t);', 'filter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t));', 'String msg = ClassUtil.exceptionMessage(e);', 'return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e)); return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e));', 'import com.fasterxml.jackson.core.JsonProcessingException;', 'public static String exceptionMessage(Throwable t) { if (t instanceof JsonProcessingException) { return ((JsonProcessingException) t).getOriginalMessage(); } return t.getMessage(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java']
['JacksonDatabind-104', 3, 3, 3, 3, ["final int year = cal.get(Calendar.YEAR); // Assuming GregorianCalendar, special handling needed for BCE (aka BC) // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but // it seems that plus prefix IS mandated. Padding is an open question, but since agreeement // for max length would be needed, we ewould need to limit to arbitrary length // like five digits (erroring out if beyond or padding to that as minimum). // Instead, let's just print number out as is and let decoder try to make sense of it. pad4(buffer, year); buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-');", '} } // Ok. First of all, BCE 1 output (given as value `1` in era BCE) needs to become // "+0000", but rest (from `2` up, in that era) need minus sign. // as with CE, 4 digit variant needs padding; beyond that not (although that part is // open to debate, needs agreement with receiver) // But `pad4()` deals with "big" numbers now so: private static void pad2(StringBuffer buffer, int value) { int tens = value / 10;', "if (h == 0) { buffer.append('0').append('0'); } else { pad2(buffer, h); value -= (100 * h); } pad2(buffer, value);"], ["final int year = cal.get(Calendar.YEAR); // Assuming GregorianCalendar, special handling needed for BCE (aka BC) if (cal.get(Calendar.ERA) == GregorianCalendar.BC) { _formatBCEYear(buffer, year); } else { if (year > 9999) { // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but // it seems that plus prefix IS mandated. Padding is an open question, but since agreeement // for max length would be needed, we ewould need to limit to arbitrary length // like five digits (erroring out if beyond or padding to that as minimum). // Instead, let's just print number out as is and let decoder try to make sense of it. buffer.append('+'); } pad4(buffer, year); } buffer.append('-'); pad2(buffer, cal.get(Calendar.MONTH) + 1); buffer.append('-');", '} } protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) { // Ok. First of all, BCE 1 output (given as value `1` in era BCE) needs to become // "+0000", but rest (from `2` up, in that era) need minus sign. if (bceYearNoSign == 1) { buffer.append("+0000"); return; } final int isoYear = bceYearNoSign - 1; buffer.append(\'-\'); // as with CE, 4 digit variant needs padding; beyond that not (although that part is // open to debate, needs agreement with receiver) // But `pad4()` deals with "big" numbers now so: pad4(buffer, isoYear); } private static void pad2(StringBuffer buffer, int value) { int tens = value / 10;', "if (h == 0) { buffer.append('0').append('0'); } else { if (h > 99) { // [databind#2167]: handle above 9999 correctly buffer.append(h); } else { pad2(buffer, h); } value -= (100 * h); } pad2(buffer, value);"], ['', '', ''], ["if (cal.get(Calendar.ERA) == GregorianCalendar.BC) { _formatBCEYear(buffer, year); } else { if (year > 9999) { buffer.append('+'); } }", 'protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) { if (bceYearNoSign == 1) { buffer.append("+0000"); return; } final int isoYear = bceYearNoSign - 1; buffer.append(\'-\'); pad4(buffer, isoYear); }', 'if (h > 99) { // [databind#2167]: handle above 9999 correctly buffer.append(h); } else { }'], 'a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java', 'b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java']
['JacksonDatabind-105', 2, 2, 2, 2, ['UUID.class, AtomicBoolean.class, StackTraceElement.class, ByteBuffer.class }; for (Class<?> cls : types) { _classNames.add(cls.getName()); } for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }', 'if (rawType == ByteBuffer.class) { return new ByteBufferDeserializer(); } } return null; }'], ['UUID.class, AtomicBoolean.class, StackTraceElement.class, ByteBuffer.class, Void.class }; for (Class<?> cls : types) { _classNames.add(cls.getName()); } for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }', 'if (rawType == ByteBuffer.class) { return new ByteBufferDeserializer(); } if (rawType == Void.class) { return NullifyingDeserializer.instance; } } return null; }'], ['ByteBuffer.class', ''], ['ByteBuffer.class, Void.class', 'if (rawType == Void.class) { return NullifyingDeserializer.instance; }'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java']
['JacksonDatabind-106', 1, 1, 1, 1, ['@Override public int getIntValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); return node.intValue(); } @Override public long getLongValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); return node.longValue(); }'], ['@Override public int getIntValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); if (!node.canConvertToInt()) { reportOverflowInt(); } return node.intValue(); } @Override public long getLongValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); if (!node.canConvertToInt()) { reportOverflowLong(); } return node.longValue(); }'], [''], ['if (!node.canConvertToInt()) { reportOverflowInt(); } if (!node.canConvertToInt()) { reportOverflowLong(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java', 'b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java']
['JacksonDatabind-107', 1, 1, 1, 1, ['JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { // what should this be taken to mean? // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but... return null; } // ... would this actually work? deser = ctxt.findContextualValueDeserializer(actual, _property);'], ['JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { // what should this be taken to mean? // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but... return NullifyingDeserializer.instance; } // ... would this actually work? deser = ctxt.findContextualValueDeserializer(actual, _property);'], ['return null;'], ['return NullifyingDeserializer.instance;'], 'a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java', 'b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java']
['JacksonDatabind-108', 2, 2, 2, 2, ['@SuppressWarnings("unchecked") @Override public <T extends TreeNode> T readTree(JsonParser p) throws IOException { return (T) _bindAsTree(p); } @Override', '* Same as {@link #_bindAsTree} except end-of-input is reported by returning * {@code null}, not "missing node" */ /** * @since 2.1'], ['@SuppressWarnings("unchecked") @Override public <T extends TreeNode> T readTree(JsonParser p) throws IOException { return (T) _bindAsTreeOrNull(p); } @Override', '* Same as {@link #_bindAsTree} except end-of-input is reported by returning * {@code null}, not "missing node" */ protected final JsonNode _bindAsTreeOrNull(JsonParser p) throws IOException { _config.initialize(p); if (_schema != null) { p.setSchema(_schema); } JsonToken t = p.getCurrentToken(); if (t == null) { t = p.nextToken(); if (t == null) { return null; } } final JsonNode resultNode; if (t == JsonToken.VALUE_NULL) { resultNode = _config.getNodeFactory().nullNode(); } else { final DeserializationContext ctxt = createDeserializationContext(p); final JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt); if (_unwrapRoot) { resultNode = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser); } else { resultNode = (JsonNode) deser.deserialize(p, ctxt); if (_config.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) { _verifyNoTrailingTokens(p, ctxt, JSON_NODE_TYPE); } } } return resultNode; } /** * @since 2.1'], ['return (T) _bindAsTree(p);', ''], ['return (T) _bindAsTreeOrNull(p);', 'protected final JsonNode _bindAsTreeOrNull(JsonParser p) throws IOException { _config.initialize(p); if (_schema != null) { p.setSchema(_schema); } JsonToken t = p.getCurrentToken(); if (t == null) { t = p.nextToken(); if (t == null) { return null; } } final JsonNode resultNode; if (t == JsonToken.VALUE_NULL) { resultNode = _config.getNodeFactory().nullNode(); } else { final DeserializationContext ctxt = createDeserializationContext(p); final JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt); if (_unwrapRoot) { resultNode = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser); } else { resultNode = (JsonNode) deser.deserialize(p, ctxt); if (_config.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) { _verifyNoTrailingTokens(p, ctxt, JSON_NODE_TYPE); } } } return resultNode; }'], 'a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java', 'b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java']
['JacksonDatabind-109', 5, 5, 5, 5, ['/** * Copied from `jackson-core` class `GeneratorBase` */ protected final boolean _isInt;', 'switch (format.getShape()) { case STRING: // [databind#2264]: Need special handling for `BigDecimal` return ToStringSerializer.instance; default: }', "/** * @since 2.10 */ // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this // ... but wouldn't it be nice to trigger error via generator? Alas, // no method to do that. So we'll do... // should never be called // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this }", ' import java.io.IOException; import java.lang.reflect.Type; import java.util.Map; import com.fasterxml.jackson.annotation.JsonFormat;', 'if (format != null) { switch (format.getShape()) { case STRING: return ToStringSerializer.instance; default: }'], ['/** * Copied from `jackson-core` class `GeneratorBase` */ protected final static int MAX_BIG_DECIMAL_SCALE = 9999; protected final boolean _isInt;', 'switch (format.getShape()) { case STRING: // [databind#2264]: Need special handling for `BigDecimal` if (((Class<?>) handledType()) == BigDecimal.class) { return bigDecimalAsStringSerializer(); } return ToStringSerializer.instance; default: }', '/** * @since 2.10 */ public static JsonSerializer<?> bigDecimalAsStringSerializer() { return BigDecimalAsStringSerializer.BD_INSTANCE; } final static class BigDecimalAsStringSerializer extends ToStringSerializerBase { final static BigDecimalAsStringSerializer BD_INSTANCE = new BigDecimalAsStringSerializer(); public BigDecimalAsStringSerializer() { super(BigDecimal.class); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return valueToString(value).isEmpty(); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { final String text; if (gen.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { final BigDecimal bd = (BigDecimal) value; // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this if (!_verifyBigDecimalRange(gen, bd)) { // ... but wouldn\'t it be nice to trigger error via generator? Alas, // no method to do that. So we\'ll do... final String errorMsg = String.format( "Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]", bd.scale(), MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE); provider.reportMappingProblem(errorMsg); } text = bd.toPlainString(); } else { text = value.toString(); } gen.writeString(text); } @Override public String valueToString(Object value) { // should never be called throw new IllegalStateException(); } // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this protected boolean _verifyBigDecimalRange(JsonGenerator gen, BigDecimal value) throws IOException { int scale = value.scale(); return ((scale >= -MAX_BIG_DECIMAL_SCALE) && (scale <= MAX_BIG_DECIMAL_SCALE)); } } }', ' import java.io.IOException; import java.lang.reflect.Type; import java.math.BigDecimal; import java.util.Map; import com.fasterxml.jackson.annotation.JsonFormat;', 'if (format != null) { switch (format.getShape()) { case STRING: if (((Class<?>) handledType()) == BigDecimal.class) { return NumberSerializer.bigDecimalAsStringSerializer(); } return ToStringSerializer.instance; default: }'], ['', '', '', '', ''], ['protected final static int MAX_BIG_DECIMAL_SCALE = 9999;', 'if (((Class<?>) handledType()) == BigDecimal.class) { return bigDecimalAsStringSerializer(); }', 'public static JsonSerializer<?> bigDecimalAsStringSerializer() { return BigDecimalAsStringSerializer.BD_INSTANCE; } final static class BigDecimalAsStringSerializer extends ToStringSerializerBase { final static BigDecimalAsStringSerializer BD_INSTANCE = new BigDecimalAsStringSerializer(); public BigDecimalAsStringSerializer() { super(BigDecimal.class); } @Override public boolean isEmpty(SerializerProvider prov, Object value) { return valueToString(value).isEmpty(); } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { final String text; if (gen.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { final BigDecimal bd = (BigDecimal) value; if (!_verifyBigDecimalRange(gen, bd)) { final String errorMsg = String.format( "Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]", bd.scale(), MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE); provider.reportMappingProblem(errorMsg); } text = bd.toPlainString(); } else { text = value.toString(); } gen.writeString(text); } @Override public String valueToString(Object value) { throw new IllegalStateException(); } protected boolean _verifyBigDecimalRange(JsonGenerator gen, BigDecimal value) throws IOException { int scale = value.scale(); return ((scale >= -MAX_BIG_DECIMAL_SCALE) && (scale <= MAX_BIG_DECIMAL_SCALE)); } }', 'import java.math.BigDecimal;', 'if (((Class<?>) handledType()) == BigDecimal.class) { return NumberSerializer.bigDecimalAsStringSerializer(); }'], 'a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java']
['JacksonDatabind-110', 3, 3, 3, 3, ['/* 02-Mar-2019, tatu: for [databind#2265], need to consider possible alternate type... * which we essentially coerce into the other one */ private final static Class<?> CLASS_UNMODIFIABLE_MAP; static {', 'CLASS_SINGLETON_LIST = list.getClass(); CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass(); // for [databind#2265] Map<?,?> map = Collections.singletonMap("a", "b"); CLASS_SINGLETON_MAP = map.getClass();', '} else if (type.hasRawClass(CLASS_SINGLETON_SET)) { conv = converter(TYPE_SINGLETON_SET, type, Set.class); // [databind#2265]: we may have another impl type for unmodifiable Lists, check both } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) { conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class); } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) { conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);'], ['/* 02-Mar-2019, tatu: for [databind#2265], need to consider possible alternate type... * which we essentially coerce into the other one */ private final static Class<?> CLASS_UNMODIFIABLE_LIST_ALIAS; private final static Class<?> CLASS_UNMODIFIABLE_MAP; static {', 'CLASS_SINGLETON_LIST = list.getClass(); CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass(); // for [databind#2265] CLASS_UNMODIFIABLE_LIST_ALIAS = Collections.unmodifiableList(new LinkedList<Object>()).getClass(); Map<?,?> map = Collections.singletonMap("a", "b"); CLASS_SINGLETON_MAP = map.getClass();', '} else if (type.hasRawClass(CLASS_SINGLETON_SET)) { conv = converter(TYPE_SINGLETON_SET, type, Set.class); // [databind#2265]: we may have another impl type for unmodifiable Lists, check both } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) { conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class); } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) { conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);'], ['', '', '} else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {'], ['private final static Class<?> CLASS_UNMODIFIABLE_LIST_ALIAS;', 'CLASS_UNMODIFIABLE_LIST_ALIAS = Collections.unmodifiableList(new LinkedList<Object>()).getClass();', '} else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) {'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java']
['JacksonDatabind-111', 9, 9, 9, 9, ['return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new CreatorProperty(this, deser, _nullProvider); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new FieldProperty(this, deser, _nullProvider); } @Override', 'Object readResolve() { return new FieldProperty(this); } No newline at end of file }', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new MethodProperty(this, deser, _nullProvider); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new ObjectIdReferenceProperty(this, deser, _nullProvider); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new ObjectIdValueProperty(this, deser, _nullProvider); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were return new SetterlessProperty(this, deser, _nullProvider); } @Override', 'set(instance, value); return instance; } No newline at end of file }', ' @Override public AtomicReference<Object> getNullValue(DeserializationContext ctxt) throws JsonMappingException { return new AtomicReference<Object>(); } @Override'], ['return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new CreatorProperty(this, deser, nvp); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new FieldProperty(this, deser, nvp); } @Override', 'Object readResolve() { return new FieldProperty(this); } } No newline at end of file', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new MethodProperty(this, deser, nvp); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new ObjectIdReferenceProperty(this, deser, nvp); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new ObjectIdValueProperty(this, deser, nvp); } @Override', 'return this; } // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new SetterlessProperty(this, deser, nvp); } @Override', 'set(instance, value); return instance; } } No newline at end of file', ' @Override public AtomicReference<Object> getNullValue(DeserializationContext ctxt) throws JsonMappingException { return new AtomicReference<Object>(_valueDeserializer.getNullValue(ctxt)); } @Override'], ['return new CreatorProperty(this, deser, _nullProvider);', 'return new FieldProperty(this, deser, _nullProvider);', '}', 'return new MethodProperty(this, deser, _nullProvider);', 'return new ObjectIdReferenceProperty(this, deser, _nullProvider);', 'return new ObjectIdValueProperty(this, deser, _nullProvider);', 'return new SetterlessProperty(this, deser, _nullProvider);', '}', 'return new AtomicReference<Object>();'], ['NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new CreatorProperty(this, deser, nvp);', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new FieldProperty(this, deser, nvp);', '}', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new MethodProperty(this, deser, nvp);', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new ObjectIdReferenceProperty(this, deser, nvp);', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new ObjectIdValueProperty(this, deser, nvp);', 'NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider; return new SetterlessProperty(this, deser, nvp);', '}', 'return new AtomicReference<Object>(_valueDeserializer.getNullValue(ctxt));'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java']
['JacksonDatabind-112', 1, 1, 1, 1, ['JsonDeserializer<Object> delegate = null; if (_valueInstantiator != null) { // [databind#2324]: check both array-delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); if (delegateCreator != null) { JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); }'], ['JsonDeserializer<Object> delegate = null; if (_valueInstantiator != null) { // [databind#2324]: check both array-delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator(); if (delegateCreator != null) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) { JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); }'], ['AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();'], ['AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator(); JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {'], 'a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java', 'b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java']
['Closure-1', 1, 1, 1, 1, ["// is removing globals, then it's OK to remove unused function args. // // See http://code.google.com/p/closure-compiler/issues/detail?id=253 Node function = fnScope.getRootNode();"], ["// is removing globals, then it's OK to remove unused function args. // // See http://code.google.com/p/closure-compiler/issues/detail?id=253 if (!removeGlobals) { return; } Node function = fnScope.getRootNode();"], [''], ['if (!removeGlobals) { return; }'], 'a/src/com/google/javascript/jscomp/RemoveUnusedVars.java', 'b/src/com/google/javascript/jscomp/RemoveUnusedVars.java']
['Closure-2', 1, 1, 1, 1, ["ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) {"], ["ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = ImmutableSet.of(); } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); } for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) {"], [''], ['if (implicitProto == null) { currentPropertyNames = ImmutableSet.of(); } else { }'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-3', 3, 3, 3, 3, ['reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { if (c.canInline()) { c.inlineVariable(); // If definition c has dependencies, then inlining it may have', 'return defMetadata.node; } private boolean canInline() { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false;', 'case Token.REGEXP: case Token.NEW: return true; } return false; }'], ['reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { if (c.canInline(t.getScope())) { c.inlineVariable(); // If definition c has dependencies, then inlining it may have', 'return defMetadata.node; } private boolean canInline(final Scope scope) { // Cannot inline a parameter. if (getDefCfgNode().isFunction()) { return false;', 'case Token.REGEXP: case Token.NEW: return true; case Token.NAME: Var var = scope.getOwnSlot(input.getString()); if (var != null && var.getParentNode().isCatch()) { return true; } } return false; }'], ['if (c.canInline()) {', 'private boolean canInline() {', ''], ['if (c.canInline(t.getScope())) {', 'private boolean canInline(final Scope scope) {', 'case Token.NAME: Var var = scope.getOwnSlot(input.getString()); if (var != null && var.getParentNode().isCatch()) { return true; }'], 'a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java', 'b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java']
['Closure-4', 2, 2, 2, 2, ['// makes more sense. Now, resolution via registry is first in order to // avoid triggering the warnings built into the resolution via properties. boolean resolved = resolveViaRegistry(t, enclosing); if (detectImplicitPrototypeCycle()) { handleTypeCycle(t); }', '} resolveViaProperties(t, enclosing); if (detectImplicitPrototypeCycle()) { handleTypeCycle(t); }'], ['// makes more sense. Now, resolution via registry is first in order to // avoid triggering the warnings built into the resolution via properties. boolean resolved = resolveViaRegistry(t, enclosing); if (detectInheritanceCycle()) { handleTypeCycle(t); }', '} resolveViaProperties(t, enclosing); if (detectInheritanceCycle()) { handleTypeCycle(t); }'], ['if (detectImplicitPrototypeCycle()) {', 'if (detectImplicitPrototypeCycle()) {'], ['if (detectInheritanceCycle()) {', 'if (detectInheritanceCycle()) {'], 'a/src/com/google/javascript/rhino/jstype/NamedType.java', 'b/src/com/google/javascript/rhino/jstype/NamedType.java']
['Closure-5', 1, 1, 1, 1, [" // Deleting a property has different semantics from deleting // a variable, so deleted properties should not be inlined. // NOTE(nicksantos): This pass's object-splitting algorithm has // a blind spot. It assumes that if a property isn't defined on an"], [" // Deleting a property has different semantics from deleting // a variable, so deleted properties should not be inlined. if (gramps.isDelProp()) { return false; } // NOTE(nicksantos): This pass's object-splitting algorithm has // a blind spot. It assumes that if a property isn't defined on an"], [''], ['if (gramps.isDelProp()) { return false; }'], 'a/src/com/google/javascript/jscomp/InlineObjectLiterals.java', 'b/src/com/google/javascript/jscomp/InlineObjectLiterals.java']
['Closure-6', 3, 3, 3, 3, ['JSType leftType, Node owner, String propName) { // The NoType check is a hack to make typedefs work OK. if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { // Do not type-check interface methods, because we expect that // they will have dummy implementations that do not match the type // annotations.', '"assignment to property " + propName + " of " + getReadableJSTypeName(owner, true), rightType, leftType); } return false; } return true;', 'boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType); } return false; } return true;'], ['JSType leftType, Node owner, String propName) { // The NoType check is a hack to make typedefs work OK. if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { // Do not type-check interface methods, because we expect that // they will have dummy implementations that do not match the type // annotations.', '"assignment to property " + propName + " of " + getReadableJSTypeName(owner, true), rightType, leftType); return false; } return true;', 'boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { mismatch(t, n, msg, rightType, leftType); return false; } return true;'], ['if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else {', '}', 'if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { }'], ['', '', ''], 'a/src/com/google/javascript/jscomp/TypeValidator.java', 'b/src/com/google/javascript/jscomp/TypeValidator.java']
['Closure-7', 1, 1, 1, 1, ['public JSType caseObjectType(ObjectType type) { if (value.equals("function")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; // Objects are restricted to "Function", subtypes are left // Only filter out subtypes of "function" } return matchesExpectation("object") ? type : null; }'], ['public JSType caseObjectType(ObjectType type) { if (value.equals("function")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); if (resultEqualsValue) { // Objects are restricted to "Function", subtypes are left return ctorType.getGreatestSubtype(type); } else { // Only filter out subtypes of "function" return type.isSubtype(ctorType) ? null : type; } } return matchesExpectation("object") ? type : null; }'], ['return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;'], ['if (resultEqualsValue) { return ctorType.getGreatestSubtype(type); } else { return type.isSubtype(ctorType) ? null : type; }'], 'a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java', 'b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java']
['Closure-8', 1, 1, 1, 1, ['Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s && !blacklistedVars.contains(var); } } private void applyCollapses() { for (Collapse collapse : collapses) {'], ['Var var = s.getVar(lhs.getString()); return var != null && var.getScope() == s && !isNamedParameter(var) && !blacklistedVars.contains(var); } } private boolean isNamedParameter(Var v) { return v.getParentNode().isParamList(); } private void applyCollapses() { for (Collapse collapse : collapses) {'], [''], ['&& !isNamedParameter(var) private boolean isNamedParameter(Var v) { return v.getParentNode().isParamList(); }'], 'a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java', 'b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java']
['Closure-9', 2, 2, 2, 2, ['private String normalizeSourceName(String filename) { // The DOS command shell will normalize "/" to "\\", so we have to // wrestle it back. if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length());', 'Preconditions.checkArgument(scriptNodeCount == 1, "ProcessCommonJSModules supports only one invocation per " + "CompilerInput / script node"); String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()) .copyInformationFromForTree(script)); if (reportDependencies) {'], ['private String normalizeSourceName(String filename) { // The DOS command shell will normalize "/" to "\\", so we have to // wrestle it back. filename = filename.replace("\\\\", "/"); if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length());', 'Preconditions.checkArgument(scriptNodeCount == 1, "ProcessCommonJSModules supports only one invocation per " + "CompilerInput / script node"); String moduleName = guessCJSModuleName(script.getSourceFileName()); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()) .copyInformationFromForTree(script)); if (reportDependencies) {'], ['', 'String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));'], ['filename = filename.replace("\\\\", "/");', 'String moduleName = guessCJSModuleName(script.getSourceFileName());'], 'a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java', 'b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java']
['Closure-10', 1, 1, 1, 1, [' static boolean mayBeString(Node n, boolean recurse) { if (recurse) { return allResultsMatch(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); }'], [' static boolean mayBeString(Node n, boolean recurse) { if (recurse) { return anyResultsMatch(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); }'], ['return allResultsMatch(n, MAY_BE_STRING_PREDICATE);'], ['return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-11', 1, 1, 1, 1, [' if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "\'.\'", "dict"); } else if (n.getJSType() != null && parent.isAssign()) { return; } else if (validator.expectNotNullOrUndefined(t, n, childType, "No properties on this expression", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n);'], [' if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "\'.\'", "dict"); } else if (validator.expectNotNullOrUndefined(t, n, childType, "No properties on this expression", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n);'], ['} else if (n.getJSType() != null && parent.isAssign()) { return;'], [''], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-12', 1, 1, 1, 1, ['} private boolean hasExceptionHandler(Node cfgNode) { return false; }'], ['} private boolean hasExceptionHandler(Node cfgNode) { List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); for (DiGraphEdge<Node, Branch> edge : branchEdges) { if (edge.getValue() == Branch.ON_EX) { return true; } } return false; }'], [''], ['List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); for (DiGraphEdge<Node, Branch> edge : branchEdges) { if (edge.getValue() == Branch.ON_EX) { return true; } }'], 'a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java', 'b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java']
['Closure-13', 1, 1, 1, 1, ['do { Node c = node.getFirstChild(); while(c != null) { traverse(c); Node next = c.getNext(); c = next; }'], ['do { Node c = node.getFirstChild(); while(c != null) { Node next = c.getNext(); traverse(c); c = next; }'], ['Node next = c.getNext();'], ['Node next = c.getNext();'], 'a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java', 'b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java']
['Closure-14', 1, 1, 1, 1, ['} else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); } } return computeFollowNode(fromNode, parent, cfa);'], ['} else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { cfa.createEdge(fromNode, Branch.ON_EX, finallyNode); } } return computeFollowNode(fromNode, parent, cfa);'], ['cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);'], ['cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);'], 'a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java', 'b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java']
['Closure-15', 1, 1, 1, 1, ['return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {'], ['return true; } if (n.isDelProp()) { return true; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {'], [''], ['if (n.isDelProp()) { return true; }'], 'a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java', 'b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java']
['Closure-16', 2, 2, 2, 2, [' private class AliasedTypeNode implements AliasUsage { private final Node typeReference; private final String aliasName; AliasedTypeNode(Node typeReference, String aliasName) { this.typeReference = typeReference; this.aliasName = aliasName; } @Override public void applyAlias() { typeReference.setString(aliasName); } }', 'Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } }'], [' private class AliasedTypeNode implements AliasUsage { private final Node typeReference; private final Node aliasDefinition; private final String aliasName; AliasedTypeNode(Node typeReference, Node aliasDefinition, String aliasName) { this.typeReference = typeReference; this.aliasDefinition = aliasDefinition; this.aliasName = aliasName; } @Override public void applyAlias() { String typeName = typeReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); } }', 'Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName)); } }'], ['AliasedTypeNode(Node typeReference, typeReference.setString(aliasName);', 'aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));'], ['private final Node aliasDefinition; AliasedTypeNode(Node typeReference, Node aliasDefinition, this.aliasDefinition = aliasDefinition; String typeName = typeReference.getString(); String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); Preconditions.checkState(typeName.startsWith(aliasName)); typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));', 'aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));'], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-17', 1, 1, 1, 1, ["if (info.isConstant()) { JSType knownType = null; if (rValue != null) { if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { // If rValue has a type-cast, we use the type in the type-cast. // If rValue's type was already computed during scope creation, // then we can safely use that. return rValue.getJSType();"], ["if (info.isConstant()) { JSType knownType = null; if (rValue != null) { JSDocInfo rValueInfo = rValue.getJSDocInfo(); if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. return rValueInfo.getType().evaluate(scope, typeRegistry); } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { // If rValue's type was already computed during scope creation, // then we can safely use that. return rValue.getJSType();"], ['if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {'], ['JSDocInfo rValueInfo = rValue.getJSDocInfo(); if (rValueInfo != null && rValueInfo.hasType()) { return rValueInfo.getType().evaluate(scope, typeRegistry); } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-18', 1, 1, 1, 1, [' // Check if the sources need to be re-ordered. boolean staleInputs = false; if (options.dependencyOptions.needsManagement() && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.'], [' // Check if the sources need to be re-ordered. boolean staleInputs = false; if (options.dependencyOptions.needsManagement()) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they // are not flagged even if they are dropped from the process.'], ['if (options.dependencyOptions.needsManagement() && options.closurePass) {'], ['if (options.dependencyOptions.needsManagement()) {'], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-19', 1, 1, 1, 1, ['scope.inferQualifiedSlot(node, qualifiedName, origType, type); break; // "this" references aren\'t currently modeled in the CFG. default: throw new IllegalArgumentException("Node cannot be refined. \\n" +'], ['scope.inferQualifiedSlot(node, qualifiedName, origType, type); break; case Token.THIS: // "this" references aren\'t currently modeled in the CFG. break; default: throw new IllegalArgumentException("Node cannot be refined. \\n" +'], [''], ['case Token.THIS: break;'], 'a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java', 'b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java']
['Closure-20', 1, 1, 1, 1, ['// slightly different semantics than \'\' + (a). See // http://code.google.com/p/closure-compiler/issues/detail?id=759 Node value = callTarget.getNext(); if (value != null) { Node addition = IR.add( IR.string("").srcref(callTarget), value.detachFromParent());'], ['// slightly different semantics than \'\' + (a). See // http://code.google.com/p/closure-compiler/issues/detail?id=759 Node value = callTarget.getNext(); if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) { Node addition = IR.add( IR.string("").srcref(callTarget), value.detachFromParent());'], ['if (value != null) {'], ['if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) {'], 'a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java', 'b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java']
['Closure-21', 2, 2, 2, 2, ['// Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; }', ' boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = "This code lacks side-effects. Is there a bug?"; if (n.isString()) {'], ['// Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult() || n.isBlock()) { return; }', ' boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = "This code lacks side-effects. Is there a bug?"; if (n.isString()) {'], ['if (n.isExprResult()) {', 'if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ('], ['if (n.isExprResult() || n.isBlock()) {', 'if (!isResultUsed &&'], 'a/src/com/google/javascript/jscomp/CheckSideEffects.java', 'b/src/com/google/javascript/jscomp/CheckSideEffects.java']
['Closure-22', 1, 1, 1, 1, ['// Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && "eval".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; } String msg = "This code lacks side-effects. Is there a bug?"; if (n.isString()) { msg = "Is there a missing \'+\' on the previous line?";'], ['// Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult() || n.isBlock()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = "This code lacks side-effects. Is there a bug?"; if (n.isString()) { msg = "Is there a missing \'+\' on the previous line?";'], ['if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && "eval".equals(n.getNext().getString())) { } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { } if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; }'], ['if (n.isExprResult() || n.isBlock()) { if (n.isQualifiedName() && n.getJSDocInfo() != null) {'], 'a/src/com/google/javascript/jscomp/CheckSideEffects.java', 'b/src/com/google/javascript/jscomp/CheckSideEffects.java']
['Closure-23', 1, 1, 1, 1, [' Node current = left.getFirstChild(); Node elem = null; for (int i = 0; current != null && i < intIndex; i++) { elem = current; current = current.getNext(); }'], [' Node current = left.getFirstChild(); Node elem = null; for (int i = 0; current != null; i++) { if (i != intIndex) { if (mayHaveSideEffects(current)) { return n; } } else { elem = current; } current = current.getNext(); }'], ['for (int i = 0; current != null && i < intIndex; i++) {'], ['for (int i = 0; current != null; i++) { if (i != intIndex) { if (mayHaveSideEffects(current)) { return n; } } else { }'], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-24', 2, 2, 2, 2, ['Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.isVar()) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar);', 'String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. // Parameters of the scope function also get a BAD_PARAMETERS // error. } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } }'], ['Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar);', 'String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. } else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } }'], ['if (parent.isVar()) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {', '}'], ['if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) {', '} else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) {'], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-25', 2, 2, 2, 2, ['} private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) {', '} if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } return scope; }'], ['} private FlowScope traverseNew(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node constructor = n.getFirstChild(); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) {', '} if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); backwardsInferenceFromCallSite(n, ct); } } } n.setJSType(type); return scope; }'], ['scope = traverse(constructor, scope);', 'for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); }'], ['scope = traverseChildren(n, scope);', 'backwardsInferenceFromCallSite(n, ct);'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['Closure-26', 3, 3, 3, 3, ['AbstractPostOrderCallback { private int scriptNodeCount = 0; @Override public void visit(NodeTraversal t, Node n, Node parent) {', '*/ private void emitOptionalModuleExportsOverride(Node script, String moduleName) { Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string("module$exports"));', 'Node exports = prop.getChildAtIndex(1); exports.putProp(Node.ORIGINALNAME_PROP, "exports"); exports.setString("module$exports"); } /**'], ['AbstractPostOrderCallback { private int scriptNodeCount = 0; private Set<String> modulesWithExports = Sets.newHashSet(); @Override public void visit(NodeTraversal t, Node n, Node parent) {', '*/ private void emitOptionalModuleExportsOverride(Node script, String moduleName) { if (!modulesWithExports.contains(moduleName)) { return; } Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string("module$exports"));', 'Node exports = prop.getChildAtIndex(1); exports.putProp(Node.ORIGINALNAME_PROP, "exports"); exports.setString("module$exports"); modulesWithExports.add(moduleName); } /**'], ['', '', ''], ['private Set<String> modulesWithExports = Sets.newHashSet();', 'if (!modulesWithExports.contains(moduleName)) { return; }', 'modulesWithExports.add(moduleName);'], 'a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java', 'b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java']
['Closure-27', 3, 3, 3, 3, ['return block; } public static Node script(Node ... stmts) { // TODO(johnlenz): finish setting up the SCRIPT node', '} public static Node tryFinally(Node tryBody, Node finallyBody) { Preconditions.checkState(tryBody.isLabelName()); Preconditions.checkState(finallyBody.isLabelName()); Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); }', 'public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); Node catchBody = block(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); }'], ['return block; } private static Node blockUnchecked(Node stmt) { return new Node(Token.BLOCK, stmt); } public static Node script(Node ... stmts) { // TODO(johnlenz): finish setting up the SCRIPT node', '} public static Node tryFinally(Node tryBody, Node finallyBody) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(finallyBody.isBlock()); Node catchBody = block().copyInformationFrom(tryBody); return new Node(Token.TRY, tryBody, catchBody, finallyBody); }', 'public static Node tryCatch(Node tryBody, Node catchNode) { Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(catchNode.isCatch()); Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode); return new Node(Token.TRY, tryBody, catchBody); }'], ['', 'Preconditions.checkState(tryBody.isLabelName()); Preconditions.checkState(finallyBody.isLabelName());', 'Node catchBody = block(catchNode).copyInformationFrom(catchNode);'], ['private static Node blockUnchecked(Node stmt) { return new Node(Token.BLOCK, stmt); }', 'Preconditions.checkState(tryBody.isBlock()); Preconditions.checkState(finallyBody.isBlock());', 'Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);'], 'a/src/com/google/javascript/rhino/IR.java', 'b/src/com/google/javascript/rhino/IR.java']
['Closure-28', 1, 1, 1, 1, ["* Constants (true, false, null) are considered basically free, * because it's likely that they will get folded when we're done. */ } }"], ['* Constants (true, false, null) are considered basically free, * because it\'s likely that they will get folded when we\'re done. */ @Override void addConstant(String newcode) { add("0"); } } }'], [''], ['@Override void addConstant(String newcode) { add("0"); }'], 'a/src/com/google/javascript/jscomp/InlineCostEstimator.java', 'b/src/com/google/javascript/jscomp/InlineCostEstimator.java']
['Closure-29', 3, 3, 3, 3, ['*/ private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent();', "// We short-circuit this problem by bailing out if we see a reference // to a property that isn't defined on the object literal. This // isn't a perfect algorithm, but it should catch most cases. continue; }", 'return false; } Node childVal = child.getFirstChild(); // Check if childVal is the parent of any of the passed in'], ['*/ private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent();', "// We short-circuit this problem by bailing out if we see a reference // to a property that isn't defined on the object literal. This // isn't a perfect algorithm, but it should catch most cases. String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; }", 'return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); // Check if childVal is the parent of any of the passed in'], ['', '', ''], ['Set<String> validProperties = Sets.newHashSet();', 'String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } }', 'validProperties.add(child.getString());'], 'a/src/com/google/javascript/jscomp/InlineObjectLiterals.java', 'b/src/com/google/javascript/jscomp/InlineObjectLiterals.java']
['Closure-30', 4, 4, 4, 4, [' @Override public void process(Node externs, Node root) { (new NodeTraversal(compiler, this)).traverse(root); } @Override', 'private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); Definition(Node node) { this.node = node;', 'new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && jsScope.isDeclared(n.getString(), true)) { Var dep = jsScope.getVar(n.getString()); def.depends.add(dep); } } });', 'GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); for (Var s : def.depends) { if (s.scope != jsScope) {'], [' @Override public void process(Node externs, Node root) { (new NodeTraversal(compiler, this)).traverseRoots(externs, root); } @Override', 'private static class Definition { final Node node; final Set<Var> depends = Sets.newHashSet(); private boolean unknownDependencies = false; Definition(Node node) { this.node = node;', 'new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName()) { Var dep = jsScope.getVar(n.getString()); if (dep == null) { def.unknownDependencies = true; } else { def.depends.add(dep); } } } });', 'GraphNode<Node, Branch> n = getCfg().getNode(useNode); FlowState<MustDef> state = n.getAnnotation(); Definition def = state.getIn().reachingDef.get(jsScope.getVar(name)); if (def.unknownDependencies) { return true; } for (Var s : def.depends) { if (s.scope != jsScope) {'], ['(new NodeTraversal(compiler, this)).traverse(root);', '', 'if (n.isName() && jsScope.isDeclared(n.getString(), true)) {', ''], ['(new NodeTraversal(compiler, this)).traverseRoots(externs, root);', 'private boolean unknownDependencies = false;', 'if (n.isName()) { if (dep == null) { def.unknownDependencies = true; } else { }', 'if (def.unknownDependencies) { return true; }'], 'a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java', 'b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java']
['Closure-31', 1, 1, 1, 1, [' // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they'], [' // Check if the sources need to be re-ordered. if (options.dependencyOptions.needsManagement() && options.closurePass) { for (CompilerInput input : inputs) { // Forward-declare all the provided types, so that they'], ['!options.skipAllPasses &&'], [''], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-32', 4, 4, 4, 4, ["// Track the start of the line to count whitespace that // the tokenizer skipped. Because this case is rare, it's easier // to do this here than in the tokenizer. do { switch (token) { case STAR: if (ignoreStar) { // Mark the position after the star as the new start of the line. } else { // The star is part of the comment. if (builder.length() > 0) {", '} ignoreStar = true; token = next(); continue;', 'ignoreStar = false; state = State.SEARCHING_ANNOTATION; // All tokens must be separated by a space. if (token == JsDocToken.EOC || token == JsDocToken.EOF ||', "return new ExtractionInfo(multilineText, token); } if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine();"], ["// Track the start of the line to count whitespace that // the tokenizer skipped. Because this case is rare, it's easier // to do this here than in the tokenizer. int lineStartChar = -1; do { switch (token) { case STAR: if (ignoreStar) { // Mark the position after the star as the new start of the line. lineStartChar = stream.getCharno() + 1; } else { // The star is part of the comment. if (builder.length() > 0) {", '} ignoreStar = true; lineStartChar = 0; token = next(); continue;', "ignoreStar = false; state = State.SEARCHING_ANNOTATION; boolean isEOC = token == JsDocToken.EOC; if (!isEOC) { if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { int numSpaces = stream.getCharno() - lineStartChar; for (int i = 0; i < numSpaces; i++) { builder.append(' '); } lineStartChar = -1; } else if (builder.length() > 0) { // All tokens must be separated by a space. builder.append(' '); } } if (token == JsDocToken.EOC || token == JsDocToken.EOF ||", 'return new ExtractionInfo(multilineText, token); } builder.append(toString(token)); line = stream.getRemainingJSDocLine();'], ['', '', '', "if (builder.length() > 0) { builder.append(' '); }"], ['int lineStartChar = -1; lineStartChar = stream.getCharno() + 1;', 'lineStartChar = 0;', "boolean isEOC = token == JsDocToken.EOC; if (!isEOC) { if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { int numSpaces = stream.getCharno() - lineStartChar; for (int i = 0; i < numSpaces; i++) { builder.append(' '); } lineStartChar = -1; } else if (builder.length() > 0) { builder.append(' '); } }", ''], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-33', 1, 1, 1, 1, ['@Override public void matchConstraint(ObjectType constraintObj) { // We only want to match contraints on anonymous types. // Handle the case where the constraint object is a record type. //'], ['@Override public void matchConstraint(ObjectType constraintObj) { // We only want to match contraints on anonymous types. if (hasReferenceName()) { return; } // Handle the case where the constraint object is a record type. //'], [''], ['if (hasReferenceName()) { return; }'], 'a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java', 'b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java']
['Closure-34', 3, 3, 3, 3, ['cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p + 1, rhsContext); } return; }', 'Node current = firstNonOperator; do { current = current.getParent(); cc.listSeparator(); addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext); } while (current != n); }', '@Override void appendOp(String op, boolean binOp) { if (binOp) { if (getLastChar() != \' \') { append(" "); } append(op);'], ['cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else { unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1); } return; }', 'Node current = firstNonOperator; do { current = current.getParent(); cc.addOp(opStr, true); addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext); } while (current != n); }', '@Override void appendOp(String op, boolean binOp) { if (binOp) { if (getLastChar() != \' \' && op.charAt(0) != \',\') { append(" "); } append(op);'], ['addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p + 1, rhsContext);', 'cc.listSeparator();', "if (getLastChar() != ' ') {"], ['unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);', 'cc.addOp(opStr, true);', "if (getLastChar() != ' ' && op.charAt(0) != ',') {"], 'a/src/com/google/javascript/jscomp/CodePrinter.java', 'b/src/com/google/javascript/jscomp/CodePrinter.java']
['Closure-35', 1, 1, 1, 1, [' ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } } }'], [' ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null) { type.matchConstraint(constraintObj); } }'], ['if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } }'], ['if (constraintObj != null) { type.matchConstraint(constraintObj);'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['Closure-36', 1, 1, 1, 1, [" // issue 668: Don't inline singleton getter methods // calls as this confused class removing logic. } }"], [" // issue 668: Don't inline singleton getter methods // calls as this confused class removing logic. if (convention.getSingletonGetterClassName(callNode) != null) { return false; } } }"], [''], ['if (convention.getSingletonGetterClassName(callNode) != null) { return false; }'], 'a/src/com/google/javascript/jscomp/InlineVariables.java', 'b/src/com/google/javascript/jscomp/InlineVariables.java']
['Closure-37', 2, 2, 2, 2, [' // Body Preconditions.checkState(body.getNext() == null && body.isBlock()); traverseBranch(body, n); popScope();', "node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); // When in ideMode Rhino tries to parse some constructs the compiler // doesn't support, repair it here. see Rhino's // Parser#parseFunctionBodyExpr. parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"], [' // Body Preconditions.checkState(body.getNext() == null && body.isBlock(), body); traverseBranch(body, n); popScope();', "node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); if (!bodyNode.isBlock()) { // When in ideMode Rhino tries to parse some constructs the compiler // doesn't support, repair it here. see Rhino's // Parser#parseFunctionBodyExpr. Preconditions.checkState(config.isIdeMode); bodyNode = IR.block(); } parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node;"], ['body.isBlock());', ''], ['body.isBlock(), body);', 'if (!bodyNode.isBlock()) { Preconditions.checkState(config.isIdeMode); bodyNode = IR.block(); }'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-38', 1, 1, 1, 1, ['// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); if (x < 0 && prev == \'-\') { add(" "); }'], ['// x--4 (which is a syntax error). char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); if ((x < 0 || negativeZero) && prev == \'-\') { add(" "); }'], ["if (x < 0 && prev == '-') {"], ["if ((x < 0 || negativeZero) && prev == '-') {"], 'a/src/com/google/javascript/jscomp/CodeConsumer.java', 'b/src/com/google/javascript/jscomp/CodeConsumer.java']
['Closure-39', 2, 2, 2, 2, [' sb.append(property); sb.append(": "); sb.append(getPropertyType(property).toString()); ++i; if (i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(", ..."); break; }', 'prettyPrint = true; return sb.toString(); } else { return "{...}"; } }'], [' sb.append(property); sb.append(": "); sb.append(getPropertyType(property).toStringHelper(forAnnotations)); ++i; if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(", ..."); break; }', 'prettyPrint = true; return sb.toString(); } else { return forAnnotations ? "?" : "{...}"; } }'], ['sb.append(getPropertyType(property).toString()); if (i == MAX_PRETTY_PRINTED_PROPERTIES) {', 'return "{...}";'], ['sb.append(getPropertyType(property).toStringHelper(forAnnotations)); if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {', 'return forAnnotations ? "?" : "{...}";'], 'a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java', 'b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java']
['Closure-40', 1, 1, 1, 1, ['Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { JsName name = getName(ns.name, false); if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } } }'], ['Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { JsName name = getName(ns.name, true); refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } }'], ['JsName name = getName(ns.name, false); if (name != null) { }'], ['JsName name = getName(ns.name, true);'], 'a/src/com/google/javascript/jscomp/NameAnalyzer.java', 'b/src/com/google/javascript/jscomp/NameAnalyzer.java']
['Closure-41', 2, 2, 2, 2, ["} // Clone any remaining params that aren't in the function literal. parametersNode = paramBuilder.build(); }", "} // Copy over any old parameters that aren't in the param list. if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName);"], ["} // Clone any remaining params that aren't in the function literal. while (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); } parametersNode = paramBuilder.build(); }", "} // Copy over any old parameters that aren't in the param list. if (!isVarArgs) { while (oldParameterType != null && !isVarArgs) { builder.newParameterFromNode(oldParameterType); oldParameterType = oldParameterType.getNext(); } } if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName);"], ['', ''], ['while (oldParams.hasNext()) { paramBuilder.newParameterFromNode(oldParams.next()); }', 'if (!isVarArgs) { while (oldParameterType != null && !isVarArgs) { builder.newParameterFromNode(oldParameterType); oldParameterType = oldParameterType.getNext(); } }'], 'a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java', 'b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java']
['Closure-42', 1, 1, 1, 1, [' @Override Node processForInLoop(ForInLoop loopNode) { // Return the bare minimum to put the AST in a valid state. return newNode( Token.FOR, transform(loopNode.getIterator()),'], [' @Override Node processForInLoop(ForInLoop loopNode) { if (loopNode.isForEach()) { errorReporter.error( "unsupported language extension: for each", sourceName, loopNode.getLineno(), "", 0); // Return the bare minimum to put the AST in a valid state. return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } return newNode( Token.FOR, transform(loopNode.getIterator()),'], [''], ['if (loopNode.isForEach()) { errorReporter.error( "unsupported language extension: for each", sourceName, loopNode.getLineno(), "", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); }'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-43', 3, 3, 3, 3, ['* For more information, see * http://code.google.com/p/closure-compiler/issues/detail?id=314 */ /** * Type-less stubs.', '} // Analyze any @lends object literals in this statement. } private void attachLiteralTypes(NodeTraversal t, Node n) {', 'break; case Token.OBJECTLIT: defineObjectLiteral(n); break; // NOTE(nicksantos): If we ever support Array tuples,'], ['* For more information, see * http://code.google.com/p/closure-compiler/issues/detail?id=314 */ private List<Node> lentObjectLiterals = null; /** * Type-less stubs.', '} // Analyze any @lends object literals in this statement. if (n.getParent() != null && NodeUtil.isStatement(n) && lentObjectLiterals != null) { for (Node objLit : lentObjectLiterals) { defineObjectLiteral(objLit); } lentObjectLiterals.clear(); } } private void attachLiteralTypes(NodeTraversal t, Node n) {', 'break; case Token.OBJECTLIT: JSDocInfo info = n.getJSDocInfo(); if (info != null && info.getLendsName() != null) { if (lentObjectLiterals == null) { lentObjectLiterals = Lists.newArrayList(); } lentObjectLiterals.add(n); } else { defineObjectLiteral(n); } break; // NOTE(nicksantos): If we ever support Array tuples,'], ['', '', ''], ['private List<Node> lentObjectLiterals = null;', 'if (n.getParent() != null && NodeUtil.isStatement(n) && lentObjectLiterals != null) { for (Node objLit : lentObjectLiterals) { defineObjectLiteral(objLit); } lentObjectLiterals.clear(); }', 'JSDocInfo info = n.getJSDocInfo(); if (info != null && info.getLendsName() != null) { if (lentObjectLiterals == null) { lentObjectLiterals = Lists.newArrayList(); } lentObjectLiterals.add(n); } else { }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-44', 1, 1, 1, 1, ['// need space to separate. This is not pretty printing. // For example: "return foo;" append(" "); // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / } append(newcode);'], ['// need space to separate. This is not pretty printing. // For example: "return foo;" append(" "); } else if (c == \'/\' && getLastChar() == \'/\') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / append(" "); } append(newcode);'], [''], ['} else if (c == \'/\' && getLastChar() == \'/\') { append(" ");'], 'a/src/com/google/javascript/jscomp/CodeConsumer.java', 'b/src/com/google/javascript/jscomp/CodeConsumer.java']
['Closure-45', 3, 3, 3, 3, ['assignedToUnknownValue = true; } for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true;', 'assign.assignNode.getLastChild(), true)) { assignedToUnknownValue = true; } } if (assignedToUnknownValue && hasPropertyAssign) { changes = markReferencedVar(var) || changes; maybeUnreferenced.remove(current); current--;', 'this.nameNode = nameNode; this.isPropertyAssign = isPropertyAssign; this.maybeAliased = !assignNode.getParent().isExprResult(); this.mayHaveSecondarySideEffects = maybeAliased || NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||'], ['assignedToUnknownValue = true; } boolean maybeEscaped = false; for (Assign assign : assignsByVar.get(var)) { if (assign.isPropertyAssign) { hasPropertyAssign = true;', 'assign.assignNode.getLastChild(), true)) { assignedToUnknownValue = true; } if (assign.maybeAliased) { maybeEscaped = true; } } if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) { changes = markReferencedVar(var) || changes; maybeUnreferenced.remove(current); current--;', 'this.nameNode = nameNode; this.isPropertyAssign = isPropertyAssign; this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode); this.mayHaveSecondarySideEffects = maybeAliased || NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||'], ['', 'if (assignedToUnknownValue && hasPropertyAssign) {', 'this.maybeAliased = !assignNode.getParent().isExprResult();'], ['boolean maybeEscaped = false;', 'if (assign.maybeAliased) { maybeEscaped = true; } if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {', 'this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);'], 'a/src/com/google/javascript/jscomp/RemoveUnusedVars.java', 'b/src/com/google/javascript/jscomp/RemoveUnusedVars.java']
['Closure-46', 1, 1, 1, 1, ['propertyNode); } @Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();'], ['propertyNode); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType();'], ['@Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }'], [''], 'a/src/com/google/javascript/rhino/jstype/RecordType.java', 'b/src/com/google/javascript/rhino/jstype/RecordType.java']
['Closure-47', 2, 2, 2, 2, ['// Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) .setLineNumber(entry.getSourceLine()) .setColumnPosition(entry.getSourceColumn()); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); }', "// zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. generator.addMapping( sourceFile, originalName, new FilePosition(node.getLineno(), node.getCharno()), outputStartPosition, outputEndPosition); }"], ['// Adjust the line/column here to be start at 1. Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) .setLineNumber(entry.getSourceLine() + 1) .setColumnPosition(entry.getSourceColumn() + 1); if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); }', "// zero based. // We don't change this for the v1 or v2 source maps but for // v3 we make them both 0 based. int lineBaseOffset = 1; if (generator instanceof SourceMapGeneratorV1 || generator instanceof SourceMapGeneratorV2) { lineBaseOffset = 0; } generator.addMapping( sourceFile, originalName, new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()), outputStartPosition, outputEndPosition); }"], ['.setLineNumber(entry.getSourceLine()) .setColumnPosition(entry.getSourceColumn());', 'new FilePosition(node.getLineno(), node.getCharno()),'], ['.setLineNumber(entry.getSourceLine() + 1) .setColumnPosition(entry.getSourceColumn() + 1);', 'int lineBaseOffset = 1; if (generator instanceof SourceMapGeneratorV1 || generator instanceof SourceMapGeneratorV2) { lineBaseOffset = 0; } new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),'], 'a/src/com/google/javascript/jscomp/SourceMap.java', 'b/src/com/google/javascript/jscomp/SourceMap.java']
['Closure-48', 1, 1, 1, 1, ['|| FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false))); } if (!inferred) {'], ['|| FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred && rhsValue != null && rhsValue.isFunction()) { // Determining declaration for #2 if (info != null) { inferred = false; } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { inferred = false; } } if (!inferred) {'], ['if (inferred) { inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));'], ['if (inferred && rhsValue != null && rhsValue.isFunction()) { if (info != null) { inferred = false; } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { inferred = false; }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-49', 3, 3, 3, 3, ['renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() == Token.FUNCTION) { for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else if (declarationRoot.getType() != Token.FUNCTION) { // Add the block declarations findDeclaredNames(declarationRoot, null, renamer);', 'renamer.addDeclaredName(name); } // Add the function parameters // Add the function body declarations nameStack.push(renamer); }', ' case Token.FUNCTION: // Remove the function body scope // Remove function recursive name (if any). nameStack.pop(); break; // Note: The parameters and function body variables live in the // same scope, we introduce the scope when in the "shouldTraverse" // visit of LP, but remove it when when we exit the function above. case Token.CATCH: // Remove catch except name from the stack of names.'], ['renamer = nameStack.peek().forChildScope(); } if (declarationRoot.getType() != Token.FUNCTION) { // Add the block declarations findDeclaredNames(declarationRoot, null, renamer);', 'renamer.addDeclaredName(name); } nameStack.push(renamer); } break; case Token.LP: { Renamer renamer = nameStack.peek().forChildScope(); // Add the function parameters for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } // Add the function body declarations Node functionBody = n.getNext(); findDeclaredNames(functionBody, null, renamer); nameStack.push(renamer); }', ' case Token.FUNCTION: // Remove the function body scope nameStack.pop(); // Remove function recursive name (if any). nameStack.pop(); break; case Token.LP: // Note: The parameters and function body variables live in the // same scope, we introduce the scope when in the "shouldTraverse" // visit of LP, but remove it when when we exit the function above. break; case Token.CATCH: // Remove catch except name from the stack of names.'], ['if (declarationRoot.getType() == Token.FUNCTION) { for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); } else', '', ''], ['', 'nameStack.push(renamer); } break; case Token.LP: { Renamer renamer = nameStack.peek().forChildScope(); for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = n.getNext(); findDeclaredNames(functionBody, null, renamer);', 'nameStack.pop(); case Token.LP: break;'], 'a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java', 'b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java']
['Closure-50', 2, 2, 2, 2, [' Node right = callTarget.getNext(); if (right != null) { if (!NodeUtil.isImmutableValue(right)) { return n; } }', 'return n; } // "," is the default, it doesn\'t need to be explicit String joinString = (right == null) ? "," : NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList();'], [' Node right = callTarget.getNext(); if (right != null) { if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) { return n; } }', 'return n; } if (right != null && right.getType() == Token.STRING && ",".equals(right.getString())) { // "," is the default, it doesn\'t need to be explicit n.removeChild(right); reportCodeChange(); } String joinString = (right == null) ? "," : NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList();'], ['if (!NodeUtil.isImmutableValue(right)) {', ''], ['if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {', 'if (right != null && right.getType() == Token.STRING && ",".equals(right.getString())) { n.removeChild(right); reportCodeChange(); }'], 'a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java', 'b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java']
['Closure-51', 2, 2, 2, 2, ['add(" "); } if ((long) x == x) { long value = (long) x; long mantissa = value; int exp = 0;', '} else { add(String.valueOf(x)); } } static boolean isWordChar(char ch) {'], ['add(" "); } if ((long) x == x && !isNegativeZero(x)) { long value = (long) x; long mantissa = value; int exp = 0;', '} else { add(String.valueOf(x)); } } static boolean isNegativeZero(double x) { return x == 0.0 && Math.copySign(1, x) == -1.0; } static boolean isWordChar(char ch) {'], ['if ((long) x == x) {', ''], ['if ((long) x == x && !isNegativeZero(x)) {', '} static boolean isNegativeZero(double x) { return x == 0.0 && Math.copySign(1, x) == -1.0;'], 'a/src/com/google/javascript/jscomp/CodeConsumer.java', 'b/src/com/google/javascript/jscomp/CodeConsumer.java']
['Closure-52', 1, 1, 1, 1, ['return false; } } return len > 0; } static double getSimpleNumber(String s) {'], ["return false; } } return len > 0 && s.charAt(0) != '0'; } static double getSimpleNumber(String s) {"], ['return len > 0;'], ["return len > 0 && s.charAt(0) != '0';"], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-53', 2, 2, 2, 2, ['} Node replacement; // All assignments evaluate to true, so make sure that the // expr statement evaluates to true in case it matters. nodes.add(new Node(Token.TRUE));', '} cur.addChildToFront(nodes.get(i)); cur.addChildToFront(nodes.get(i + 1)); Node replace = ref.getParent(); replacement.copyInformationFromForTree(replace);'], ['} Node replacement; if (nodes.isEmpty()) { replacement = new Node(Token.TRUE); } else { // All assignments evaluate to true, so make sure that the // expr statement evaluates to true in case it matters. nodes.add(new Node(Token.TRUE));', '} cur.addChildToFront(nodes.get(i)); cur.addChildToFront(nodes.get(i + 1)); } Node replace = ref.getParent(); replacement.copyInformationFromForTree(replace);'], ['', ''], ['if (nodes.isEmpty()) { replacement = new Node(Token.TRUE); } else {', '}'], 'a/src/com/google/javascript/jscomp/InlineObjectLiterals.java', 'b/src/com/google/javascript/jscomp/InlineObjectLiterals.java']
['Closure-54', 3, 3, 3, 3, ["// then they are responsible for making sure that the object literal's // implicit prototype is set up appropriately. We just obey // the @extends tag. if (!qVar.isTypeInferred()) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to some arbitrary expression, // there's not much we can do. We just ignore the expression,", '// // In the second case, we just use the anonymous object as the prototype. if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {', 'return false; } boolean replacedPrototype = prototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot("prototype", prototype, true); this.prototype.setOwnerFunction(this); // Disassociating the old prototype makes this easier to debug-- // we don\'t have to worry about two prototypes running around. if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor();'], ["// then they are responsible for making sure that the object literal's // implicit prototype is set up appropriately. We just obey // the @extends tag. ObjectType qVarType = ObjectType.cast(qVar.getType()); if (qVarType != null && rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) { typeRegistry.resetImplicitPrototype( rhsValue.getJSType(), qVarType.getImplicitPrototype()); } else if (!qVar.isTypeInferred()) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to some arbitrary expression, // there's not much we can do. We just ignore the expression,", '// // In the second case, we just use the anonymous object as the prototype. if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {', 'return false; } PrototypeObjectType oldPrototype = this.prototype; boolean replacedPrototype = oldPrototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot("prototype", prototype, true); this.prototype.setOwnerFunction(this); if (oldPrototype != null) { // Disassociating the old prototype makes this easier to debug-- // we don\'t have to worry about two prototypes running around. oldPrototype.setOwnerFunction(null); } if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor();'], ['if (!qVar.isTypeInferred()) {', 'baseType.isUnknownType() ||', 'boolean replacedPrototype = prototype != null;'], ['ObjectType qVarType = ObjectType.cast(qVar.getType()); if (qVarType != null && rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) { typeRegistry.resetImplicitPrototype( rhsValue.getJSType(), qVarType.getImplicitPrototype()); } else if (!qVar.isTypeInferred()) {', '', 'PrototypeObjectType oldPrototype = this.prototype; boolean replacedPrototype = oldPrototype != null; if (oldPrototype != null) { oldPrototype.setOwnerFunction(null); }'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-55', 1, 1, 1, 1, ['} private static boolean isReduceableFunctionExpression(Node n) { return NodeUtil.isFunctionExpression(n); } /**'], ['} private static boolean isReduceableFunctionExpression(Node n) { return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent()); } /**'], ['return NodeUtil.isFunctionExpression(n);'], ['return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent());'], 'a/src/com/google/javascript/jscomp/FunctionRewriter.java', 'b/src/com/google/javascript/jscomp/FunctionRewriter.java']
['Closure-56', 1, 1, 1, 1, ["// If next new line cannot be found, there are two cases // 1. pos already reaches the end of file, then null should be returned // 2. otherwise, return the contents between pos and the end of file. return null; } else { return js.substring(pos, js.indexOf('\\n', pos)); }"], ["// If next new line cannot be found, there are two cases // 1. pos already reaches the end of file, then null should be returned // 2. otherwise, return the contents between pos and the end of file. if (pos >= js.length()) { return null; } else { return js.substring(pos, js.length()); } } else { return js.substring(pos, js.indexOf('\\n', pos)); }"], [''], ['if (pos >= js.length()) { } else { return js.substring(pos, js.length()); }'], 'a/src/com/google/javascript/jscomp/SourceFile.java', 'b/src/com/google/javascript/jscomp/SourceFile.java']
['Closure-57', 1, 1, 1, 1, ['String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null) { className = target.getString(); } }'], ['String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null && target.getType() == Token.STRING) { className = target.getString(); } }'], ['if (target != null) {'], ['if (target != null && target.getType() == Token.STRING) {'], 'a/src/com/google/javascript/jscomp/ClosureCodingConvention.java', 'b/src/com/google/javascript/jscomp/ClosureCodingConvention.java']
['Closure-58', 1, 1, 1, 1, ['// for(var x in y) {...} lhs = lhs.getLastChild(); } addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); computeGenKill(rhs, gen, kill, conditional); } return;'], ['// for(var x in y) {...} lhs = lhs.getLastChild(); } if (NodeUtil.isName(lhs)) { addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); } else { computeGenKill(lhs, gen, kill, conditional); } computeGenKill(rhs, gen, kill, conditional); } return;'], [''], ['if (NodeUtil.isName(lhs)) { } else { computeGenKill(lhs, gen, kill, conditional); }'], 'a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java', 'b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java']
['Closure-59', 1, 1, 1, 1, ['CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);'], ['CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);'], ['if (options.checkGlobalThisLevel.isOn()) {'], ['if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) {'], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-60', 2, 2, 2, 2, ['// ignoring side-effects return TernaryValue.TRUE; default: return getPureBooleanValue(n);', 'return TernaryValue.FALSE; case Token.VOID: return TernaryValue.FALSE; case Token.NAME: String name = n.getString();'], ['// ignoring side-effects return TernaryValue.TRUE; case Token.VOID: return TernaryValue.FALSE; default: return getPureBooleanValue(n);', 'return TernaryValue.FALSE; case Token.VOID: if (!mayHaveSideEffects(n.getFirstChild())) { return TernaryValue.FALSE; } break; case Token.NAME: String name = n.getString();'], ['', ''], ['case Token.VOID: return TernaryValue.FALSE;', 'if (!mayHaveSideEffects(n.getFirstChild())) { } break;'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-61', 1, 1, 1, 1, ['} // Functions in the "Math" namespace have no side effects. if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP'], ['} // Functions in the "Math" namespace have no side effects. if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals("Math")) { return false; } } if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP'], [''], ['if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals("Math")) { return false; } }'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-62', 1, 1, 1, 1, ['// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {'], ['// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {'], ['&& 0 <= charno && charno < sourceExcerpt.length()) {'], ['&& 0 <= charno && charno <= sourceExcerpt.length()) {'], 'a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java', 'b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java']
['Closure-63', 1, 1, 1, 1, ['// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {'], ['// charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) {'], ['&& 0 <= charno && charno < sourceExcerpt.length()) {'], ['&& 0 <= charno && charno <= sourceExcerpt.length()) {'], 'a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java', 'b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java']
['Closure-64', 2, 2, 2, 2, [" // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict' // for the first input file String code = toSource(root, sourceMap); if (!code.isEmpty()) { cb.append(code);", '@Override String toSource(Node n) { initCompilerOptionsIfTesting(); return toSource(n, null); } /** * Generates JavaScript source code for an AST. */ private String toSource(Node n, SourceMap sourceMap) { CodePrinter.Builder builder = new CodePrinter.Builder(n); builder.setPrettyPrint(options.prettyPrint); builder.setLineBreak(options.lineBreak); builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); builder.setTagAsStrict( options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT); builder.setLineLengthThreshold(options.lineLengthThreshold);'], [" // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict' // for the first input file String code = toSource(root, sourceMap, inputSeqNum == 0); if (!code.isEmpty()) { cb.append(code);", '@Override String toSource(Node n) { initCompilerOptionsIfTesting(); return toSource(n, null, true); } /** * Generates JavaScript source code for an AST. */ private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) { CodePrinter.Builder builder = new CodePrinter.Builder(n); builder.setPrettyPrint(options.prettyPrint); builder.setLineBreak(options.lineBreak); builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); builder.setTagAsStrict(firstOutput && options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT); builder.setLineLengthThreshold(options.lineLengthThreshold);'], ['String code = toSource(root, sourceMap);', 'return toSource(n, null); private String toSource(Node n, SourceMap sourceMap) { builder.setTagAsStrict('], ['String code = toSource(root, sourceMap, inputSeqNum == 0);', 'return toSource(n, null, true); private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) { builder.setTagAsStrict(firstOutput &&'], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-65', 1, 1, 1, 1, ['for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case \'\\0\': sb.append("\\\\0"); break; case \'\\n\': sb.append("\\\\n"); break; case \'\\r\': sb.append("\\\\r"); break; case \'\\t\': sb.append("\\\\t"); break;'], ['for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case \'\\0\': sb.append("\\\\000"); break; case \'\\n\': sb.append("\\\\n"); break; case \'\\r\': sb.append("\\\\r"); break; case \'\\t\': sb.append("\\\\t"); break;'], ['case \'\\0\': sb.append("\\\\0"); break;'], ['case \'\\0\': sb.append("\\\\000"); break;'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-66', 1, 1, 1, 1, ['// Object literal keys are handled with OBJECTLIT if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); // Object literal keys are not typeable } break;'], ['// Object literal keys are handled with OBJECTLIT if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); } else { // Object literal keys are not typeable typeable = false; } break;'], [''], ['} else { typeable = false;'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-67', 1, 1, 1, 1, ['Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP ) { // We want to exclude the assignment itself from the usage list boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;'], ['Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP && assign.getParent().getType() == Token.EXPR_RESULT) { // We want to exclude the assignment itself from the usage list boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP;'], [') {'], ['&& assign.getParent().getType() == Token.EXPR_RESULT) {'], 'a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java', 'b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java']
['Closure-68', 3, 3, 3, 3, ['} break; } token = eatTokensUntilEOL(); } continue retry; } }', '} } return reportGenericTypeSyntaxWarning(); }', '// NOTE(nicksantos): We\'re not implementing generics at the moment, so // just throw out TypeParameters. if (token != JsDocToken.LP) { return reportTypeSyntaxWarning("msg.jsdoc.missing.lp"); }'], ['} break; } } token = eatTokensUntilEOL(); continue retry; } }', '} } restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); }', '// NOTE(nicksantos): We\'re not implementing generics at the moment, so // just throw out TypeParameters. if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning("msg.jsdoc.missing.lp"); }'], ['}', '', ''], ['}', 'restoreLookAhead(token);', 'restoreLookAhead(token);'], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-69', 1, 1, 1, 1, [" // Functions with explcit 'this' types must be called in a GETPROP // or GETELEM. visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType());"], [" // Functions with explcit 'this' types must be called in a GETPROP // or GETELEM. if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) { report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); } visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType());"], [''], ['if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) { report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); }'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-70', 1, 1, 1, 1, ['for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), true); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);'], ['for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, jsDocParameter.getJSType(), false); jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true);'], ['jsDocParameter.getJSType(), true);'], ['jsDocParameter.getJSType(), false);'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-71', 1, 1, 1, 1, ['if (objectType != null) { // Is this a normal property access, or are we trying to override // an existing property? boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;'], ['if (objectType != null) { // Is this a normal property access, or are we trying to override // an existing property? boolean isOverride = parent.getJSDocInfo() != null && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;'], ['boolean isOverride = t.inGlobalScope() &&'], ['boolean isOverride = parent.getJSDocInfo() != null &&'], 'a/src/com/google/javascript/jscomp/CheckAccessControls.java', 'b/src/com/google/javascript/jscomp/CheckAccessControls.java']
['Closure-72', 2, 2, 2, 2, ['"inline_", isCallInLoop))); // Make label names unique to this instance. } static class LabelNameSupplier implements Supplier<String> {', 'String name = nameNode.getString(); LabelInfo li = getLabelInfo(name); // This is a label... if (li.referenced) { String newName = getNameForId(li.id); if (!name.equals(newName)) { // ... and it is used, give it the short name.'], ['"inline_", isCallInLoop))); // Make label names unique to this instance. new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false) .process(null, fnNode); } static class LabelNameSupplier implements Supplier<String> {', 'String name = nameNode.getString(); LabelInfo li = getLabelInfo(name); // This is a label... if (li.referenced || !removeUnused) { String newName = getNameForId(li.id); if (!name.equals(newName)) { // ... and it is used, give it the short name.'], ['', 'if (li.referenced) {'], ['new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false) .process(null, fnNode);', 'if (li.referenced || !removeUnused) {'], 'a/src/com/google/javascript/jscomp/RenameLabels.java', 'b/src/com/google/javascript/jscomp/RenameLabels.java']
['Closure-73', 1, 1, 1, 1, ['// No charsetEncoder provided - pass straight latin characters // through, and escape the rest. Doing the explicit character // check is measurably faster than using the CharsetEncoder. if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,'], ['// No charsetEncoder provided - pass straight latin characters // through, and escape the rest. Doing the explicit character // check is measurably faster than using the CharsetEncoder. if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers,'], ['if (c > 0x1f && c <= 0x7f) {'], ['if (c > 0x1f && c < 0x7f) {'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-74', 2, 2, 2, 2, ['&& right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {', '/** * @return Translate NOT expressions into TRUE or FALSE when possible. */ /** * The result of the comparison as a Boolean or null if the'], ['&& right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = getNormalizedNodeType(left); int rhType = getNormalizedNodeType(right); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {', '/** * @return Translate NOT expressions into TRUE or FALSE when possible. */ private int getNormalizedNodeType(Node n) { int type = n.getType(); if (type == Token.NOT) { TernaryValue value = NodeUtil.getPureBooleanValue(n); switch (value) { case TRUE: return Token.TRUE; case FALSE: return Token.FALSE; } } return type; } /** * The result of the comparison as a Boolean or null if the'], ['int lhType = left.getType(); int rhType = right.getType();', ''], ['int lhType = getNormalizedNodeType(left); int rhType = getNormalizedNodeType(right);', 'private int getNormalizedNodeType(Node n) { int type = n.getType(); if (type == Token.NOT) { TernaryValue value = NodeUtil.getPureBooleanValue(n); switch (value) { case TRUE: return Token.TRUE; case FALSE: return Token.FALSE; } } return type; }'], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-75', 2, 2, 2, 2, ['} static Double getStringNumberValue(String rawJsString) { // vertical tab is not always whitespace String s = trimJsWhiteSpace(rawJsString); // return ScriptRuntime.toNumber(s);', "static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\\u000B': // <VT> return TernaryValue.TRUE; case ' ': // <SP> case '\\n': // <LF> case '\\r': // <CR>"], ['} static Double getStringNumberValue(String rawJsString) { if (rawJsString.contains("\\u000b")) { // vertical tab is not always whitespace return null; } String s = trimJsWhiteSpace(rawJsString); // return ScriptRuntime.toNumber(s);', 'static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case \'\\u000B\': // <VT> return TernaryValue.UNKNOWN; // IE says "no", EcmaScript says "yes" case \' \': // <SP> case \'\\n\': // <LF> case \'\\r\': // <CR>'], ['', 'return TernaryValue.TRUE;'], ['if (rawJsString.contains("\\u000b")) { return null; }', 'return TernaryValue.UNKNOWN; // IE says "no", EcmaScript says "yes"'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-76', 4, 4, 4, 4, ['// If the currently node is the first child of // AND/OR, be conservative only consider the READs // of the second operand. case Token.HOOK: // If current node is the condition, check each following // branch, otherwise it is a conditional branch and the // other branch can be ignored. default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); // If we see a READ or KILL there is no need to continue. if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } } n = n.getParent(); }', '*/ private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) {', '// Conditionals case Token.OR: case Token.AND: // With a AND/OR the first branch always runs, but the second is // may not. case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);', '// Expressions are evaluated left-right, depth first. for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE;'], ['// If the currently node is the first child of // AND/OR, be conservative only consider the READs // of the second operand. if (n.getNext() != null) { state = isVariableReadBeforeKill( n.getNext(), variable); if (state == VariableLiveness.KILL) { state = VariableLiveness.MAYBE_LIVE; } } break; case Token.HOOK: // If current node is the condition, check each following // branch, otherwise it is a conditional branch and the // other branch can be ignored. if (n.getNext() != null && n.getNext().getNext() != null) { state = checkHookBranchReadBeforeKill( n.getNext(), n.getNext().getNext(), variable); } break; default: for(Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { state = isVariableReadBeforeKill(sibling, variable); if (state != VariableLiveness.MAYBE_LIVE) { break; } } } // If we see a READ or KILL there is no need to continue. if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } n = n.getParent(); }', '*/ private VariableLiveness isVariableReadBeforeKill( Node n, String variable) { if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION return VariableLiveness.MAYBE_LIVE; } if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) {', '// Conditionals case Token.OR: case Token.AND: VariableLiveness v1 = isVariableReadBeforeKill( n.getFirstChild(), variable); VariableLiveness v2 = isVariableReadBeforeKill( n.getLastChild(), variable); // With a AND/OR the first branch always runs, but the second is // may not. if (v1 != VariableLiveness.MAYBE_LIVE) { return v1; } else if (v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else { return VariableLiveness.MAYBE_LIVE; } case Token.HOOK: VariableLiveness first = isVariableReadBeforeKill( n.getFirstChild(), variable); if (first != VariableLiveness.MAYBE_LIVE) { return first; } return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);', '// Expressions are evaluated left-right, depth first. for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } return VariableLiveness.MAYBE_LIVE;'], ['if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { } } }', '', '', 'if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION }'], ['if (n.getNext() != null) { state = isVariableReadBeforeKill( n.getNext(), variable); if (state == VariableLiveness.KILL) { state = VariableLiveness.MAYBE_LIVE; } } break; if (n.getNext() != null && n.getNext().getNext() != null) { state = checkHookBranchReadBeforeKill( n.getNext(), n.getNext().getNext(), variable); } break; if (state != VariableLiveness.MAYBE_LIVE) { break; } } }', 'if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION return VariableLiveness.MAYBE_LIVE; }', 'VariableLiveness v1 = isVariableReadBeforeKill( n.getFirstChild(), variable); VariableLiveness v2 = isVariableReadBeforeKill( n.getLastChild(), variable); if (v1 != VariableLiveness.MAYBE_LIVE) { return v1; } else if (v2 == VariableLiveness.READ) { return VariableLiveness.READ; } else { return VariableLiveness.MAYBE_LIVE; } VariableLiveness first = isVariableReadBeforeKill( n.getFirstChild(), variable); if (first != VariableLiveness.MAYBE_LIVE) { return first; }', ''], 'a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java', 'b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java']
['Closure-77', 1, 1, 1, 1, ['for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case \'\\n\': sb.append("\\\\n"); break; case \'\\r\': sb.append("\\\\r"); break; case \'\\t\': sb.append("\\\\t"); break;'], ['for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case \'\\0\': sb.append("\\\\0"); break; case \'\\n\': sb.append("\\\\n"); break; case \'\\r\': sb.append("\\\\r"); break; case \'\\t\': sb.append("\\\\t"); break;'], [''], ['case \'\\0\': sb.append("\\\\0"); break;'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-78', 1, 1, 1, 1, ['break; case Token.MOD: if (rval == 0) { error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right); return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right); return null; } result = lval / rval;'], ['break; case Token.MOD: if (rval == 0) { return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { return null; } result = lval / rval;'], ['error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right); error(DiagnosticType.error("JSC_DIVIDE_BY_0_ERROR", "Divide by 0"), right);'], [''], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-79', 2, 2, 2, 2, ['public void process(Node externs, Node root) { new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) .traverse(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer);', 'getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName); } /**'], ['public void process(Node externs, Node root) { new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) .traverseRoots(externs, root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer);', 'getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName); compiler.reportCodeChange(); } /**'], ['.traverse(root);', ''], ['.traverseRoots(externs, root);', 'compiler.reportCodeChange();'], 'a/src/com/google/javascript/jscomp/VarCheck.java', 'b/src/com/google/javascript/jscomp/VarCheck.java']
['Closure-80', 2, 2, 2, 2, ['// Inversion case Token.NOT: // delete operator returns a boolean. return true; default: return false;', 'case Token.OBJECTLIT: // Literals objects with non-literal children are allowed. return true; case Token.IN: // TODO(johnlenz): should IN operator be included in #isSimpleOperator? return true;'], ['// Inversion case Token.NOT: // delete operator returns a boolean. case Token.DELPROP: return true; default: return false;', 'case Token.OBJECTLIT: // Literals objects with non-literal children are allowed. return true; case Token.DELPROP: case Token.IN: // TODO(johnlenz): should IN operator be included in #isSimpleOperator? return true;'], ['', ''], ['case Token.DELPROP:', 'case Token.DELPROP:'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-81', 1, 1, 1, 1, ['Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { name = new Name(); name.setIdentifier(""); isUnnamedFunction = true;'], ['Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( "unnamed function statement", sourceName, functionNode.getLineno(), "", 0); } name = new Name(); name.setIdentifier(""); isUnnamedFunction = true;'], [''], ['int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( "unnamed function statement", sourceName, functionNode.getLineno(), "", 0); }'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-82', 1, 1, 1, 1, ['} public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType(); } public boolean isNumberObjectType() {'], ['} public final boolean isEmptyType() { return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); } public boolean isNumberObjectType() {'], ['return isNoType() || isNoObjectType() || isNoResolvedType();'], ['return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this);'], 'a/src/com/google/javascript/rhino/jstype/JSType.java', 'b/src/com/google/javascript/rhino/jstype/JSType.java']
['Closure-83', 1, 1, 1, 1, [' @Override public int parseArguments(Parameters params) throws CmdLineException { String param = params.getParameter(0); if (param == null) { setter.addValue(true);'], [' @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true);'], ['String param = params.getParameter(0);'], ['String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}'], 'a/src/com/google/javascript/jscomp/CommandLineRunner.java', 'b/src/com/google/javascript/jscomp/CommandLineRunner.java']
['Closure-84', 3, 3, 3, 3, ['@Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); return assign; }', 'operand.setDouble(-operand.getDouble()); return operand; } else { Node node = newNode(type, operand); if (exprNode.isPostfix()) {', '} } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {'], ['@Override Node processAssignment(Assignment assignmentNode) { Node assign = processInfixExpression(assignmentNode); Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) { errorReporter.error( "invalid assignment target", sourceName, target.getLineno(), "", 0); } return assign; }', 'operand.setDouble(-operand.getDouble()); return operand; } else { if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? "invalid increment target" : "invalid decrement target"; errorReporter.error( msg, sourceName, operand.getLineno(), "", 0); } } Node node = newNode(type, operand); if (exprNode.isPostfix()) {', '} } private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; } @Override Node processVariableDeclaration(VariableDeclaration declarationNode) {'], ['', '', ''], ['Node target = assign.getFirstChild(); if (!validAssignmentTarget(target)) { errorReporter.error( "invalid assignment target", sourceName, target.getLineno(), "", 0); }', 'if (type == Token.INC || type == Token.DEC) { if (!validAssignmentTarget(operand)) { String msg = (type == Token.INC) ? "invalid increment target" : "invalid decrement target"; errorReporter.error( msg, sourceName, operand.getLineno(), "", 0); } }', 'private boolean validAssignmentTarget(Node target) { switch (target.getType()) { case Token.NAME: case Token.GETPROP: case Token.GETELEM: return true; } return false; }'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-85', 3, 3, 3, 3, ['return n; } if (n.getParent() == null) { List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); if (outEdges.size() == 1) { return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); } } switch (n.getType()) { case Token.BLOCK: if (n.hasChildren()) { Node first = n.getFirstChild(); return tryRemoveUnconditionalBranching(first); } else { return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); } case Token.RETURN: if (n.hasChildren()) { break;', '(n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) { Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n)); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeDeadExprStatementSafely(n);', ' private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n); return next; }'], ['return n; } switch (n.getType()) { case Token.RETURN: if (n.hasChildren()) { break;', '(n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) { Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeDeadExprStatementSafely(n);', ' private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n); while (next != null && next.getType() == Token.BLOCK) { if (next.hasChildren()) { next = next.getFirstChild(); } else { next = computeFollowing(next); } } return next; }'], ['if (n.getParent() == null) { List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges(); if (outEdges.size() == 1) { return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue()); } } case Token.BLOCK: if (n.hasChildren()) { Node first = n.getFirstChild(); return tryRemoveUnconditionalBranching(first); } else { return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n)); }', 'Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));', ''], ['', 'Node fallThrough = computeFollowing(n);', 'while (next != null && next.getType() == Token.BLOCK) { if (next.hasChildren()) { next = next.getFirstChild(); } else { next = computeFollowing(next); } }'], 'a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java', 'b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java']
['Closure-86', 1, 1, 1, 1, ["// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) return true; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:"], ["// TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT:"], ['return true;'], ['return false;'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-87', 1, 1, 1, 1, ["if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild(); // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It's pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. // We only have to worry about methods with an implicit 'this' // param, or this doesn't happen. return NodeUtil.isExpressionNode(maybeExpr); } }"], ['if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node maybeExpr = n.getFirstChild(); if (maybeExpr.getType() == Token.EXPR_RESULT) { // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It\'s pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. if (maybeExpr.getFirstChild().getType() == Token.CALL) { Node calledFn = maybeExpr.getFirstChild().getFirstChild(); // We only have to worry about methods with an implicit \'this\' // param, or this doesn\'t happen. if (calledFn.getType() == Token.GETELEM) { return false; } else if (calledFn.getType() == Token.GETPROP && calledFn.getLastChild().getString().startsWith("on")) { return false; } } return true; } return false; } }'], ['return NodeUtil.isExpressionNode(maybeExpr);'], ['if (maybeExpr.getType() == Token.EXPR_RESULT) { if (maybeExpr.getFirstChild().getType() == Token.CALL) { Node calledFn = maybeExpr.getFirstChild().getFirstChild(); if (calledFn.getType() == Token.GETELEM) { return false; } else if (calledFn.getType() == Token.GETPROP && calledFn.getLastChild().getString().startsWith("on")) { return false; } } return true; } return false;'], 'a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java', 'b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java']
['Closure-88', 1, 1, 1, 1, ['Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. return VariableLiveness.KILL; } else { return VariableLiveness.READ;'], ['Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ;'], [''], ['Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; }'], 'a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java', 'b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java']
['Closure-89', 2, 2, 2, 2, ['Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); // Create the new alias node. Node nameNode = NodeUtil.newName(', "} // If this is aliased, then its properties can't be collapsed either. if (type != Type.FUNCTION && aliasingGets > 0) { return false; }"], ['Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } // Create the new alias node. Node nameNode = NodeUtil.newName(', "} // If this is aliased, then its properties can't be collapsed either. if (aliasingGets > 0) { return false; }"], ['', 'if (type != Type.FUNCTION && aliasingGets > 0) {'], ['if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); }', 'if (aliasingGets > 0) {'], 'a/src/com/google/javascript/jscomp/GlobalNamespace.java', 'b/src/com/google/javascript/jscomp/GlobalNamespace.java']
['Closure-90', 2, 2, 2, 2, ['// create interfaces JSType, ObjectType, FunctionType etc and have // separate implementation instead of the class hierarchy, so that // union types can also be object types, etc. if (!type.isSubtype( typeRegistry.getNativeType(OBJECT_TYPE))) { reportWarning(THIS_TYPE_NON_OBJECT, type.toString()); return false;', '// mean "nullable Foo". For certain tags (like @extends) we de-nullify // the name for them. JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }'], ['// create interfaces JSType, ObjectType, FunctionType etc and have // separate implementation instead of the class hierarchy, so that // union types can also be object types, etc. if (!type.restrictByNotNullOrUndefined().isSubtype( typeRegistry.getNativeType(OBJECT_TYPE))) { reportWarning(THIS_TYPE_NON_OBJECT, type.toString()); return false;', '// mean "nullable Foo". For certain tags (like @extends) we de-nullify // the name for them. JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }'], ['if (!type.isSubtype(', ''], ['if (!type.restrictByNotNullOrUndefined().isSubtype(', 'if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); }'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-91', 1, 1, 1, 1, ["} // Don't traverse functions that are getting lent to a prototype. } if (parent != null && parent.getType() == Token.ASSIGN) {"], ['} // Don\'t traverse functions that are getting lent to a prototype. Node gramps = parent.getParent(); if (NodeUtil.isObjectLitKey(parent, gramps)) { JSDocInfo maybeLends = gramps.getJSDocInfo(); if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith(".prototype")) { return false; } } } if (parent != null && parent.getType() == Token.ASSIGN) {'], [''], ['Node gramps = parent.getParent(); if (NodeUtil.isObjectLitKey(parent, gramps)) { JSDocInfo maybeLends = gramps.getJSDocInfo(); if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith(".prototype")) { return false; } }'], 'a/src/com/google/javascript/jscomp/CheckGlobalThis.java', 'b/src/com/google/javascript/jscomp/CheckGlobalThis.java']
['Closure-92', 1, 1, 1, 1, ["} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"], ["} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. int indexOfDot = namespace.lastIndexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"], ["int indexOfDot = namespace.indexOf('.');"], ["int indexOfDot = namespace.lastIndexOf('.');"], 'a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java', 'b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java']
['Closure-93', 1, 1, 1, 1, ["} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"], ["} else { // In this case, the name was implicitly provided by two independent // modules. We need to move this code up to a common module. int indexOfDot = namespace.lastIndexOf('.'); if (indexOfDot == -1) { // Any old place is fine. compiler.getNodeForCodeInsertion(minimumModule)"], ["int indexOfDot = namespace.indexOf('.');"], ["int indexOfDot = namespace.lastIndexOf('.');"], 'a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java', 'b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java']
['Closure-94', 1, 1, 1, 1, ['return true; // Binary operators are only valid if both children are valid. case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: return isValidDefineValue(val.getFirstChild(), defines); // Names are valid if and only if they are defines themselves.'], ['return true; // Binary operators are only valid if both children are valid. case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.DIV: case Token.EQ: case Token.GE: case Token.GT: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.URSH: return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines); // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: case Token.POS: return isValidDefineValue(val.getFirstChild(), defines); // Names are valid if and only if they are defines themselves.'], [''], ['case Token.ADD: case Token.DIV: case Token.EQ: case Token.GE: case Token.GT: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.URSH: return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines); case Token.POS:'], 'a/src/com/google/javascript/jscomp/NodeUtil.java', 'b/src/com/google/javascript/jscomp/NodeUtil.java']
['Closure-95', 1, 1, 1, 1, ['// scope where the root object appears. This helps out people // who declare "global" names in an anonymous namespace. Scope scopeToDeclareIn = scope; // don\'t try to declare in the global scope if there\'s // already a symbol there with this name. // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {'], ['// scope where the root object appears. This helps out people // who declare "global" names in an anonymous namespace. Scope scopeToDeclareIn = scope; if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); // don\'t try to declare in the global scope if there\'s // already a symbol there with this name. if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } } // declared in closest scope? if (scopeToDeclareIn.isDeclared(variableName, false)) {'], [''], ['if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-96', 1, 1, 1, 1, ['Node parameter = null; Node argument = null; while (arguments.hasNext() && parameters.hasNext()) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. parameter = parameters.next(); argument = arguments.next(); ordinal++;'], ['Node parameter = null; Node argument = null; while (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. if (parameters.hasNext()) { parameter = parameters.next(); } argument = arguments.next(); ordinal++;'], ['parameters.hasNext()) {'], ['(parameters.hasNext() || parameter != null && parameter.isVarArgs())) { if (parameters.hasNext()) { }'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-97', 1, 1, 1, 1, ['// JavaScript handles zero shifts on signed numbers differently than // Java as an Java int can not represent the unsigned 32-bit number // where JavaScript can so use a long here. result = lvalInt >>> rvalInt; break; default: throw new AssertionError("Unknown shift operator: " +'], ['// JavaScript handles zero shifts on signed numbers differently than // Java as an Java int can not represent the unsigned 32-bit number // where JavaScript can so use a long here. long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt; break; default: throw new AssertionError("Unknown shift operator: " +'], ['result = lvalInt >>> rvalInt;'], ['long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt;'], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-98', 3, 3, 3, 3, ['} // Make sure this assignment is not in a loop. return true; }', '/** * Whether this block denotes a function scope. */ /** * Whether this block denotes a loop. */ /** * Creates a new block.', '// only named functions may be hoisted. this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); } BasicBlock getParent() {'], ['} // Make sure this assignment is not in a loop. for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false; } } return true; }', '/** * Whether this block denotes a function scope. */ private final boolean isFunction; /** * Whether this block denotes a loop. */ private final boolean isLoop; /** * Creates a new block.', '// only named functions may be hoisted. this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root); this.isFunction = root.getType() == Token.FUNCTION; if (root.getParent() != null) { int pType = root.getParent().getType(); this.isLoop = pType == Token.DO || pType == Token.WHILE || pType == Token.FOR; } else { this.isLoop = false; } } BasicBlock getParent() {'], ['', '', ''], ['for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false; } }', 'private final boolean isFunction; private final boolean isLoop;', 'this.isFunction = root.getType() == Token.FUNCTION; if (root.getParent() != null) { int pType = root.getParent().getType(); this.isLoop = pType == Token.DO || pType == Token.WHILE || pType == Token.FOR; } else { this.isLoop = false; }'], 'a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java', 'b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java']
['Closure-99', 2, 2, 2, 2, ['JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false;', '} else { // Only traverse the right side if it\'s not an assignment to a prototype // property or subproperty. if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals("prototype")) { return false; } if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(".prototype.")) { return false; } } }'], ['JSDocInfo jsDoc = getFunctionJsDocInfo(n); if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) { return false;', '} else { // Only traverse the right side if it\'s not an assignment to a prototype // property or subproperty. if (NodeUtil.isGet(lhs)) { if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals("prototype")) { return false; } Node llhs = lhs.getFirstChild(); if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals("prototype")) { return false; } } } }'], ['', 'if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(".prototype.")) {'], ['jsDoc.isInterface() ||', 'if (NodeUtil.isGet(lhs)) { Node llhs = lhs.getFirstChild(); if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals("prototype")) { }'], 'a/src/com/google/javascript/jscomp/CheckGlobalThis.java', 'b/src/com/google/javascript/jscomp/CheckGlobalThis.java']
['Closure-100', 2, 2, 2, 2, ['// var a = function() { }; // or // function a() {} // or // a.x = function() {}; } if (parent != null && parent.getType() == Token.ASSIGN) {', '} // Also report a THIS with a property access. return false; } /**'], ['// var a = function() { }; // or // function a() {} // or // a.x = function() {}; int pType = parent.getType(); if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) { return false; } } if (parent != null && parent.getType() == Token.ASSIGN) {', '} // Also report a THIS with a property access. return parent != null && NodeUtil.isGet(parent); } /**'], ['', 'return false;'], ['int pType = parent.getType(); if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) { return false; }', 'return parent != null && NodeUtil.isGet(parent);'], 'a/src/com/google/javascript/jscomp/CheckGlobalThis.java', 'b/src/com/google/javascript/jscomp/CheckGlobalThis.java']
['Closure-101', 1, 1, 1, 1, ['for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } if (flags.process_closure_primitives) { options.closurePass = true; } initOptionsFromFlags(options); return options; }'], ['for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; initOptionsFromFlags(options); return options; }'], ['if (flags.process_closure_primitives) { options.closurePass = true; }'], ['options.closurePass = flags.process_closure_primitives;'], 'a/src/com/google/javascript/jscomp/CommandLineRunner.java', 'b/src/com/google/javascript/jscomp/CommandLineRunner.java']
['Closure-102', 1, 1, 1, 1, ['@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }'], ['@Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }'], ['removeDuplicateDeclarations(root);'], ['removeDuplicateDeclarations(root);'], 'a/src/com/google/javascript/jscomp/Normalize.java', 'b/src/com/google/javascript/jscomp/Normalize.java']
['Closure-103', 2, 2, 2, 2, ['case Token.ASSIGN: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false;', '} // If the property does not exist on the referenced type but the original // type is an object type, see if any subtype has the property. // getGreatestSubtypeWithProperty does not guarantee that the property // is defined on the returned type, it just indicates that it might be, // so we have to double check. return foundType; }'], ['case Token.ASSIGN: case Token.INC: case Token.DEC: case Token.INSTANCEOF: return true; case Token.FUNCTION: return false;', '} // If the property does not exist on the referenced type but the original // type is an object type, see if any subtype has the property. if (foundType == null) { ObjectType maybeType = ObjectType.cast( registry.getGreatestSubtypeWithProperty(type, field)); // getGreatestSubtypeWithProperty does not guarantee that the property // is defined on the returned type, it just indicates that it might be, // so we have to double check. if (maybeType != null && maybeType.hasOwnProperty(field)) { foundType = maybeType; } } return foundType; }'], ['', ''], ['case Token.INSTANCEOF:', 'if (foundType == null) { ObjectType maybeType = ObjectType.cast( registry.getGreatestSubtypeWithProperty(type, field)); if (maybeType != null && maybeType.hasOwnProperty(field)) { foundType = maybeType; } }'], 'a/src/com/google/javascript/jscomp/DisambiguateProperties.java', 'b/src/com/google/javascript/jscomp/DisambiguateProperties.java']
['Closure-104', 1, 1, 1, 1, ['builder.addAlternate(that); } JSType result = builder.build(); if (result != null) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE);'], ['builder.addAlternate(that); } JSType result = builder.build(); if (!result.isNoType()) { return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE);'], ['if (result != null) {'], ['if (!result.isNoType()) {'], 'a/src/com/google/javascript/rhino/jstype/UnionType.java', 'b/src/com/google/javascript/rhino/jstype/UnionType.java']
['Closure-105', 2, 2, 2, 2, [' String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = new StringBuilder(); } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem);', 'elem = elem.getNext(); } if (sb.length() > 0) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString()));'], [' String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = null; int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb == null) { sb = new StringBuilder(); } else { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem);', 'elem = elem.getNext(); } if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString()));'], ['StringBuilder sb = new StringBuilder(); if (sb.length() > 0) { if (sb.length() > 0) { sb = new StringBuilder();', 'if (sb.length() > 0) {'], ['StringBuilder sb = null; if (sb == null) { sb = new StringBuilder(); } else { if (sb != null) { sb = null;', 'if (sb != null) {'], 'a/src/com/google/javascript/jscomp/FoldConstants.java', 'b/src/com/google/javascript/jscomp/FoldConstants.java']
['Closure-106', 2, 2, 2, 2, ["// Don't try to collapse if the one global set is a twin reference. // We could theoretically handle this case in CollapseProperties, but // it's probably not worth the effort. if (isClassOrEnum) { return true;", '* @return {@code true} if the description was recorded. */ public boolean recordBlockDescription(String description) { if (parseDocumentation) { populated = true; } return currentInfo.documentBlock(description); }'], ["// Don't try to collapse if the one global set is a twin reference. // We could theoretically handle this case in CollapseProperties, but // it's probably not worth the effort. Preconditions.checkNotNull(declaration); if (declaration.getTwin() != null) { return false; } if (isClassOrEnum) { return true;", '* @return {@code true} if the description was recorded. */ public boolean recordBlockDescription(String description) { populated = true; return currentInfo.documentBlock(description); }'], ['', 'if (parseDocumentation) { }'], ['Preconditions.checkNotNull(declaration); if (declaration.getTwin() != null) { return false; }', ''], 'a/src/com/google/javascript/rhino/JSDocInfoBuilder.java', 'b/src/com/google/javascript/rhino/JSDocInfoBuilder.java']
['Closure-107', 1, 1, 1, 1, ["// so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. options.messageBundle = new EmptyMessageBundle(); } return options;"], ["// so we might as well inline it. But shut off the i18n warnings, // because the user didn't really ask for i18n. options.messageBundle = new EmptyMessageBundle(); options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF); } return options;"], [''], ['options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);'], 'a/src/com/google/javascript/jscomp/CommandLineRunner.java', 'b/src/com/google/javascript/jscomp/CommandLineRunner.java']
['Closure-108', 4, 4, 4, 4, ['private final Map<String, Var> aliases = Maps.newHashMap(); // Also temporary and cleared for each scope. // Suppose you create an alias. // var x = goog.x;', ' if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); aliases.clear(); forbiddenLocals.clear(); transformation = null;', '} else { grandparent.addChildBefore(newDecl, varNode); } } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"', '// When we inject declarations, we duplicate jsdoc. Make sure // we only process that jsdoc once. JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }'], ['private final Map<String, Var> aliases = Maps.newHashMap(); // Also temporary and cleared for each scope. private final Set<Node> injectedDecls = Sets.newHashSet(); // Suppose you create an alias. // var x = goog.x;', ' if (t.getScopeDepth() == 2) { renameNamespaceShadows(t); injectedDecls.clear(); aliases.clear(); forbiddenLocals.clear(); transformation = null;', '} else { grandparent.addChildBefore(newDecl, varNode); } injectedDecls.add(newDecl.getFirstChild()); } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"', '// When we inject declarations, we duplicate jsdoc. Make sure // we only process that jsdoc once. JSDocInfo info = n.getJSDocInfo(); if (info != null && !injectedDecls.contains(n)) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }'], ['', '', '', 'if (info != null) {'], ['private final Set<Node> injectedDecls = Sets.newHashSet();', 'injectedDecls.clear();', 'injectedDecls.add(newDecl.getFirstChild());', 'if (info != null && !injectedDecls.contains(n)) {'], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-109', 1, 1, 1, 1, ['* For expressions on the right hand side of a this: or new: */ private Node parseContextTypeExpression(JsDocToken token) { return parseTypeName(token); } /**'], ['* For expressions on the right hand side of a this: or new: */ private Node parseContextTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); } } /**'], ['return parseTypeName(token);'], ['if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); }'], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-110', 6, 6, 6, 6, ['Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) {', '} else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name);', ' // First, we need to free up the function expression (EXPR) // to be used in another expression. // Replace "function NAME() { ... }" with "var NAME;". // We can\'t keep the local name on the function expression, // because IE is buggy and will leak the name into the global', '// // This will only cause problems if this is a hoisted, recursive // function, and the programmer is using the hoisting. // If this is a VAR, we can just detach the expression and // the tree will still be valid. // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info.', 'NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"', 'return null; } Node n = first; while (n.next != child) { n = n.next;'], ['Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) {', '} else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else if (isVar || isFunctionDecl) { boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent); Node grandparent = parent.getParent(); Node value = v.getInitialValue() != null ? v.getInitialValue() : null; Node varNode = null; String name = n.getString(); int nameCount = scopedAliasNames.count(name);', ' // First, we need to free up the function expression (EXPR) // to be used in another expression. if (isFunctionDecl) { // Replace "function NAME() { ... }" with "var NAME;". Node existingName = v.getNameNode(); // We can\'t keep the local name on the function expression, // because IE is buggy and will leak the name into the global', '// // This will only cause problems if this is a hoisted, recursive // function, and the programmer is using the hoisting. Node newName = IR.name("").useSourceInfoFrom(existingName); value.replaceChild(existingName, newName); varNode = IR.var(existingName).useSourceInfoFrom(existingName); grandparent.replaceChild(parent, varNode); } else { if (value != null) { // If this is a VAR, we can just detach the expression and // the tree will still be valid. value.detachFromParent(); } varNode = parent; } // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info.', 'NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); if (isHoisted) { grandparent.addChildToFront(newDecl); } else { grandparent.addChildBefore(newDecl, varNode); } } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"', 'return null; } Node n = first; if (n == null) { throw new RuntimeException("node is not a child"); } while (n.next != child) { n = n.next;'], ['', '} else if (isVar) { Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : Node varNode = parent;', '', '', '', ''], ['boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);', '} else if (isVar || isFunctionDecl) { boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent); Node value = v.getInitialValue() != null ? v.getInitialValue() : Node varNode = null;', 'if (isFunctionDecl) { Node existingName = v.getNameNode();', 'Node newName = IR.name("").useSourceInfoFrom(existingName); value.replaceChild(existingName, newName); varNode = IR.var(existingName).useSourceInfoFrom(existingName); grandparent.replaceChild(parent, varNode); } else { if (value != null) { value.detachFromParent(); } varNode = parent; }', 'if (isHoisted) { grandparent.addChildToFront(newDecl); } else { }', 'if (n == null) { throw new RuntimeException("node is not a child"); }'], 'a/src/com/google/javascript/rhino/Node.java', 'b/src/com/google/javascript/rhino/Node.java']
['Closure-111', 1, 1, 1, 1, ['new RestrictByTrueTypeOfResultVisitor() { @Override protected JSType caseTopType(JSType topType) { return topType; } @Override'], ['new RestrictByTrueTypeOfResultVisitor() { @Override protected JSType caseTopType(JSType topType) { return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType; } @Override'], ['return topType;'], ['return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType;'], 'a/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java', 'b/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java']
['Closure-112', 1, 1, 1, 1, ["} // Try to infer the template types Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n); // Replace all template types. If we couldn't find a replacement, we // replace it with UNKNOWN."], ["} // Try to infer the template types Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} ); // Replace all template types. If we couldn't find a replacement, we // replace it with UNKNOWN."], ['Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);'], ['Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} );'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['Closure-113', 1, 1, 1, 1, ['// the checks for broken requires turned off. In these cases, we // allow broken requires to be preserved by the first run to // let them be caught in the subsequent run. if (provided != null) { parent.detachFromParent(); compiler.reportCodeChange(); }'], ['// the checks for broken requires turned off. In these cases, we // allow broken requires to be preserved by the first run to // let them be caught in the subsequent run. if (provided != null || requiresLevel.isOn()) { parent.detachFromParent(); compiler.reportCodeChange(); }'], ['if (provided != null) {'], ['if (provided != null || requiresLevel.isOn()) {'], 'a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java', 'b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java']
['Closure-114', 1, 1, 1, 1, ["} else { recordDepScope(nameNode, ns); } } else { // The rhs of the assignment is the caller, so it's used by the // context. Don't associate it w/ the lhs. // FYI: this fixes only the specific case where the assignment is the"], ["} else { recordDepScope(nameNode, ns); } } else if (!(parent.isCall() && parent.getFirstChild() == n)) { // The rhs of the assignment is the caller, so it's used by the // context. Don't associate it w/ the lhs. // FYI: this fixes only the specific case where the assignment is the"], ['} else {'], ['} else if (!(parent.isCall() && parent.getFirstChild() == n)) {'], 'a/src/com/google/javascript/jscomp/NameAnalyzer.java', 'b/src/com/google/javascript/jscomp/NameAnalyzer.java']
['Closure-115', 2, 2, 2, 2, [' Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop.'], [' Node block = fnNode.getLastChild(); // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop.'], ['boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }', 'if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }'], ['', ''], 'a/src/com/google/javascript/jscomp/FunctionInjector.java', 'b/src/com/google/javascript/jscomp/FunctionInjector.java']
['Closure-116', 2, 2, 2, 2, [' Node block = fnNode.getLastChild(); // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a'], [' Node block = fnNode.getLastChild(); boolean hasSideEffects = false; // empty function case if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects( stmt.getFirstChild(), compiler); } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '// For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a'], ['', ''], ['boolean hasSideEffects = false; // empty function case if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects( stmt.getFirstChild(), compiler); } }', 'if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }'], 'a/src/com/google/javascript/jscomp/FunctionInjector.java', 'b/src/com/google/javascript/jscomp/FunctionInjector.java']
['Closure-117', 2, 2, 2, 2, ["* to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { // The best type name is the actual type name. // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where", '} } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;'], ["* to an Object type, if possible. */ String getReadableJSTypeName(Node n, boolean dereference) { JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } // The best type name is the actual type name. if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } // If we're analyzing a GETPROP, the property may be inherited by the // prototype chain. So climb the prototype chain and find out where", '} } String qualifiedName = n.getQualifiedName(); if (qualifiedName != null) { return qualifiedName;'], ['', 'JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); }'], ['JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); }', ''], 'a/src/com/google/javascript/jscomp/TypeValidator.java', 'b/src/com/google/javascript/jscomp/TypeValidator.java']
['Closure-118', 1, 1, 1, 1, ['child != null; child = child.getNext()) { // Maybe STRING, GET, SET // We should never see a mix of numbers and strings. String name = child.getString();'], ['child != null; child = child.getNext()) { // Maybe STRING, GET, SET if (child.isQuotedString()) { continue; } // We should never see a mix of numbers and strings. String name = child.getString();'], [''], ['if (child.isQuotedString()) { continue; }'], 'a/src/com/google/javascript/jscomp/DisambiguateProperties.java', 'b/src/com/google/javascript/jscomp/DisambiguateProperties.java']
['Closure-119', 1, 1, 1, 1, ['isSet = true; type = Name.Type.FUNCTION; break; case Token.INC: case Token.DEC: isSet = true;'], ['isSet = true; type = Name.Type.FUNCTION; break; case Token.CATCH: case Token.INC: case Token.DEC: isSet = true;'], [''], ['case Token.CATCH:'], 'a/src/com/google/javascript/jscomp/GlobalNamespace.java', 'b/src/com/google/javascript/jscomp/GlobalNamespace.java']
['Closure-120', 1, 1, 1, 1, ['for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { break; } else if (block.isLoop) { return false;'], ['for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { if (ref.getSymbol().getScope() != ref.scope) { return false; } break; } else if (block.isLoop) { return false;'], [''], ['if (ref.getSymbol().getScope() != ref.scope) { return false; }'], 'a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java', 'b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java']
['Closure-121', 1, 1, 1, 1, ['if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNode();'], ['if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime() && // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. (isInlineableDeclaredConstant(v, referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) { List<Reference> refs = referenceInfo.references; for (int i = 1 /* start from a read */; i < refs.size(); i++) { Node nameNode = refs.get(i).getNode();'], ['referenceInfo.isAssignedOnceInLifetime()) {'], ['referenceInfo.isAssignedOnceInLifetime() && (isInlineableDeclaredConstant(v, referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {'], 'a/src/com/google/javascript/jscomp/InlineVariables.java', 'b/src/com/google/javascript/jscomp/InlineVariables.java']
['Closure-122', 1, 1, 1, 1, ['* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { if (comment.getValue().indexOf("/* @") != -1 || comment.getValue().indexOf("\\n * @") != -1) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName,'], ['* Check to see if the given block comment looks like it should be JSDoc. */ private void handleBlockComment(Comment comment) { Pattern p = Pattern.compile("(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]"); if (p.matcher(comment.getValue()).find()) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName,'], ['if (comment.getValue().indexOf("/* @") != -1 || comment.getValue().indexOf("\\n * @") != -1) {'], ['Pattern p = Pattern.compile("(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]"); if (p.matcher(comment.getValue()).find()) {'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-123', 1, 1, 1, 1, ['case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); Context rhsContext = Context.OTHER; addExpr(first, p + 1, context); cc.addOp("?", true); addExpr(first.getNext(), 1, rhsContext);'], ['case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); Context rhsContext = getContextForNoInOperator(context); addExpr(first, p + 1, context); cc.addOp("?", true); addExpr(first.getNext(), 1, rhsContext);'], ['Context rhsContext = Context.OTHER;'], ['Context rhsContext = getContextForNoInOperator(context);'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-124', 1, 1, 1, 1, ['} Preconditions.checkArgument(node.isGetProp()); node = node.getFirstChild(); if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false;'], ['} Preconditions.checkArgument(node.isGetProp()); while (node.isGetProp()) { node = node.getFirstChild(); } if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false;'], [''], ['while (node.isGetProp()) { }'], 'a/src/com/google/javascript/jscomp/ExploitAssigns.java', 'b/src/com/google/javascript/jscomp/ExploitAssigns.java']
['Closure-125', 1, 1, 1, 1, ['JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {'], ['JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null && fnType.hasInstanceType()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else {'], ['if (fnType != null) {'], ['if (fnType != null && fnType.hasInstanceType()) {'], 'a/src/com/google/javascript/jscomp/TypeCheck.java', 'b/src/com/google/javascript/jscomp/TypeCheck.java']
['Closure-126', 1, 1, 1, 1, ["* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'."], ["* can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ } // Just a 'label'."], ['if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }'], [''], 'a/src/com/google/javascript/jscomp/MinimizeExitPoints.java', 'b/src/com/google/javascript/jscomp/MinimizeExitPoints.java']
['Closure-127', 1, 1, 1, 1, ['outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough) { removeNode(n); } } } } private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n);'], ['outEdges.get(0).getValue() == Branch.UNCOND); Node fallThrough = computeFollowing(n); Node nextCfgNode = outEdges.get(0).getDestination().getValue(); if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { removeNode(n); } } } } private boolean inFinally(Node parent, Node child) { if (parent == null || parent.isFunction()) { return false; } else if (NodeUtil.isTryFinallyNode(parent, child)) { return true; } else { return inFinally(parent.getParent(), parent); } } private Node computeFollowing(Node n) { Node next = ControlFlowAnalysis.computeFollowNode(n);'], ['if (nextCfgNode == fallThrough) {'], ['if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { private boolean inFinally(Node parent, Node child) { if (parent == null || parent.isFunction()) { return false; } else if (NodeUtil.isTryFinallyNode(parent, child)) { return true; } else { return inFinally(parent.getParent(), parent); } }'], 'a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java', 'b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java']
['Closure-128', 1, 1, 1, 1, [" static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len > 0 && s.charAt(0) != '0'; } static double getSimpleNumber(String s) {"], [" static boolean isSimpleNumber(String s) { int len = s.length(); if (len == 0) { return false; } for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len == 1 || s.charAt(0) != '0'; } static double getSimpleNumber(String s) {"], ["return len > 0 && s.charAt(0) != '0';"], ["if (len == 0) { return false; } return len == 1 || s.charAt(0) != '0';"], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-129', 1, 1, 1, 1, ['Node first = n.getFirstChild(); // ignore cast nodes. if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true);'], ['Node first = n.getFirstChild(); // ignore cast nodes. while (first.isCast()) { first = first.getFirstChild(); } if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true);'], [''], ['while (first.isCast()) { first = first.getFirstChild(); }'], 'a/src/com/google/javascript/jscomp/PrepareAst.java', 'b/src/com/google/javascript/jscomp/PrepareAst.java']
['Closure-130', 1, 1, 1, 1, ['continue; } if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { // {@code name} meets condition (b). Find all of its local aliases // and try to inline them.'], ['continue; } if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { // {@code name} meets condition (b). Find all of its local aliases // and try to inline them.'], ['if (name.globalSets == 1 && name.localSets == 0 &&'], ['if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&'], 'a/src/com/google/javascript/jscomp/CollapseProperties.java', 'b/src/com/google/javascript/jscomp/CollapseProperties.java']
['Closure-131', 1, 1, 1, 1, ['int length = s.length(); if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; } for (int i = 1; i < length; i++) { if ( !Character.isJavaIdentifierPart(s.charAt(i))) { return false; }'], ['int length = s.length(); if (length == 0 || Character.isIdentifierIgnorable(s.charAt(0)) || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; } for (int i = 1; i < length; i++) { if (Character.isIdentifierIgnorable(s.charAt(i)) || !Character.isJavaIdentifierPart(s.charAt(i))) { return false; }'], ['if ('], ['Character.isIdentifierIgnorable(s.charAt(0)) || if (Character.isIdentifierIgnorable(s.charAt(i)) ||'], 'a/src/com/google/javascript/rhino/TokenStream.java', 'b/src/com/google/javascript/rhino/TokenStream.java']
['Closure-132', 1, 1, 1, 1, ['// evaluates LHS before cond] // NOTE - there are some circumstances where we can // proceed even if there are side effects... !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild();'], ['// evaluates LHS before cond] // NOTE - there are some circumstances where we can // proceed even if there are side effects... !mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild();'], ['!mayEffectMutableState(lhs)) {'], ['!mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {'], 'a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java', 'b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java']
['Closure-133', 1, 1, 1, 1, ['*/ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); return result; }'], ['*/ private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); unreadToken = NO_UNREAD_TOKEN; return result; }'], [''], ['unreadToken = NO_UNREAD_TOKEN;'], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-134', 6, 6, 6, 6, ['for (Property p : propertyMap.values()) { if (!p.skipAmbiguating) { ++numRenamedPropertyNames; computeRelatedTypes(p.type); propsByFreq.add(p); } else { ++numSkippedPropertyNames;', 'if (typesRelatedToSet.intersects(prop.typesSet)) { return false; } return !getRelated(prop.type).intersects(typesInSet); } /**', '*/ public void addNode(Property prop) { typesInSet.or(prop.typesSet); typesRelatedToSet.or(getRelated(prop.type)); } /**', '/** Encapsulates the information needed for renaming a property. */ private class Property { final String oldName; JSType type; String newName; int numOccurrences; boolean skipAmbiguating; JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size()); Property(String name) { this.oldName = name;', 'return; } if (type == null) { type = newType; } else { type = type.getLeastSupertype(newType); } typesSet.set(getIntForType(newType)); } }', "JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } // If it's not, then check to see if it's implemented // on an implemented interface. return null; }"], ['for (Property p : propertyMap.values()) { if (!p.skipAmbiguating) { ++numRenamedPropertyNames; propsByFreq.add(p); } else { ++numSkippedPropertyNames;', 'if (typesRelatedToSet.intersects(prop.typesSet)) { return false; } return !prop.relatedTypesSet.intersects(typesInSet); } /**', '*/ public void addNode(Property prop) { typesInSet.or(prop.typesSet); typesRelatedToSet.or(prop.relatedTypesSet); } /**', '/** Encapsulates the information needed for renaming a property. */ private class Property { final String oldName; String newName; int numOccurrences; boolean skipAmbiguating; JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size()); JSTypeBitSet relatedTypesSet = new JSTypeBitSet(intForType.size()); Property(String name) { this.oldName = name;', 'return; } int typeInt = getIntForType(newType); if (!typesSet.get(typeInt)) { computeRelatedTypes(newType); typesSet.set(typeInt); relatedTypesSet.or(getRelatedTypesOnNonUnion(newType)); } } }', "JSType propType = ownerType.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } else { // If it's not, then check to see if it's implemented // on an implemented interface. for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } } } return null; }"], ['computeRelatedTypes(p.type);', 'return !getRelated(prop.type).intersects(typesInSet);', 'typesRelatedToSet.or(getRelated(prop.type));', 'JSType type;', 'if (type == null) { type = newType; } else { type = type.getLeastSupertype(newType); typesSet.set(getIntForType(newType));', '}'], ['', 'return !prop.relatedTypesSet.intersects(typesInSet);', 'typesRelatedToSet.or(prop.relatedTypesSet);', 'JSTypeBitSet relatedTypesSet = new JSTypeBitSet(intForType.size());', 'int typeInt = getIntForType(newType); if (!typesSet.get(typeInt)) { computeRelatedTypes(newType); typesSet.set(typeInt); relatedTypesSet.or(getRelatedTypesOnNonUnion(newType));', '} else { for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { propType = iface.getPropertyType(propName); if (propType instanceof FunctionType) { return (FunctionType) propType; } } }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-135', 3, 3, 3, 3, ['for (Node child : node.children()) { if (NodeUtil.isThis(child)) { Node newName = Node.newString(Token.NAME, name); node.replaceChild(child, newName); } else { replaceReferencesToThis(child, name);', 'return super.hasProperty(name) || "prototype".equals(name); } @Override public JSType getPropertyType(String name) {', 'if ("prototype".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { return setPrototype( new FunctionPrototypeType( registry, this, objType, isNativeObjectType()));'], ['for (Node child : node.children()) { if (NodeUtil.isThis(child)) { Node newName = Node.newString(Token.NAME, name); newName.setJSType(child.getJSType()); node.replaceChild(child, newName); } else { replaceReferencesToThis(child, name);', 'return super.hasProperty(name) || "prototype".equals(name); } @Override public boolean hasOwnProperty(String name) { return super.hasOwnProperty(name) || "prototype".equals(name); } @Override public JSType getPropertyType(String name) {', 'if ("prototype".equals(name)) { ObjectType objType = type.toObjectType(); if (objType != null) { if (objType.equals(prototype)) { return true; } return setPrototype( new FunctionPrototypeType( registry, this, objType, isNativeObjectType()));'], ['', '', ''], ['newName.setJSType(child.getJSType());', '@Override public boolean hasOwnProperty(String name) { return super.hasOwnProperty(name) || "prototype".equals(name); }', 'if (objType.equals(prototype)) { return true; }'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-136', 2, 2, 2, 2, ['* itself or the name of a function). */ private void addPossibleSignature(String name, Node node, NodeTraversal t) { boolean signatureAdded = false; if (node.getType() == Token.FUNCTION) { // The node we\'re looking at is a function, so we can add it directly addSignature(name, node, t.getSourceName()); signatureAdded = true; } else if (node.getType() == Token.NAME) { String functionName = node.getString(); Scope.Var v = t.getScope().getVar(functionName); if (v == null) { if (compiler.isIdeMode()) { return; } else { throw new IllegalStateException( "VarCheck should have caught this undefined function"); } } Node function = v.getInitialValue(); if (function != null && function.getType() == Token.FUNCTION) { addSignature(name, function, v.getInputName()); signatureAdded = true; } } if (!signatureAdded) { nonMethodProperties.add(name); } }', ' // Check if we can rename this. if (!okToRenameVar(name, local)) { // Blindly de-uniquify for the Prototype library for issue 103. return; }'], ["* itself or the name of a function). */ private void addPossibleSignature(String name, Node node, NodeTraversal t) { if (node.getType() == Token.FUNCTION) { // The node we're looking at is a function, so we can add it directly addSignature(name, node, t.getSourceName()); } else { nonMethodProperties.add(name); } }", ' // Check if we can rename this. if (!okToRenameVar(name, local)) { if (local) { // Blindly de-uniquify for the Prototype library for issue 103. String newName = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName( name); if (!newName.equals(name)) { n.setString(newName); } } return; }'], ['boolean signatureAdded = false; signatureAdded = true; } else if (node.getType() == Token.NAME) { String functionName = node.getString(); Scope.Var v = t.getScope().getVar(functionName); if (v == null) { if (compiler.isIdeMode()) { return; } else { throw new IllegalStateException( "VarCheck should have caught this undefined function"); } } Node function = v.getInitialValue(); if (function != null && function.getType() == Token.FUNCTION) { addSignature(name, function, v.getInputName()); signatureAdded = true; } } if (!signatureAdded) {', ''], ['} else {', 'if (local) { String newName = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName( name); if (!newName.equals(name)) { n.setString(newName); } }'], 'a/src/com/google/javascript/jscomp/RenameVars.java', 'b/src/com/google/javascript/jscomp/RenameVars.java']
['Closure-137', 10, 10, 10, 10, ['import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;', 'class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer;', "/** * Inverts the transformation by {@link ContextualRenamer}, when possible. */ static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private final AbstractCompiler compiler; // The set of names referenced in the current scope. // Stack reference sets. // Name are globally unique initially, so we don't need a per-scope map. private Map<Var, String> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;", 'private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } /** * Prepare a set for the new scope. */ private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); } /** * Rename vars for the current scope, and merge any referenced * names into the parent scope reference set. */ @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { return; } if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); // Merge any names that were referenced but not declared in the current // scope. // If there isn\'t anything left in the stack we will be going into the // global scope: don\'t try to build a set of referenced names for the // global scope. boolean recurseScopes = false; if (!suffix.matches("\\\\d+")) { recurseScopes = true; } /** * For the Var declared in the current scope determine if it is possible * to revert the name to its orginal form without conflicting with other * values. */ // Check if the new name is valid and if it would cause conflicts. if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); // Adding a reference to the new name to prevent either the parent // scopes or the current scope renaming another var to this new name. Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); compiler.reportCodeChange(); } nameMap.put(var, newName); } // Add all referenced names to the set so it is possible to check for // conflicts. // Store only references to candidate names in the node map. } } } } /**', '*/ @Override public void addDeclaredName(String name) { if (global) { reserveName(name); } else {', 'String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } }', ' @Override public void addDeclaredName(String name) { if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); }', '* @return Whether the name is a reference to a variable, function or * function parameter (not a label or a empty anonymous function name). */ /** @return Whether the node is a label name. */ static boolean isLabelName(Node n) {', 'public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); removeDuplicateDeclarations(root); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer);', "// } // otherwise 'var e = 1' would be rewritten as 'e = 1'. // TODO(johnlenz): Introduce a seperate scope for catch nodes. new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"], ['import com.google.common.collect.Maps; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;', 'class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback { public static final String ARGUMENTS = "arguments"; private Deque<Renamer> nameStack = new ArrayDeque<Renamer>(); private final Renamer rootRenamer;', "/** * Inverts the transformation by {@link ContextualRenamer}, when possible. */ static class ContextualRenameInverter implements ScopedCallback, CompilerPass { private final AbstractCompiler compiler; // The set of names referenced in the current scope. private Set<String> referencedNames = ImmutableSet.of(); // Stack reference sets. private Deque<Set<String>> referenceStack = new ArrayDeque<Set<String>>(); // Name are globally unique initially, so we don't need a per-scope map. private Map<String, List<Node>> nameMap = Maps.newHashMap(); private ContextualRenameInverter(AbstractCompiler compiler) { this.compiler = compiler;", "private boolean containsSeparator(String name) { return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1; } /** * Prepare a set for the new scope. */ public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { return; } referenceStack.push(referencedNames); referencedNames = Sets.newHashSet(); } /** * Rename vars for the current scope, and merge any referenced * names into the parent scope reference set. */ public void exitScope(NodeTraversal t) { if (t.inGlobalScope()) { return; } for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); handleScopeVar(v); } // Merge any names that were referenced but not declared in the current // scope. Set<String> current = referencedNames; referencedNames = referenceStack.pop(); // If there isn't anything left in the stack we will be going into the // global scope: don't try to build a set of referenced names for the // global scope. if (!referenceStack.isEmpty()) { referencedNames.addAll(current); } } /** * For the Var declared in the current scope determine if it is possible * to revert the name to its orginal form without conflicting with other * values. */ void handleScopeVar(Var v) { String name = v.getName(); if (containsSeparator(name)) { String newName = getOrginalName(name); // Check if the new name is valid and if it would cause conflicts. if (TokenStream.isJSIdentifier(newName) && !referencedNames.contains(newName) && !newName.equals(ARGUMENTS)) { referencedNames.remove(name); // Adding a reference to the new name to prevent either the parent // scopes or the current scope renaming another var to this new name. referencedNames.add(newName); List<Node> references = nameMap.get(name); Preconditions.checkState(references != null); for (Node n : references) { Preconditions.checkState(n.getType() == Token.NAME); n.setString(newName); } compiler.reportCodeChange(); } nameMap.remove(name); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (t.inGlobalScope()) { return; } if (NodeUtil.isReferenceName(node)) { String name = node.getString(); // Add all referenced names to the set so it is possible to check for // conflicts. referencedNames.add(name); // Store only references to candidate names in the node map. if (containsSeparator(name)) { addCandidateNameReference(name, node); } } } private void addCandidateNameReference(String name, Node n) { List<Node> nodes = nameMap.get(name); if (null == nodes) { nodes = Lists.newLinkedList(); nameMap.put(name, nodes); } nodes.add(n); } } /**", '*/ @Override public void addDeclaredName(String name) { if (!name.equals(ARGUMENTS)) { if (global) { reserveName(name); } else {', 'String newName = null; if (id != 0) { newName = getUniqueName(name, id); } declarations.put(name, newName); } } } }', ' @Override public void addDeclaredName(String name) { Preconditions.checkState(!name.equals(ARGUMENTS)); if (!declarations.containsKey(name)) { declarations.put(name, getUniqueName(name)); }', '* @return Whether the name is a reference to a variable, function or * function parameter (not a label or a empty anonymous function name). */ static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty() && !isLabelName(n); } /** @return Whether the node is a label name. */ static boolean isLabelName(Node n) {', 'public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange)); if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer);', "// } // otherwise 'var e = 1' would be rewritten as 'e = 1'. // TODO(johnlenz): Introduce a seperate scope for catch nodes. removeDuplicateDeclarations(root); new PropogateConstantAnnotations(compiler, assertOnChange) .process(externs, root); }"], ['import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;', '', 'static class ContextualRenameInverter extends AbstractPostOrderCallback implements CompilerPass { private Map<Var, String> nameMap = Maps.newHashMap();', 'private static String getOrginalNameInternal(String name, int index) { return name.substring(0, index); } private static String getNameSuffix(String name, int index) { return name.substring( index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length()); @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getType() == Token.NAME) { String oldName = node.getString(); if (containsSeparator(oldName)) { Scope scope = t.getScope(); Var var = t.getScope().getVar(oldName); if (var == null || var.isGlobal()) { if (nameMap.containsKey(var)) { node.setString(nameMap.get(var)); } else { int index = indexOfSeparator(oldName); String newName = getOrginalNameInternal(oldName, index); String suffix = getNameSuffix(oldName, index); boolean recurseScopes = false; if (!suffix.matches("\\\\d+")) { recurseScopes = true; } if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { newName = oldName; } else { var.scope.declare(newName, var.nameNode, null, null); Node parentNode = var.getParentNode(); if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) { var.getNameNode().setString(newName); } node.setString(newName); nameMap.put(var, newName);', '', 'declarations.put(name, newName);', '', '', 'removeDuplicateDeclarations(root);', ''], ['import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;', 'public static final String ARGUMENTS = "arguments";', 'static class ContextualRenameInverter implements ScopedCallback, CompilerPass { private Set<String> referencedNames = ImmutableSet.of(); private Deque<Set<String>> referenceStack = new ArrayDeque<Set<String>>(); private Map<String, List<Node>> nameMap = Maps.newHashMap();', 'public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { return; } referenceStack.push(referencedNames); referencedNames = Sets.newHashSet(); public void exitScope(NodeTraversal t) { if (t.inGlobalScope()) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next(); handleScopeVar(v); } Set<String> current = referencedNames; referencedNames = referenceStack.pop(); if (!referenceStack.isEmpty()) { referencedNames.addAll(current); } } void handleScopeVar(Var v) { String name = v.getName(); if (containsSeparator(name)) { String newName = getOrginalName(name); if (TokenStream.isJSIdentifier(newName) && !referencedNames.contains(newName) && !newName.equals(ARGUMENTS)) { referencedNames.remove(name); referencedNames.add(newName); List<Node> references = nameMap.get(name); Preconditions.checkState(references != null); for (Node n : references) { Preconditions.checkState(n.getType() == Token.NAME); n.setString(newName); } nameMap.remove(name); } } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node node, Node parent) { if (t.inGlobalScope()) { return; if (NodeUtil.isReferenceName(node)) { String name = node.getString(); referencedNames.add(name); if (containsSeparator(name)) { addCandidateNameReference(name, node); private void addCandidateNameReference(String name, Node n) { List<Node> nodes = nameMap.get(name); if (null == nodes) { nodes = Lists.newLinkedList(); nameMap.put(name, nodes); } nodes.add(n); }', 'if (!name.equals(ARGUMENTS)) {', '} declarations.put(name, newName);', 'Preconditions.checkState(!name.equals(ARGUMENTS));', 'static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty() && !isLabelName(n); }', '', 'removeDuplicateDeclarations(root);'], 'a/src/com/google/javascript/jscomp/Normalize.java', 'b/src/com/google/javascript/jscomp/Normalize.java']
['Closure-138', 3, 3, 3, 3, ['Node param = condition.getLastChild(); if (callee.getType() == GETPROP && param.isQualifiedName()) { JSType paramType = getTypeIfRefinable(param, blindScope); if (paramType != null) { Node left = callee.getFirstChild(); Node right = callee.getLastChild(); if (left.getType() == NAME && "goog".equals(left.getString()) &&', 'if (restricter != null) { return restrictParameter(param, paramType, blindScope, restricter, outcome); } } } }', "return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null && !(var.isTypeInferred() && unflowableVarNames.contains(varName))) { // There are two situations where we don't want to use type information // from the scope, even if we have it. // 1) The var is escaped in a weird way, e.g., // function f() { var x = 3; function g() { x = null } (x); } // 2) We're reading type information from another scope for an // inferred variable. // var t = null; function f() { (t); } type = var.getType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); } } }"], ['Node param = condition.getLastChild(); if (callee.getType() == GETPROP && param.isQualifiedName()) { JSType paramType = getTypeIfRefinable(param, blindScope); Node left = callee.getFirstChild(); Node right = callee.getLastChild(); if (left.getType() == NAME && "goog".equals(left.getString()) &&', 'if (restricter != null) { return restrictParameter(param, paramType, blindScope, restricter, outcome); } } }', "return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { // There are two situations where we don't want to use type information // from the scope, even if we have it. // 1) The var is escaped in a weird way, e.g., // function f() { var x = 3; function g() { x = null } (x); } boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && unflowableVarNames.contains(varName); // 2) We're reading type information from another scope for an // inferred variable. // var t = null; function f() { (t); } boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName); if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); } } } }"], ['if (paramType != null) {', '}', 'if (var != null && !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {'], ['', '', 'if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && unflowableVarNames.contains(varName); boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName); if (!unflowable && !nonLocalInferredSlot) { }'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['Closure-139', 4, 4, 4, 4, ['} break; } }', '* to: * var f = function () {}; */ /** * Rewrite the function declaration from:', '* LP * BLOCK */ // Prepare a spot for the function. // Prepare the function // Move the function /** * Do normalizations that introduce new siblings or parents.', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); if (parent.getType() == Token.VAR) { // If name is "arguments", Var maybe null. Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps);'], ['} break; case Token.FUNCTION: normalizeFunctionDeclaration(n); break; } }', '* to: * var f = function () {}; */ private void normalizeFunctionDeclaration(Node n) { Preconditions.checkState(n.getType() == Token.FUNCTION); if (!NodeUtil.isFunctionAnonymous(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) { rewriteFunctionDeclaration(n); } } /** * Rewrite the function declaration from:', '* LP * BLOCK */ private void rewriteFunctionDeclaration(Node n) { // Prepare a spot for the function. Node oldNameNode = n.getFirstChild(); Node fnNameNode = oldNameNode.cloneNode(); Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno()); var.copyInformationFrom(n); // Prepare the function oldNameNode.setString(""); // Move the function Node parent = n.getParent(); parent.replaceChild(n, var); fnNameNode.addChildToFront(n); reportCodeChange("Function declaration"); } /** * Do normalizations that introduce new siblings or parents.', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); Var v = s.getVar(name); // If name is "arguments", Var maybe null. Preconditions.checkState( v == null || v.getParentNode().getType() != Token.CATCH); if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) { s.undeclare(v); s.declare(name, n, n.getJSType(), v.input); replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent()); } } else if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps);'], ['', '', '', 'if (parent.getType() == Token.VAR) {'], ['case Token.FUNCTION: normalizeFunctionDeclaration(n); break;', 'private void normalizeFunctionDeclaration(Node n) { Preconditions.checkState(n.getType() == Token.FUNCTION); if (!NodeUtil.isFunctionAnonymous(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) { rewriteFunctionDeclaration(n); } }', 'private void rewriteFunctionDeclaration(Node n) { Node oldNameNode = n.getFirstChild(); Node fnNameNode = oldNameNode.cloneNode(); Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno()); var.copyInformationFrom(n); oldNameNode.setString(""); Node parent = n.getParent(); parent.replaceChild(n, var); fnNameNode.addChildToFront(n); reportCodeChange("Function declaration"); }', 'Var v = s.getVar(name); Preconditions.checkState( v == null || v.getParentNode().getType() != Token.CATCH); if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) { s.undeclare(v); s.declare(name, n, n.getJSType(), v.input); replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent()); } } else if (parent.getType() == Token.VAR) {'], 'a/src/com/google/javascript/jscomp/Normalize.java', 'b/src/com/google/javascript/jscomp/Normalize.java']
['Closure-140', 3, 3, 3, 3, ['initOptions(options); checkFirstModule(modules); this.externs = makeCompilerInput(externs, true); this.modules = modules;', '* Fill any empty modules with a place holder file. It makes any cross module * motion easier. */ static final DiagnosticType DUPLICATE_INPUT_IN_MODULES = DiagnosticType.error("JSC_DUPLICATE_INPUT_IN_MODULES_ERROR",', 'if (inputs.size() > 0) { return inputs.get(0).getAstRoot(this); } for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) { inputs = m.getInputs(); if (inputs.size() > 0) { return inputs.get(0).getAstRoot(this); } } throw new IllegalStateException("Root module has no inputs"); }'], ['initOptions(options); checkFirstModule(modules); fillEmptyModules(modules); this.externs = makeCompilerInput(externs, true); this.modules = modules;', '* Fill any empty modules with a place holder file. It makes any cross module * motion easier. */ private void fillEmptyModules(JSModule[] modules) { for (int i = 1; i < modules.length; i ++) { JSModule module = modules[i]; if (module.getInputs().isEmpty()) { module.add(JSSourceFile.fromCode("[" + module.getName() + "]", "")); } } } static final DiagnosticType DUPLICATE_INPUT_IN_MODULES = DiagnosticType.error("JSC_DUPLICATE_INPUT_IN_MODULES_ERROR",', 'if (inputs.size() > 0) { return inputs.get(0).getAstRoot(this); } throw new IllegalStateException("Root module has no inputs"); }'], ['', '', 'for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) { inputs = m.getInputs(); if (inputs.size() > 0) { return inputs.get(0).getAstRoot(this); } }'], ['fillEmptyModules(modules);', 'private void fillEmptyModules(JSModule[] modules) { for (int i = 1; i < modules.length; i ++) { JSModule module = modules[i]; if (module.getInputs().isEmpty()) { module.add(JSSourceFile.fromCode("[" + module.getName() + "]", "")); } } }', ''], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-141', 3, 3, 3, 3, ['case Token.GETELEM: return true; // Anonymous functions definitions are not changed by side-effects, // and named functions are not part of expressions. } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {', '*/ private static Collection<Definition> getCallableDefinitions( DefinitionProvider definitionProvider, Node name) { List<Definition> result = Lists.newArrayList(); if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) { return null; } Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name); if (decls == null) {', '} return result; } /**'], ['case Token.GETELEM: return true; case Token.FUNCTION: // Anonymous functions definitions are not changed by side-effects, // and named functions are not part of expressions. Preconditions.checkState(NodeUtil.isAnonymousFunction(n)); return false; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {', '*/ private static Collection<Definition> getCallableDefinitions( DefinitionProvider definitionProvider, Node name) { if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) { List<Definition> result = Lists.newArrayList(); Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name); if (decls == null) {', '} return result; } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) { Node firstVal; if (name.getType() == Token.HOOK) { firstVal = name.getFirstChild().getNext(); } else { firstVal = name.getFirstChild(); } Collection<Definition> defs1 = getCallableDefinitions(definitionProvider, firstVal); Collection<Definition> defs2 = getCallableDefinitions(definitionProvider, firstVal.getNext()); if (defs1 != null && defs2 != null) { defs1.addAll(defs2); return defs1; } else { return null; } } else { return null; } } /**'], ['', 'if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) { return null; }', ''], ['case Token.FUNCTION: Preconditions.checkState(NodeUtil.isAnonymousFunction(n)); return false;', 'if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {', '} else if (name.getType() == Token.OR || name.getType() == Token.HOOK) { Node firstVal; if (name.getType() == Token.HOOK) { firstVal = name.getFirstChild().getNext(); } else { firstVal = name.getFirstChild(); } Collection<Definition> defs1 = getCallableDefinitions(definitionProvider, firstVal); Collection<Definition> defs2 = getCallableDefinitions(definitionProvider, firstVal.getNext()); if (defs1 != null && defs2 != null) { defs1.addAll(defs2); return defs1; } else { return null; } } else { return null; }'], 'a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java', 'b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java']
['Closure-142', 3, 3, 3, 3, ['// a work-around for an IE bug where it throws an exception if you // write to the parameters of the callback in a sort(). See: // http://code.google.com/p/closure-compiler/issues/detail?id=58 liveness.analyze(); UndiGraph<Var, Void> interferenceGraph =', "case EOF: // When we're capturing a license block, annotations // in the block are ok. String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) {", '} return new ExtractionInfo(multilineText, token); // FALL THROUGH'], ['// a work-around for an IE bug where it throws an exception if you // write to the parameters of the callback in a sort(). See: // http://code.google.com/p/closure-compiler/issues/detail?id=58 if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) { liveness.markAllParametersEscaped(); } liveness.analyze(); UndiGraph<Var, Void> interferenceGraph =', "case EOF: // When we're capturing a license block, annotations // in the block are ok. if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) {", '} return new ExtractionInfo(multilineText, token); } // FALL THROUGH'], ['', '', ''], ['if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) { liveness.markAllParametersEscaped(); }', 'if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) {', '}'], 'a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java', 'b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java']
['Closure-143', 2, 2, 2, 2, ["} else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') )) { // If the value starts and ends with a single quote, // we assume that it's a string. String maybeStringVal =", ' Node exprBody = node.getFirstChild(); if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody) ) { changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody)); } }'], ['} else if (defValue.length() > 1 && ((defValue.charAt(0) == \'\\\'\' && defValue.charAt(defValue.length() - 1) == \'\\\'\') || (defValue.charAt(0) == \'\\"\' && defValue.charAt(defValue.length() - 1) == \'\\"\'))) { // If the value starts and ends with a single quote, // we assume that it\'s a string. String maybeStringVal =', ' Node exprBody = node.getFirstChild(); if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody) || exprBody.getType() == Token.NEW || exprBody.getType() == Token.CALL) { changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody)); } }'], [')) {', ') {'], ['|| (defValue.charAt(0) == \'\\"\' && defValue.charAt(defValue.length() - 1) == \'\\"\'))) {', '|| exprBody.getType() == Token.NEW || exprBody.getType() == Token.CALL) {'], 'a/src/com/google/javascript/jscomp/RemoveConstantExpressions.java', 'b/src/com/google/javascript/jscomp/RemoveConstantExpressions.java']
['Closure-144', 9, 9, 9, 9, ['private final Scope scope; private JSType returnType = null; private List<ObjectType> implementedInterfaces = null; private ObjectType baseType = null; private ObjectType thisType = null;', '*/ FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE); if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); }', '* If we haven\'t found a return value yet, try to look at the "return" * statements in the function. */ /** * Infer the role of the function (whether it\'s a constructor or interface)', '.withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) .withReturnType(returnType) .withTypeOfThis(thisType) .withTemplateName(templateTypeName) .build();', 'Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry);', '.setSourceNode(fnRoot) .inferFromOverriddenFunction(propType, parametersNode) .inferThisType(info, owner) .buildAndRegister(); } }', '.inferInheritance(info) .inferThisType(info, owner) .inferParameterTypes(parametersNode, info) .buildAndRegister(); }', "} /** Set the return type and whether it's inferred. */ /** Sets an inferred return type. */ public FunctionBuilder withInferredReturnType(JSType returnType) {", ' FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) { return new FunctionType( registry, null, null, new ArrowType( registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);'], ['private final Scope scope; private JSType returnType = null; private boolean returnTypeInferred = false; private List<ObjectType> implementedInterfaces = null; private ObjectType baseType = null; private ObjectType thisType = null;', '*/ FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : null; if (templateTypeName != null && returnType != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); }', '* If we haven\'t found a return value yet, try to look at the "return" * statements in the function. */ FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) { if (functionBlock == null || compiler.getInput(sourceName).isExtern()) { return this; } Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK); if (returnType == null) { boolean hasNonEmptyReturns = false; List<Node> worklist = Lists.newArrayList(functionBlock); while (!worklist.isEmpty()) { Node current = worklist.remove(worklist.size() - 1); int cType = current.getType(); if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) { hasNonEmptyReturns = true; break; } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) { for (Node child = current.getFirstChild(); child != null; child = child.getNext()) { worklist.add(child); } } } if (!hasNonEmptyReturns) { returnType = typeRegistry.getNativeType(VOID_TYPE); returnTypeInferred = true; } } return this; } /** * Infer the role of the function (whether it\'s a constructor or interface)', '.withName(fnName) .withSourceNode(sourceNode) .withParamsNode(parametersNode) .withReturnType(returnType, returnTypeInferred) .withTypeOfThis(thisType) .withTemplateName(templateTypeName) .build();', 'Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; Node fnBlock = isFnLiteral ? parametersNode.getNext() : null; if (functionType == null && info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry);', '.setSourceNode(fnRoot) .inferFromOverriddenFunction(propType, parametersNode) .inferThisType(info, owner) .inferReturnStatements(fnBlock) .buildAndRegister(); } }', '.inferInheritance(info) .inferThisType(info, owner) .inferParameterTypes(parametersNode, info) .inferReturnStatements(fnBlock) .buildAndRegister(); }', "} /** Set the return type and whether it's inferred. */ public FunctionBuilder withReturnType(JSType returnType, boolean inferred) { this.returnType = returnType; this.inferredReturnType = inferred; return this; } /** Sets an inferred return type. */ public FunctionBuilder withInferredReturnType(JSType returnType) {", ' FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) { return new FunctionType( registry, null, source, new ArrowType( registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);'], ['', 'info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE);', '', '.withReturnType(returnType)', '', '', '', '', 'registry, null, null,'], ['private boolean returnTypeInferred = false;', 'info.getReturnType().evaluate(scope, typeRegistry) : null; returnType != null &&', 'FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) { if (functionBlock == null || compiler.getInput(sourceName).isExtern()) { return this; } Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK); if (returnType == null) { boolean hasNonEmptyReturns = false; List<Node> worklist = Lists.newArrayList(functionBlock); while (!worklist.isEmpty()) { Node current = worklist.remove(worklist.size() - 1); int cType = current.getType(); if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) { hasNonEmptyReturns = true; break; } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) { for (Node child = current.getFirstChild(); child != null; child = child.getNext()) { worklist.add(child); } } } if (!hasNonEmptyReturns) { returnType = typeRegistry.getNativeType(VOID_TYPE); returnTypeInferred = true; } } return this; }', '.withReturnType(returnType, returnTypeInferred)', 'Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;', '.inferReturnStatements(fnBlock)', '.inferReturnStatements(fnBlock)', 'public FunctionBuilder withReturnType(JSType returnType, boolean inferred) { this.returnType = returnType; this.inferredReturnType = inferred; return this; }', 'registry, null, source,'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-145', 1, 1, 1, 1, ["* labels). */ private boolean isOneExactlyFunctionOrDo(Node n) { // For labels with block children, we need to ensure that a // labeled FUNCTION or DO isn't generated when extraneous BLOCKs // are skipped. // Either a empty statement or an block with more than one child, // way it isn't a FUNCTION or DO. return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } /**"], ["* labels). */ private boolean isOneExactlyFunctionOrDo(Node n) { if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { // For labels with block children, we need to ensure that a // labeled FUNCTION or DO isn't generated when extraneous BLOCKs // are skipped. if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { // Either a empty statement or an block with more than one child, // way it isn't a FUNCTION or DO. return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); } } /**"], [''], ['if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { return false; } } } else { }'], 'a/src/com/google/javascript/jscomp/CodeGenerator.java', 'b/src/com/google/javascript/jscomp/CodeGenerator.java']
['Closure-146', 1, 1, 1, 1, ['// other types switch (this.testForEquality(that)) { case TRUE: return new TypePair(null, null); case FALSE: case UNKNOWN:'], ['// other types switch (this.testForEquality(that)) { case TRUE: JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); case FALSE: case UNKNOWN:'], ['return new TypePair(null, null);'], ['JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType);'], 'a/src/com/google/javascript/rhino/jstype/JSType.java', 'b/src/com/google/javascript/rhino/jstype/JSType.java']
['Closure-147', 2, 2, 2, 2, ['if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) { return false; } } ld mode 100755 ew mode 100644', ' // To satisfy normalization constraints, the type checking must be // added after any inner function declarations. for (Node paramType : funType.getParameters()) { // Can this ever happen? ld mode 100755 ew mode 100644 ld mode 100755 ew mode 100644 ld mode 100755 ew mode 100644'], ['if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN || pType == Token.OBJECTLIT)) { return false; } } ld mode 100755 ew mode 100644', ' // To satisfy normalization constraints, the type checking must be // added after any inner function declarations. for (Node next = block.getFirstChild(); next != null && NodeUtil.isFunctionDeclaration(next); next = next.getNext()) { insertionPoint = next; } for (Node paramType : funType.getParameters()) { // Can this ever happen? ld mode 100755 ew mode 100644 ld mode 100755 ew mode 100644 ld mode 100755 ew mode 100644'], ['pType == Token.ASSIGN)) {', ''], ['pType == Token.ASSIGN || pType == Token.OBJECTLIT)) {', 'for (Node next = block.getFirstChild(); next != null && NodeUtil.isFunctionDeclaration(next); next = next.getNext()) { insertionPoint = next; }'], 'a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java', 'b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java']
['Closure-148', 16, 16, 16, 16, ['case Token.ARRAYLIT: typeNameString = "object"; break; case Token.NAME: // We assume here that programs don\'t change the value of the // keyword undefined to something other than the value undefined.', '*/ public class SourceMap { /** * A mapping from a given position in an input source file to a given position', '/** * A unique ID for this mapping for record keeping purposes. */ int id; /** * The input source file.', '/** * Whether the mapping is actually used by the source map. */ /** * Cache of escaped source file name. */ /** * Appends the mapping to the given buffer. */ void appendTo(Appendable out) throws IOException { out.append("["); out.append(sourceFile); // The source file rarely changes, so cache the escaped string. out.append(","); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(","); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(","); out.append(originalName); } out.append("]"); } /** * Add used mappings to the supplied Appendable. */ } /**', 'private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } private String lastSourceFile = null; private String lastSourceFileEscaped = null; /** * Adds a mapping for the given node. Mappings must be added in order.', 'return; } String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, "s1 != s2" not "!s1.equals(s2)" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; // Create the new mapping. Mapping mapping = new Mapping(); mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = escapeString(originalName); } // If the mapping is found on the first line, we need to offset // its character position by the number of characters found on // the *last* line of the source file to which the code is', 'mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); mappings.add(mapping); }', 'prefixPosition = new Position(0, 0); } private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); } /** * Appends the source map in LavaBug format to the given buffer. *', '// 11) ["c.js", 1, 4] // 12) ["d.js", 3, 78, "foo"] int maxLine = findLastLine(); // Add the line character maps. out.append("/** Begin line maps. **/{ \\"file\\" : ");', '// Add the mappings themselves. out.append("/** Begin mapping definitions. **/\\n"); for (Mapping mapping : mappings) { mapping.appendTo(out); out.append("\\n"); } } /** * Assigns sequential ids to used mappings, and returns the last line mapped. */ // Mark any unused mappings. // Renumber used mappings and keep track of the last line. // Adjust for the prefix. private class LineMapper { // The destination. private final Appendable out; private int line; private int col; // Whether the current line has had a value written yet. private boolean firstChar = true; private final static String UNMAPPED_STRING = "-1"; private final static int UNMAPPED = -1; LineMapper(Appendable out) { this.out = out;', '/** * As each segment is visited write out the appropriate line mapping. */ // Prevent the creation of unnecessary temporary stings for often // repeated values. // Append the line mapping entries. void appendLineMappings() throws IOException {', '// Start the first line. openLine(); // And close the final line. /** * Begin the entry for a new line. */ /** * End the entry for a line. */ /** * Add a new char position entry. * @param id The mapping id to record. */ /** * Mark any visited mapping as "used". */ /** * @throws IOException */ /** * @param m The mapping for the current code segment. null if the segment * is unmapped.', '* @param endCol The ending column * @throws IOException */ /** * Walk the mappings and visit each segment of the mappings, unmapped * segments are visited with a null mapping, unused mapping are not visited. */ // The last line and column written // Append the line mapping entries. // The mapping list is ordered as a pre-order traversal. The mapping // positions give us enough information to rebuild the stack and this', '// closed in the reverse order of when they encountered. while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); writeClosedMapping(previous); } // Any gaps between the current line position and the start of the // current mapping belong to the parent. Mapping parent = stack.peek(); writeCharsBetween(parent, m); stack.push(m); }', '// mappings in the reverse order of when they encountered. while (!stack.isEmpty()) { Mapping m = stack.pop(); writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append("["); this.firstChar = true; } private void closeLine() throws IOException { out.append("]\\n"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(","); } out.append(id); } /**', '* Write any needed entries from the current position to the end of the * provided mapping. */ private void writeClosedMapping(Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); // If this anything remaining in this mapping beyond the // current line and column position, write it out now. if (line < nextLine || (line == nextLine && col < nextCol)) { writeCharsUpTo(nextLine, nextCol, m.id); } } /** * Write any needed entries to complete the provided mapping. */ private void writeCharsBetween(Mapping prev, Mapping next) throws IOException { int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); // If the previous value is null, no mapping exists. int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); } /** * Write any entries needed between the current position the next position * and update the current position. */ private void writeCharsUpTo( int nextLine, int nextCol, int id) throws IOException { Preconditions.checkState(line <= nextLine, ""); Preconditions.checkState(line < nextLine || col <= nextCol); if (line == nextLine && col == nextCol) { // Nothing to do. return; } String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } line = nextLine; col = nextCol;'], ['case Token.ARRAYLIT: typeNameString = "object"; break; case Token.VOID: typeNameString = "undefined"; break; case Token.NAME: // We assume here that programs don\'t change the value of the // keyword undefined to something other than the value undefined.', '*/ public class SourceMap { private final static int UNMAPPED = -1; /** * A mapping from a given position in an input source file to a given position', '/** * A unique ID for this mapping for record keeping purposes. */ int id = UNMAPPED; /** * The input source file.', '/** * Whether the mapping is actually used by the source map. */ boolean used = false; } private class MappingWriter { /** * Cache of escaped source file name. */ private String lastSourceFile = null; private String lastSourceFileEscaped = null; private int lastLine = 0; private String lastLineString = String.valueOf(0); /** * Appends the mapping to the given buffer. */ private void appendMappingTo( Mapping m, Appendable out) throws IOException { out.append("["); String sourceFile = m.sourceFile; // The source file rarely changes, so cache the escaped string. String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2) lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; out.append(escapedSourceFile); out.append(","); int line = m.originalPosition.getLineNumber(); if (line != lastLine) { lastLineString = String.valueOf(line); } String lineValue = lastLineString; out.append(lineValue); out.append(","); out.append(String.valueOf( m.originalPosition.getCharacterIndex())); if (m.originalName != null) { out.append(","); out.append(escapeString(m.originalName)); } out.append("]\\n"); } /** * Add used mappings to the supplied Appendable. */ void appendMappings(Appendable out) throws IOException { for (Mapping m : mappings) { if (m.used) { appendMappingTo(m, out); } } } } /**', 'private static String escapeString(String value) { return CodeGenerator.escapeToDoubleQuotedJsString(value); } /** * Adds a mapping for the given node. Mappings must be added in order.', 'return; } // Create the new mapping. Mapping mapping = new Mapping(); mapping.sourceFile = sourceFile; mapping.originalPosition = new Position(node.getLineno(), node.getCharno()); String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP); if (originalName != null) { mapping.originalName = originalName; } if (offsetPosition.getLineNumber() == 0 && offsetPosition.getCharacterIndex() == 0) { mapping.startPosition = startPosition; mapping.endPosition = endPosition; } else { // If the mapping is found on the first line, we need to offset // its character position by the number of characters found on // the *last* line of the source file to which the code is', 'mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition); } mappings.add(mapping); }', 'prefixPosition = new Position(0, 0); } /** * Appends the source map in LavaBug format to the given buffer. *', '// 11) ["c.js", 1, 4] // 12) ["d.js", 3, 78, "foo"] int maxLine = prepMappings(); // Add the line character maps. out.append("/** Begin line maps. **/{ \\"file\\" : ");', '// Add the mappings themselves. out.append("/** Begin mapping definitions. **/\\n"); (new MappingWriter()).appendMappings(out); } /** * Assigns sequential ids to used mappings, and returns the last line mapped. */ private int prepMappings() throws IOException { // Mark any unused mappings. (new MappingTraversal()).traverse(new UsedMappingCheck()); // Renumber used mappings and keep track of the last line. int id = 0; int maxLine = 0; for (Mapping m : mappings) { if (m.used) { m.id = id++; int endPositionLine = m.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } } // Adjust for the prefix. return maxLine + prefixPosition.getLineNumber(); } private class LineMapper implements MappingVisitor { // The destination. private final Appendable out; // Whether the current line has had a value written yet. private boolean firstChar = true; private final static String UNMAPPED_STRING = "-1"; private int lastId = UNMAPPED; private String lastIdString = UNMAPPED_STRING; LineMapper(Appendable out) { this.out = out;', '/** * As each segment is visited write out the appropriate line mapping. */ public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { int id = (m != null) ? m.id : UNMAPPED; if (lastId != id) { // Prevent the creation of unnecessary temporary stings for often // repeated values. lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); lastId = id; } String idString = lastIdString; for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } } // Append the line mapping entries. void appendLineMappings() throws IOException {', '// Start the first line. openLine(); (new MappingTraversal()).traverse(this); // And close the final line. closeLine(); } /** * Begin the entry for a new line. */ private void openLine() throws IOException { if (out != null) { out.append("["); this.firstChar = true; } } /** * End the entry for a line. */ private void closeLine() throws IOException { if (out != null) { out.append("]\\n"); } } /** * Add a new char position entry. * @param id The mapping id to record. */ private void addCharEntry(String id) throws IOException { if (out != null) { if (firstChar) { firstChar = false; } else { out.append(","); } out.append(id); } } } /** * Mark any visited mapping as "used". */ private class UsedMappingCheck implements MappingVisitor { /** * @throws IOException */ @Override public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { if (m != null) { m.used = true; } } } private interface MappingVisitor { /** * @param m The mapping for the current code segment. null if the segment * is unmapped.', '* @param endCol The ending column * @throws IOException */ void visit(Mapping m, int line, int col, int endLine, int endCol) throws IOException; } /** * Walk the mappings and visit each segment of the mappings, unmapped * segments are visited with a null mapping, unused mapping are not visited. */ private class MappingTraversal { // The last line and column written private int line; private int col; MappingTraversal() { } // Append the line mapping entries. void traverse(MappingVisitor v) throws IOException { Preconditions.checkState(!mappings.isEmpty()); // The mapping list is ordered as a pre-order traversal. The mapping // positions give us enough information to rebuild the stack and this', '// closed in the reverse order of when they encountered. while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) { Mapping previous = stack.pop(); maybeVisit(v, previous); } // Any gaps between the current line position and the start of the // current mapping belong to the parent. Mapping parent = stack.peek(); maybeVisitParent(v, parent, m); stack.push(m); }', '// mappings in the reverse order of when they encountered. while (!stack.isEmpty()) { Mapping m = stack.pop(); maybeVisit(v, m); } } /**', '* Write any needed entries from the current position to the end of the * provided mapping. */ private void maybeVisit(MappingVisitor v, Mapping m) throws IOException { int nextLine = getAdjustedLine(m.endPosition); int nextCol = getAdjustedCol(m.endPosition); // If this anything remaining in this mapping beyond the // current line and column position, write it out now. if (line < nextLine || (line == nextLine && col < nextCol)) { visit(v, m, nextLine, nextCol); } } /** * Write any needed entries to complete the provided mapping. */ private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m) throws IOException { int nextLine = getAdjustedLine(m.startPosition); int nextCol = getAdjustedCol(m.startPosition); // If the previous value is null, no mapping exists. Preconditions.checkState(line < nextLine || col <= nextCol); if (line < nextLine || (line == nextLine && col < nextCol)) { visit(v, parent, nextLine, nextCol); } } /** * Write any entries needed between the current position the next position * and update the current position. */ private void visit(MappingVisitor v, Mapping m, int nextLine, int nextCol) throws IOException { Preconditions.checkState(line <= nextLine); Preconditions.checkState(line < nextLine || col < nextCol); if (line == nextLine && col == nextCol) { // Nothing to do. Preconditions.checkState(false); return; } v.visit(m, line, col, nextLine, nextCol); line = nextLine; col = nextCol;'], ['', '', 'int id;', 'void appendTo(Appendable out) throws IOException { out.append(sourceFile); out.append(String.valueOf(originalPosition.getLineNumber())); out.append(String.valueOf(originalPosition.getCharacterIndex())); if (originalName != null) { out.append(originalName); out.append("]");', 'private String lastSourceFile = null; private String lastSourceFileEscaped = null;', 'String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, "s1 != s2" not "!s1.equals(s2)" lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; mapping.id = mappings.size(); mapping.sourceFile = escapedSourceFile; mapping.originalName = escapeString(originalName);', '', 'private int findLastLine() { int maxLine = 0; for (Mapping mapping : mappings) { int endPositionLine = mapping.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } return maxLine + prefixPosition.getLineNumber(); }', 'int maxLine = findLastLine();', 'for (Mapping mapping : mappings) { mapping.appendTo(out); out.append("\\n"); } private class LineMapper { private int line; private int col; private final static int UNMAPPED = -1;', '', '', '', 'writeClosedMapping(previous); writeCharsBetween(parent, m);', 'writeClosedMapping(m); } closeLine(); } private void openLine() throws IOException { out.append("["); this.firstChar = true; } private void closeLine() throws IOException { out.append("]\\n"); } private void addCharEntry(String id) throws IOException { if (firstChar) { firstChar = false; } else { out.append(","); out.append(id);', 'private void writeClosedMapping(Mapping m) throws IOException { writeCharsUpTo(nextLine, nextCol, m.id); private void writeCharsBetween(Mapping prev, Mapping next) int nextLine = getAdjustedLine(next.startPosition); int nextCol = getAdjustedCol(next.startPosition); int id = (prev != null) ? prev.id : UNMAPPED; writeCharsUpTo(nextLine, nextCol, id); private void writeCharsUpTo( int nextLine, int nextCol, int id) Preconditions.checkState(line <= nextLine, ""); Preconditions.checkState(line < nextLine || col <= nextCol); String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); }'], ['case Token.VOID: typeNameString = "undefined"; break;', 'private final static int UNMAPPED = -1;', 'int id = UNMAPPED;', 'boolean used = false; } private class MappingWriter { private String lastSourceFile = null; private String lastSourceFileEscaped = null; private int lastLine = 0; private String lastLineString = String.valueOf(0); private void appendMappingTo( Mapping m, Appendable out) throws IOException { String sourceFile = m.sourceFile; String escapedSourceFile; if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2) lastSourceFile = sourceFile; lastSourceFileEscaped = escapeString(sourceFile); } escapedSourceFile = lastSourceFileEscaped; out.append(escapedSourceFile); int line = m.originalPosition.getLineNumber(); if (line != lastLine) { lastLineString = String.valueOf(line); } String lineValue = lastLineString; out.append(lineValue); out.append(String.valueOf( m.originalPosition.getCharacterIndex())); if (m.originalName != null) { out.append(escapeString(m.originalName)); out.append("]\\n"); void appendMappings(Appendable out) throws IOException { for (Mapping m : mappings) { if (m.used) { appendMappingTo(m, out); } } }', '', 'mapping.sourceFile = sourceFile; mapping.originalName = originalName; if (offsetPosition.getLineNumber() == 0 && offsetPosition.getCharacterIndex() == 0) { mapping.startPosition = startPosition; mapping.endPosition = endPosition; } else {', '}', '', 'int maxLine = prepMappings();', '(new MappingWriter()).appendMappings(out); private int prepMappings() throws IOException { (new MappingTraversal()).traverse(new UsedMappingCheck()); int id = 0; int maxLine = 0; for (Mapping m : mappings) { if (m.used) { m.id = id++; int endPositionLine = m.endPosition.getLineNumber(); maxLine = Math.max(maxLine, endPositionLine); } } return maxLine + prefixPosition.getLineNumber(); } private class LineMapper implements MappingVisitor { private int lastId = UNMAPPED; private String lastIdString = UNMAPPED_STRING;', 'public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { int id = (m != null) ? m.id : UNMAPPED; if (lastId != id) { lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id); lastId = id; } String idString = lastIdString; for (int i = line; i <= nextLine; i++) { if (i == nextLine) { for (int j = col; j < nextCol; j++) { addCharEntry(idString); } break; } closeLine(); openLine(); } }', '(new MappingTraversal()).traverse(this); closeLine(); } private void openLine() throws IOException { if (out != null) { out.append("["); this.firstChar = true; } } private void closeLine() throws IOException { if (out != null) { out.append("]\\n"); } } private void addCharEntry(String id) throws IOException { if (out != null) { if (firstChar) { firstChar = false; } else { out.append(","); } out.append(id); } } } private class UsedMappingCheck implements MappingVisitor { @Override public void visit(Mapping m, int line, int col, int nextLine, int nextCol) throws IOException { if (m != null) { m.used = true; } } } private interface MappingVisitor {', 'void visit(Mapping m, int line, int col, int endLine, int endCol) throws IOException; } private class MappingTraversal { private int line; private int col; MappingTraversal() { } void traverse(MappingVisitor v) throws IOException { Preconditions.checkState(!mappings.isEmpty());', 'maybeVisit(v, previous); maybeVisitParent(v, parent, m);', 'maybeVisit(v, m);', 'private void maybeVisit(MappingVisitor v, Mapping m) throws IOException { visit(v, m, nextLine, nextCol); private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m) int nextLine = getAdjustedLine(m.startPosition); int nextCol = getAdjustedCol(m.startPosition); Preconditions.checkState(line < nextLine || col <= nextCol); if (line < nextLine || (line == nextLine && col < nextCol)) { visit(v, parent, nextLine, nextCol); } private void visit(MappingVisitor v, Mapping m, int nextLine, int nextCol) Preconditions.checkState(line <= nextLine); Preconditions.checkState(line < nextLine || col < nextCol); Preconditions.checkState(false); v.visit(m, line, col, nextLine, nextCol);'], 'a/src/com/google/javascript/jscomp/SourceMap.java', 'b/src/com/google/javascript/jscomp/SourceMap.java']
['Closure-149', 7, 7, 7, 7, ['options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) {', 'Result result; setRunOptions(options); if (inputCharset == Charsets.UTF_8) { options.outputCharset = Charsets.US_ASCII; } else { options.outputCharset = inputCharset; } boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) {', '* be a supported charset. * @throws FlagUsageException if flag is not a valid Charset name. */ protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException {', '} options.closurePass = flags.process_closure_primitives; initOptionsFromFlags(options); return options; }', 'builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); Charset charset = options.outputCharset; builder.setOutputCharset(charset); return builder.build();', "* Charset to use when generating code. If null, then output ASCII. * This needs to be a string because CompilerOptions is serializable. */ public Charset outputCharset; /** * Whether the named objects types included 'undefined' by default.", '/** * Sets the output charset by name. */ /** * Whether to include "undefined" in the default types.'], ['options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); options.outputCharset = getOutputCharset(); inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) {', 'Result result; setRunOptions(options); boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) {', '* be a supported charset. * @throws FlagUsageException if flag is not a valid Charset name. */ private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + " is not a valid charset name."); } return config.charset; } return "US-ASCII"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException {', '} options.closurePass = flags.process_closure_primitives; return options; }', 'builder.setSourceMap(sourceMap); builder.setSourceMapDetailLevel(options.sourceMapDetailLevel); Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null; builder.setOutputCharset(charset); return builder.build();', "* Charset to use when generating code. If null, then output ASCII. * This needs to be a string because CompilerOptions is serializable. */ String outputCharset; /** * Whether the named objects types included 'undefined' by default.", '/** * Sets the output charset by name. */ public void setOutputCharset(String charsetName) { this.outputCharset = charsetName; } /** * Whether to include "undefined" in the default types.'], ['', 'if (inputCharset == Charsets.UTF_8) { options.outputCharset = Charsets.US_ASCII; } else { options.outputCharset = inputCharset; }', '', 'initOptionsFromFlags(options);', 'Charset charset = options.outputCharset;', 'public Charset outputCharset;', ''], ['options.outputCharset = getOutputCharset();', '', 'private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + " is not a valid charset name."); } return config.charset; } return "US-ASCII"; }', '', 'Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;', 'String outputCharset;', 'public void setOutputCharset(String charsetName) { this.outputCharset = charsetName; }'], 'a/src/com/google/javascript/jscomp/CompilerOptions.java', 'b/src/com/google/javascript/jscomp/CompilerOptions.java']
['Closure-150', 1, 1, 1, 1, ['return; } attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } } /** Handle bleeding functions and function parameters. */'], ['return; } super.visit(t, n, parent); } /** Handle bleeding functions and function parameters. */'], ['attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; }'], ['super.visit(t, n, parent);'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-151', 3, 3, 3, 3, ['+ "a manifest for each module.") private String output_manifest = ""; // Our own option parser to be backwards-compatible. // It needs to be public because of the crazy reflection that args4j does.', ' private final Flags flags = new Flags(); private boolean isConfigValid = false;', 'isConfigValid = false; } if (!isConfigValid || flags.display_help) { isConfigValid = false;'], ['+ "a manifest for each module.") private String output_manifest = ""; @Option(name = "--version", usage = "Prints the compiler version to stderr.") private boolean version = false; // Our own option parser to be backwards-compatible. // It needs to be public because of the crazy reflection that args4j does.', ' private final Flags flags = new Flags(); private static final String configResource = "com.google.javascript.jscomp.parsing.ParserConfig"; private boolean isConfigValid = false;', 'isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( "Closure Compiler (http://code.google.com/p/closure/compiler)\\n" + "Version: " + config.getString("compiler.version") + "\\n" + "Built on: " + config.getString("compiler.date")); err.flush(); } if (!isConfigValid || flags.display_help) { isConfigValid = false;'], ['', '', ''], ['@Option(name = "--version", usage = "Prints the compiler version to stderr.") private boolean version = false;', 'private static final String configResource = "com.google.javascript.jscomp.parsing.ParserConfig";', 'if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( "Closure Compiler (http://code.google.com/p/closure/compiler)\\n" + "Version: " + config.getString("compiler.version") + "\\n" + "Built on: " + config.getString("compiler.date")); err.flush(); }'], 'a/src/com/google/javascript/jscomp/CommandLineRunner.java', 'b/src/com/google/javascript/jscomp/CommandLineRunner.java']
['Closure-152', 1, 1, 1, 1, ["// Warning about typeOfThis if it doesn't resolve to an ObjectType // is handled further upstream. // TODO(nicksantos): Handle this correctly if we have a UnionType. typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces ="], ["// Warning about typeOfThis if it doesn't resolve to an ObjectType // is handled further upstream. // TODO(nicksantos): Handle this correctly if we have a UnionType. JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces ="], ['typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);'], ['JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }'], 'a/src/com/google/javascript/rhino/jstype/FunctionType.java', 'b/src/com/google/javascript/rhino/jstype/FunctionType.java']
['Closure-153', 13, 13, 13, 13, ['private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { /** * Remove duplicate VAR declarations encountered discovered during', '*/ @Override public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { Preconditions.checkState(n.getType() == Token.NAME); Var v = s.getVar(name); // We allow variables to be duplicate declared if one // declaration appears in source and the other in externs. // This deals with issues where a browser built-in is declared // in one browser but not in another. // If name is "arguments", Var maybe null. if (v != null && v.getParentNode().getType() == Token.CATCH) {', 'name); compiler.report( JSError.make( NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name)); } else if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) {', '} else if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, gramps); } }', 'import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.JSType; /**', '// been declared in the outer scope. String fnName = fnNameNode.getString(); if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) { declareVar(fnName, fnNameNode, n, null, null, n); } // Args: Declare function variables', 'for (Node a = args.getFirstChild(); a != null; a = a.getNext()) { Preconditions.checkState(a.getType() == Token.NAME); declareVar(a.getString(), a, args, n, null, n); } // Body', 'for (Node child = n.getFirstChild(); child != null;) { Node next = child.getNext(); Preconditions.checkState(child.getType() == Token.NAME); String name = child.getString(); declareVar(name, child, n, parent, null, n); child = next; } return;', "// This is invalid, but allow it so the checks can catch it. return; } declareVar(fnName, n.getFirstChild(), n, parent, null, n); return; // should not examine function's children case Token.CATCH:", 'final Node var = n.getFirstChild(); final Node block = var.getNext(); declareVar(var.getString(), var, n, parent, null, n); scanVars(block, n); return; // only one child to scan', '*/ interface RedeclarationHandler { void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber); } /**', "*/ private class DefaultRedeclarationHandler implements RedeclarationHandler { public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) { // Don't allow multiple variables to be declared at the top level scope if (scope.isGlobal()) {", "* @param n The node corresponding to the variable name. * @param declaredType The variable's type, according to JSDoc */ private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) { if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) { redeclarationHandler.onRedeclaration( scope, name, n, parent, gramps, nodeWithLineNumber); } else { scope.declare(name, n, declaredType, compiler.getInput(sourceName)); } } }"], ['private final class DuplicateDeclarationHandler implements SyntacticScopeCreator.RedeclarationHandler { private Set<Var> hasOkDuplicateDeclaration = Sets.newHashSet(); /** * Remove duplicate VAR declarations encountered discovered during', '*/ @Override public void onRedeclaration( Scope s, String name, Node n, CompilerInput input) { Preconditions.checkState(n.getType() == Token.NAME); Node parent = n.getParent(); Var v = s.getVar(name); if (v != null && s.isGlobal()) { // We allow variables to be duplicate declared if one // declaration appears in source and the other in externs. // This deals with issues where a browser built-in is declared // in one browser but not in another. if (v.isExtern() && !input.isExtern()) { if (hasOkDuplicateDeclaration.add(v)) { return; } } } // If name is "arguments", Var maybe null. if (v != null && v.getParentNode().getType() == Token.CATCH) {', 'name); compiler.report( JSError.make( input.getName(), n, CATCH_BLOCK_VAR_ERROR, name)); } else if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) {', '} else if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, parent.getParent()); } }', 'import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; /**', '// been declared in the outer scope. String fnName = fnNameNode.getString(); if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) { declareVar(fnNameNode); } // Args: Declare function variables', 'for (Node a = args.getFirstChild(); a != null; a = a.getNext()) { Preconditions.checkState(a.getType() == Token.NAME); declareVar(a); } // Body', 'for (Node child = n.getFirstChild(); child != null;) { Node next = child.getNext(); declareVar(child); child = next; } return;', "// This is invalid, but allow it so the checks can catch it. return; } declareVar(n.getFirstChild()); return; // should not examine function's children case Token.CATCH:", 'final Node var = n.getFirstChild(); final Node block = var.getNext(); declareVar(var); scanVars(block, n); return; // only one child to scan', '*/ interface RedeclarationHandler { void onRedeclaration( Scope s, String name, Node n, CompilerInput input); } /**', "*/ private class DefaultRedeclarationHandler implements RedeclarationHandler { public void onRedeclaration( Scope s, String name, Node n, CompilerInput input) { Node parent = n.getParent(); // Don't allow multiple variables to be declared at the top level scope if (scope.isGlobal()) {", "* @param n The node corresponding to the variable name. * @param declaredType The variable's type, according to JSDoc */ private void declareVar(Node n) { Preconditions.checkState(n.getType() == Token.NAME); CompilerInput input = compiler.getInput(sourceName); String name = n.getString(); if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) { redeclarationHandler.onRedeclaration( scope, name, n, input); } else { scope.declare(name, n, null, input); } } }"], ['', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {', 'NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,', 'replaceVarWithAssignment(n, parent, gramps);', 'import com.google.javascript.rhino.jstype.JSType;', 'declareVar(fnName, fnNameNode, n, null, null, n);', 'declareVar(a.getString(), a, args, n, null, n);', 'Preconditions.checkState(child.getType() == Token.NAME); String name = child.getString(); declareVar(name, child, n, parent, null, n);', 'declareVar(fnName, n.getFirstChild(), n, parent, null, n);', 'declareVar(var.getString(), var, n, parent, null, n);', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);', 'Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {', 'private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) { scope, name, n, parent, gramps, nodeWithLineNumber); scope.declare(name, n, declaredType, compiler.getInput(sourceName));'], ['private Set<Var> hasOkDuplicateDeclaration = Sets.newHashSet();', 'Scope s, String name, Node n, CompilerInput input) { Node parent = n.getParent(); if (v != null && s.isGlobal()) { if (v.isExtern() && !input.isExtern()) { if (hasOkDuplicateDeclaration.add(v)) { return; } } }', 'input.getName(), n,', 'replaceVarWithAssignment(n, parent, parent.getParent());', '', 'declareVar(fnNameNode);', 'declareVar(a);', 'declareVar(child);', 'declareVar(n.getFirstChild());', 'declareVar(var);', 'Scope s, String name, Node n, CompilerInput input);', 'Scope s, String name, Node n, CompilerInput input) { Node parent = n.getParent();', 'private void declareVar(Node n) { Preconditions.checkState(n.getType() == Token.NAME); CompilerInput input = compiler.getInput(sourceName); String name = n.getString(); scope, name, n, input); scope.declare(name, n, null, input);'], 'a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java', 'b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java']
['Closure-154', 6, 6, 6, 6, ['"original: {2}\\n" + "override: {3}"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "mismatch of the {0} property type and the type " + "of the property it overrides from interface {1}\\n" + "original: {2}\\n" + "override: {3}"); static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( "JSC_UNKNOWN_OVERRIDE",', 'HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE,', 'HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); } if (interfaceHasProperty) { JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(interfacePropType)) { compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString())); } } } }', '"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED", "property {0} on interface {1} is not implemented by type {2}"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST,', 'MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler;', 'prop, implementedInterface.toString(), instance.toString())); } registerMismatch(instance, implementedInterface); // Implemented, but not correctly typed } }'], ['"original: {2}\\n" + "override: {3}"); static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( "JSC_UNKNOWN_OVERRIDE",', 'HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE,', 'HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); } } }', '"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED", "property {0} on interface {1} is not implemented by type {2}"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "mismatch of the {0} property type and the type " + "of the property it overrides from interface {1}\\n" + "original: {2}\\n" + "override: {3}"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST,', 'MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler;', 'prop, implementedInterface.toString(), instance.toString())); } registerMismatch(instance, implementedInterface); } else { JSType found = instance.getPropertyType(prop); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) { // Implemented, but not correctly typed if (shouldReport) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString())); } registerMismatch(found, required); } } }'], ['static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "mismatch of the {0} property type and the type " + "of the property it overrides from interface {1}\\n" + "original: {2}\\n" + "override: {3}");', 'HIDDEN_INTERFACE_PROPERTY_MISMATCH,', 'if (interfaceHasProperty) { JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(interfacePropType)) { compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString())); } }', '', 'INTERFACE_METHOD_NOT_IMPLEMENTED);', ''], ['', '', '', 'static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "mismatch of the {0} property type and the type " + "of the property it overrides from interface {1}\\n" + "original: {2}\\n" + "override: {3}");', 'INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH);', '} else { JSType found = instance.getPropertyType(prop); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) { if (shouldReport) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString())); } registerMismatch(found, required); }'], 'a/src/com/google/javascript/jscomp/TypeValidator.java', 'b/src/com/google/javascript/jscomp/TypeValidator.java']
['Closure-155', 7, 7, 7, 7, ['private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next();', '// inlining heuristics. See InlineConstantsTest. continue; } else { inlineNonConstants(v, referenceInfo); } } } // Any reference that is not a read of the arguments property // consider a escape of the arguments object. private void inlineNonConstants( Var v, ReferenceCollection referenceInfo) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference();', "// inline an alias of it. (If the variable was inlined, then the // reference data is out of sync. We're better off just waiting for // the next pass.) if ( !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references;", '*/ public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v = t.getScope().getVar(n.getString()); if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek()));', '/** Whether this is a bottom scope for the purposes of type inference. */ private final boolean isBottom; /** Stores info about a variable */ public static class Var implements StaticSlot<JSType> {', '* scope. */ // TODO(johnlenz): Include this the list of Vars for the scope. // TODO(johnlenz): provide the type of "Arguments". /** * Creates a Scope given the parent Scope and the root node of the scope.', '/** * Get a unique VAR object to represents "arguments" within this scope */ /** * Returns true if a variable is declared.'], ['private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments(t.getScope(), referenceMap); for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) { Var v = it.next();', '// inlining heuristics. See InlineConstantsTest. continue; } else { inlineNonConstants(v, referenceInfo, maybeModifiedArguments); } } } private boolean maybeEscapedOrModifiedArguments( Scope scope, Map<Var, ReferenceCollection> referenceMap) { if (scope.isLocal()) { Var arguments = scope.getArgumentsVar(); ReferenceCollection refs = referenceMap.get(arguments); if (refs != null && !refs.references.isEmpty()) { for (Reference ref : refs.references) { Node refNode = ref.getNameNode(); Node refParent = ref.getParent(); // Any reference that is not a read of the arguments property // consider a escape of the arguments object. if (!(NodeUtil.isGet(refParent) && refNode == ref.getParent().getFirstChild() && !isLValue(refParent))) { return true; } } } } return false; } private boolean isLValue(Node n) { Node parent = n.getParent(); return (parent.getType() == Token.INC || parent.getType() == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)); } private void inlineNonConstants( Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) { int refCount = referenceInfo.references.size(); Reference declaration = referenceInfo.references.get(0); Reference init = referenceInfo.getInitializingReference();', "// inline an alias of it. (If the variable was inlined, then the // reference data is out of sync. We're better off just waiting for // the next pass.) if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { List<Reference> refs = referenceInfo.references;", '*/ public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { Var v; if (n.getString().equals("arguments")) { v = t.getScope().getArgumentsVar(); } else { v = t.getScope().getVar(n.getString()); } if (v != null && varFilter.apply(v)) { addReference(t, v, new Reference(n, parent, t, blockStack.peek()));', '/** Whether this is a bottom scope for the purposes of type inference. */ private final boolean isBottom; private Var arguments; /** Stores info about a variable */ public static class Var implements StaticSlot<JSType> {', '* scope. */ // TODO(johnlenz): Include this the list of Vars for the scope. public static class Arguments extends Var { Arguments(Scope scope) { super( false, // no inferred "arguments", // always arguments null, // no declaration node // TODO(johnlenz): provide the type of "Arguments". null, // no type info scope, -1, // no variable index null, // input, false, // not a define null // no jsdoc ); } @Override public boolean equals(Object other) { if (!(other instanceof Arguments)) { return false; } Arguments otherVar = (Arguments) other; return otherVar.scope.getRootNode() == scope.getRootNode(); } @Override public int hashCode() { return System.identityHashCode(this); } } /** * Creates a Scope given the parent Scope and the root node of the scope.', '/** * Get a unique VAR object to represents "arguments" within this scope */ public Var getArgumentsVar() { if (arguments == null) { arguments = new Arguments(this); } return arguments; } /** * Returns true if a variable is declared.'], ['', 'inlineNonConstants(v, referenceInfo); Var v, ReferenceCollection referenceInfo) {', 'if (', 'Var v = t.getScope().getVar(n.getString());', '', '', ''], ['boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);', 'inlineNonConstants(v, referenceInfo, maybeModifiedArguments); private boolean maybeEscapedOrModifiedArguments( Scope scope, Map<Var, ReferenceCollection> referenceMap) { if (scope.isLocal()) { Var arguments = scope.getArgumentsVar(); ReferenceCollection refs = referenceMap.get(arguments); if (refs != null && !refs.references.isEmpty()) { for (Reference ref : refs.references) { Node refNode = ref.getNameNode(); Node refParent = ref.getParent(); if (!(NodeUtil.isGet(refParent) && refNode == ref.getParent().getFirstChild() && !isLValue(refParent))) { return true; } } } } return false; } private boolean isLValue(Node n) { Node parent = n.getParent(); return (parent.getType() == Token.INC || parent.getType() == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)); } Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {', 'if (!maybeModifiedArguments &&', 'Var v; if (n.getString().equals("arguments")) { v = t.getScope().getArgumentsVar(); } else { v = t.getScope().getVar(n.getString()); }', 'private Var arguments;', 'public static class Arguments extends Var { Arguments(Scope scope) { super( false, // no inferred "arguments", // always arguments null, // no declaration node null, // no type info scope, -1, // no variable index null, // input, false, // not a define null // no jsdoc ); } @Override public boolean equals(Object other) { if (!(other instanceof Arguments)) { return false; } Arguments otherVar = (Arguments) other; return otherVar.scope.getRootNode() == scope.getRootNode(); } @Override public int hashCode() { return System.identityHashCode(this); } }', 'public Var getArgumentsVar() { if (arguments == null) { arguments = new Arguments(this); } return arguments; }'], 'a/src/com/google/javascript/jscomp/Scope.java', 'b/src/com/google/javascript/jscomp/Scope.java']
['Closure-156', 7, 7, 7, 7, ['boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); // Handle this name first so that nested object literals get unrolled. if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias); } if (n.props != null) {', "* this name. (This is mostly passed for convenience; it's equivalent to * n.canCollapseChildNames()). */ private void updateObjLitOrFunctionDeclaration(Name n, String alias) { if (n.declaration == null) { // Some names do not have declarations, because they // are only defined in local scopes.", ' switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n); break; } }', '* @param alias The flattened name for {@code n} (e.g. "a", "a$b$c") */ private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias) { // NOTE: It\'s important that we don\'t add additional nodes // (e.g. a var node before the exprstmt) because the exprstmt might be // the child of an if statement that\'s not inside a block).', 'insertedVarNode = true; } if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); if (insertedVarNode) { if (!varNode.hasChildren()) {', '* * @param n An object representing a global name (e.g. "a") */ private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) { Ref ref = n.declaration; String name = ref.node.getString();', '* * @param n An object representing a global name (e.g. "a") */ private void updateFunctionDeclarationAtFunctionNode(Name n) { Ref ref = n.declaration; String fnName = ref.node.getString();'], ['boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); // Handle this name first so that nested object literals get unrolled. if (n.canCollapse()) { updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames); } if (n.props != null) {', "* this name. (This is mostly passed for convenience; it's equivalent to * n.canCollapseChildNames()). */ private void updateObjLitOrFunctionDeclaration( Name n, String alias, boolean canCollapseChildNames) { if (n.declaration == null) { // Some names do not have declarations, because they // are only defined in local scopes.", ' switch (n.declaration.node.getParent().getType()) { case Token.ASSIGN: updateObjLitOrFunctionDeclarationAtAssignNode( n, alias, canCollapseChildNames); break; case Token.VAR: updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames); break; case Token.FUNCTION: updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames); break; } }', '* @param alias The flattened name for {@code n} (e.g. "a", "a$b$c") */ private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias, boolean canCollapseChildNames) { // NOTE: It\'s important that we don\'t add additional nodes // (e.g. a var node before the exprstmt) because the exprstmt might be // the child of an if statement that\'s not inside a block).', 'insertedVarNode = true; } if (canCollapseChildNames) { if (isObjLit) { declareVarsForObjLitValues( n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); } if (insertedVarNode) { if (!varNode.hasChildren()) {', '* * @param n An object representing a global name (e.g. "a") */ private void updateObjLitOrFunctionDeclarationAtVarNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; } Ref ref = n.declaration; String name = ref.node.getString();', '* * @param n An object representing a global name (e.g. "a") */ private void updateFunctionDeclarationAtFunctionNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; } Ref ref = n.declaration; String fnName = ref.node.getString();'], ['if (n.canCollapse() && canCollapseChildNames) { updateObjLitOrFunctionDeclaration(n, alias);', 'private void updateObjLitOrFunctionDeclaration(Name n, String alias) {', 'updateObjLitOrFunctionDeclarationAtAssignNode(n, alias); updateObjLitOrFunctionDeclarationAtVarNode(n); updateFunctionDeclarationAtFunctionNode(n);', 'Name n, String alias) {', 'if (isObjLit) { addStubsForUndeclaredProperties(n, alias, varParent, varNode);', 'private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {', 'private void updateFunctionDeclarationAtFunctionNode(Name n) {'], ['if (n.canCollapse()) { updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);', 'private void updateObjLitOrFunctionDeclaration( Name n, String alias, boolean canCollapseChildNames) {', 'updateObjLitOrFunctionDeclarationAtAssignNode( n, alias, canCollapseChildNames); updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames); updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);', 'Name n, String alias, boolean canCollapseChildNames) {', 'if (canCollapseChildNames) { if (isObjLit) { } addStubsForUndeclaredProperties(n, alias, varParent, varNode);', 'private void updateObjLitOrFunctionDeclarationAtVarNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; }', 'private void updateFunctionDeclarationAtFunctionNode( Name n, boolean canCollapseChildNames) { if (!canCollapseChildNames) { return; }'], 'a/src/com/google/javascript/jscomp/CollapseProperties.java', 'b/src/com/google/javascript/jscomp/CollapseProperties.java']
['Closure-157', 7, 7, 7, 7, ['Node body = fn.getLastChild(); // Add the property name. if (TokenStream.isJSIdentifier(name) && // do not encode literally any non-literal characters that were // unicode escaped. NodeUtil.isLatin(name)) { add(name); } else { // Determine if the string is a simple number. add(jsString(n.getString(), outputCharsetEncoder)); } add(parameters);', 'if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { // Object literal property names don\'t have to be quoted if they // are not JavaScript keywords if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && // do not encode literally any non-literal characters that // were unicode escaped. NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { // Determine if the string is a simple number. addExpr(c, 1); } add(":"); addExpr(c.getFirstChild(), 1);', 'cc.endSourceMapping(n); } /** * @return Whether the name is an indirect eval.', 'child != null; child = child.getNext()) { if (child.getType() != Token.NUMBER) { markObjLitPropertyCandidate(child, t.getInput()); } }', ' for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { if (key.getType() != Token.NUMBER) { // May be STRING, GET, or SET markPrototypePropertyCandidate(key, input); }', 'return irNode; } // Return "1" instead of "1.0" private void setSourceInfo(Node irNode, AstNode node) { // If we have a named function, set the position to that of the name.', 'Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else { ret = transform(n); Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { ret.putBooleanProp(Node.QUOTED_PROP, true); } } return ret; }'], ['Node body = fn.getLastChild(); // Add the property name. if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && // do not encode literally any non-literal characters that were // unicode escaped. NodeUtil.isLatin(name)) { add(name); } else { // Determine if the string is a simple number. double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { add(jsString(n.getString(), outputCharsetEncoder)); } } add(parameters);', 'if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { Preconditions.checkState(c.getType() == Token.STRING); String key = c.getString(); // Object literal property names don\'t have to be quoted if they // are not JavaScript keywords if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && // do not encode literally any non-literal characters that // were unicode escaped. NodeUtil.isLatin(key)) { add(key); } else { // Determine if the string is a simple number. double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1); } } add(":"); addExpr(c.getFirstChild(), 1);', "cc.endSourceMapping(n); } static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len > 0; } static double getSimpleNumber(String s) { if (isSimpleNumber(s)) { long l = Long.parseLong(s); if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) { return l; } } return Double.NaN; } /** * @return Whether the name is an indirect eval.", 'child != null; child = child.getNext()) { if (TokenStream.isJSIdentifier(child.getString())) { markObjLitPropertyCandidate(child, t.getInput()); } }', ' for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { if (TokenStream.isJSIdentifier(key.getString())) { // May be STRING, GET, or SET markPrototypePropertyCandidate(key, input); }', 'return irNode; } private Node transformNumberAsString(NumberLiteral literalNode) { JSDocInfo jsDocInfo = handleJsDoc(literalNode); Node irNode = newStringNode(getStringValue(literalNode.getNumber())); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, literalNode); return irNode; } private static String getStringValue(double value) { long longValue = (long) value; // Return "1" instead of "1.0" if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(value); } } private void setSourceInfo(Node irNode, AstNode node) { // If we have a named function, set the position to that of the name.', 'Node ret; if (n instanceof Name) { ret = transformNameAsString((Name)n); } else if (n instanceof NumberLiteral) { ret = transformNumberAsString((NumberLiteral)n); ret.putBooleanProp(Node.QUOTED_PROP, true); } else { ret = transform(n); ret.putBooleanProp(Node.QUOTED_PROP, true); } Preconditions.checkState(ret.getType() == Token.STRING); return ret; }'], ['if (TokenStream.isJSIdentifier(name) && add(jsString(n.getString(), outputCharsetEncoder));', 'if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString()); addExpr(c, 1);', '', 'if (child.getType() != Token.NUMBER) {', 'if (key.getType() != Token.NUMBER) {', '', 'Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING); if (ret.getType() == Token.STRING) { }'], ['if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { add(jsString(n.getString(), outputCharsetEncoder)); }', 'Preconditions.checkState(c.getType() == Token.STRING); String key = c.getString(); if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) { add(key); double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1); }', "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len > 0; } static double getSimpleNumber(String s) { if (isSimpleNumber(s)) { long l = Long.parseLong(s); if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) { return l; } } return Double.NaN; }", 'if (TokenStream.isJSIdentifier(child.getString())) {', 'if (TokenStream.isJSIdentifier(key.getString())) {', 'private Node transformNumberAsString(NumberLiteral literalNode) { JSDocInfo jsDocInfo = handleJsDoc(literalNode); Node irNode = newStringNode(getStringValue(literalNode.getNumber())); if (jsDocInfo != null) { irNode.setJSDocInfo(jsDocInfo); } setSourceInfo(irNode, literalNode); return irNode; } private static String getStringValue(double value) { long longValue = (long) value; if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(value); } }', '} else if (n instanceof NumberLiteral) { ret = transformNumberAsString((NumberLiteral)n); ret.putBooleanProp(Node.QUOTED_PROP, true); Preconditions.checkState(ret.getType() == Token.STRING);'], 'a/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'b/src/com/google/javascript/jscomp/parsing/IRFactory.java']
['Closure-158', 12, 12, 12, 12, ['throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF); createDefineOrTweakReplacements(config.define, options, false);', 'return this; } private final List<String> jscompError = Lists.newArrayList(); /** * Add warning guards. */ CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning); return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff); return this; }', '* A little helper class to make it easier to collect warning types * from --jscomp_error, --jscomp_warning, and --jscomp_off. */ // The entries, in the order that they were added. }', 'import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser;', '// I don\'t really care about unchecked warnings in this class. @SuppressWarnings("unchecked") private static class Flags { @Option(name = "--help", handler = BooleanOptionHandler.class,', 'private String create_source_map = ""; @Option(name = "--jscomp_error", usage = "Make the named class of warnings an error. Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = "--jscomp_warning", usage = "Make the named class of warnings a normal warning. " + "Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = "--jscomp_off", usage = "Turn off the named class of warnings. Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList();', ' // Our own parser for warning guards that preserves the original order // of the flags. } /**', 'List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); // Currently we are not supporting this (prevent direct/indirect loops)', 'List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {}));', '.setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies)', 'import com.google.common.collect.ImmutableMap; import com.google.common.collect.Maps; import java.util.List; import java.util.Map; /**', '/** * Adds warning levels by name. */ void setWarningLevels(CompilerOptions options, List<String> diagnosticGroups, CheckLevel level) { for (String name : diagnosticGroups) { DiagnosticGroup group = forName(name); Preconditions.checkNotNull(group, "No warning class for name: " + name); options.setWarningLevel(group, level); } } }'], ['throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); if (config.warningGuards != null) { for (WarningGuardSpec.Entry entry : config.warningGuards.entries) { diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level); } } createDefineOrTweakReplacements(config.define, options, false);', 'return this; } private WarningGuardSpec warningGuards = null; /** * Add warning guards. */ CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) { this.warningGuards = spec; return this; }', '* A little helper class to make it easier to collect warning types * from --jscomp_error, --jscomp_warning, and --jscomp_off. */ protected static class WarningGuardSpec { private static class Entry { private final CheckLevel level; private final String groupName; private Entry(CheckLevel level, String groupName) { this.level = level; this.groupName = groupName; } } // The entries, in the order that they were added. private final List<Entry> entries = Lists.newArrayList(); protected void add(CheckLevel level, String groupName) { entries.add(new Entry(level, groupName)); } protected void clear() { entries.clear(); } } }', 'import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import com.google.javascript.jscomp.AbstractCommandLineRunner.WarningGuardSpec; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser;', '// I don\'t really care about unchecked warnings in this class. @SuppressWarnings("unchecked") private static class Flags { private static final WarningGuardSpec warningGuardSpec = new WarningGuardSpec(); @Option(name = "--help", handler = BooleanOptionHandler.class,', 'private String create_source_map = ""; @Option(name = "--jscomp_error", handler = WarningGuardErrorOptionHandler.class, usage = "Make the named class of warnings an error. Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = "--jscomp_warning", handler = WarningGuardWarningOptionHandler.class, usage = "Make the named class of warnings a normal warning. " + "Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = "--jscomp_off", handler = WarningGuardOffOptionHandler.class, usage = "Turn off the named class of warnings. Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList();', ' // Our own parser for warning guards that preserves the original order // of the flags. public static class WarningGuardErrorOptionHandler extends StringOptionHandler { public WarningGuardErrorOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.ERROR)); } } public static class WarningGuardWarningOptionHandler extends StringOptionHandler { public WarningGuardWarningOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.WARNING)); } } public static class WarningGuardOffOptionHandler extends StringOptionHandler { public WarningGuardOffOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.OFF)); } } private static class WarningGuardSetter implements Setter { private final Setter proxy; private final CheckLevel level; private WarningGuardSetter(Setter proxy, CheckLevel level) { this.proxy = proxy; this.level = level; } @Override public boolean isMultiValued() { return proxy.isMultiValued(); } @Override public Class getType() { return proxy.getType(); } @Override public void addValue(Object value) throws CmdLineException { proxy.addValue((String) value); warningGuardSpec.add(level, (String) value); } } } /**', 'List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); Flags.warningGuardSpec.clear(); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); // Currently we are not supporting this (prevent direct/indirect loops)', 'List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); Flags.warningGuardSpec.clear(); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {}));', '.setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setWarningGuardSpec(Flags.warningGuardSpec) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies)', 'import com.google.common.collect.ImmutableMap; import com.google.common.collect.Maps; import java.util.Map; /**', '/** * Adds warning levels by name. */ void setWarningLevel(CompilerOptions options, String name, CheckLevel level) { DiagnosticGroup group = forName(name); Preconditions.checkNotNull(group, "No warning class for name: " + name); options.setWarningLevel(group, level); } }'], ['diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF);', 'private final List<String> jscompError = Lists.newArrayList(); CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning); return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff);', '', '', '', '', '', '', '', '.setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off)', 'import java.util.List;', 'void setWarningLevels(CompilerOptions options, List<String> diagnosticGroups, CheckLevel level) { for (String name : diagnosticGroups) { }'], ['if (config.warningGuards != null) { for (WarningGuardSpec.Entry entry : config.warningGuards.entries) { diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level); } }', 'private WarningGuardSpec warningGuards = null; CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) { this.warningGuards = spec;', 'protected static class WarningGuardSpec { private static class Entry { private final CheckLevel level; private final String groupName; private Entry(CheckLevel level, String groupName) { this.level = level; this.groupName = groupName; } } private final List<Entry> entries = Lists.newArrayList(); protected void add(CheckLevel level, String groupName) { entries.add(new Entry(level, groupName)); } protected void clear() { entries.clear(); } }', 'import com.google.javascript.jscomp.AbstractCommandLineRunner.WarningGuardSpec;', 'private static final WarningGuardSpec warningGuardSpec = new WarningGuardSpec();', 'handler = WarningGuardErrorOptionHandler.class, handler = WarningGuardWarningOptionHandler.class, handler = WarningGuardOffOptionHandler.class,', 'public static class WarningGuardErrorOptionHandler extends StringOptionHandler { public WarningGuardErrorOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.ERROR)); } } public static class WarningGuardWarningOptionHandler extends StringOptionHandler { public WarningGuardWarningOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.WARNING)); } } public static class WarningGuardOffOptionHandler extends StringOptionHandler { public WarningGuardOffOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.OFF)); } } private static class WarningGuardSetter implements Setter { private final Setter proxy; private final CheckLevel level; private WarningGuardSetter(Setter proxy, CheckLevel level) { this.proxy = proxy; this.level = level; } @Override public boolean isMultiValued() { return proxy.isMultiValued(); } @Override public Class getType() { return proxy.getType(); } @Override public void addValue(Object value) throws CmdLineException { proxy.addValue((String) value); warningGuardSpec.add(level, (String) value); } }', 'Flags.warningGuardSpec.clear();', 'Flags.warningGuardSpec.clear();', '.setWarningGuardSpec(Flags.warningGuardSpec)', '', 'void setWarningLevel(CompilerOptions options, String name, CheckLevel level) {'], 'a/src/com/google/javascript/jscomp/DiagnosticGroups.java', 'b/src/com/google/javascript/jscomp/DiagnosticGroups.java']
['Closure-159', 1, 1, 1, 1, ['Node node, Set<String> changed) { Preconditions.checkArgument(changed != null); // For each referenced function, add a new reference if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); } }'], ['Node node, Set<String> changed) { Preconditions.checkArgument(changed != null); // For each referenced function, add a new reference if (node.getType() == Token.NAME) { if (isCandidateUsage(node)) { changed.add(node.getString()); } }'], ['if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());'], ['if (node.getType() == Token.NAME) { if (isCandidateUsage(node)) { changed.add(node.getString());'], 'a/src/com/google/javascript/jscomp/InlineFunctions.java', 'b/src/com/google/javascript/jscomp/InlineFunctions.java']
['Closure-160', 2, 2, 2, 2, ["getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); // All passes must run the variable check. This synthesizes // variables later so that the compiler doesn't crash. It also", '// about missing variable declarations, we shut that specific // error off. if (!options.checkSymbols && (warningsGuard == null || !warningsGuard.disables( DiagnosticGroups.CHECK_VARIABLES))) { guards.add(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = new ComposeWarningsGuard(guards); } /**'], ["getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); // All passes must run the variable check. This synthesizes // variables later so that the compiler doesn't crash. It also", '// about missing variable declarations, we shut that specific // error off. if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; } /**'], ['', '(warningsGuard == null || !warningsGuard.disables( DiagnosticGroups.CHECK_VARIABLES))) { guards.add(new DiagnosticGroupWarningsGuard( this.warningsGuard = new ComposeWarningsGuard(guards);'], ['ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);', '!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( this.warningsGuard = composedGuards;'], 'a/src/com/google/javascript/jscomp/Compiler.java', 'b/src/com/google/javascript/jscomp/Compiler.java']
['Closure-161', 1, 1, 1, 1, ['// If GETPROP/GETELEM is used as assignment target the array literal is // acting as a temporary we can\'t fold it here: // "[][0] += 1" if (right.getType() != Token.NUMBER) { // Sometimes people like to use complex expressions to index into'], ['// If GETPROP/GETELEM is used as assignment target the array literal is // acting as a temporary we can\'t fold it here: // "[][0] += 1" if (isAssignmentTarget(n)) { return n; } if (right.getType() != Token.NUMBER) { // Sometimes people like to use complex expressions to index into'], [''], ['if (isAssignmentTarget(n)) { return n; }'], 'a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java', 'b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java']
['Closure-162', 6, 6, 6, 6, ['/** * Return an iterable over all of the variables declared in this scope. */ @Override public Iterable<Var> getReferences(Var var) {', 'if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } }', 'hasErrors = true; } // TODO(robbyw): Support using locals for private variables. private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) {', "validateScopeCall(t, n, n.getParent()); } // Validate the top level of the goog.scope block. if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); // Return early, to ensure that we don't record a definition // twice. return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN);", "// Validate all descendent scopes of the goog.scope block. if (t.getScopeDepth() >= 2) { // Check if this name points to an alias. if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { // Note, to support the transitive case, it's important we don't // clone aliasedNode here. For example, // var g = goog; var d = g.dom; d.createElement('DIV');", "// with <code>g.dom.createElement('DIV')</code>. Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo();"], ['/** * Return an iterable over all of the variables declared in this scope. */ Iterable<Var> getVarIterable() { return vars.values(); } @Override public Iterable<Var> getReferences(Var var) {', 'if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); findAliases(t); } }', 'hasErrors = true; } private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) {', "validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } // Validate the top level of the goog.scope block. if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); // Return early, to ensure that we don't record a definition // twice. return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN);", "// Validate all descendent scopes of the goog.scope block. if (t.getScopeDepth() >= 2) { // Check if this name points to an alias. if (aliasVar != null) { // Note, to support the transitive case, it's important we don't // clone aliasedNode here. For example, // var g = goog; var d = g.dom; d.createElement('DIV');", "// with <code>g.dom.createElement('DIV')</code>. Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } JSDocInfo info = n.getJSDocInfo();"], ['', '', '', 'int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); }', 'if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {', '}'], ['Iterable<Var> getVarIterable() { return vars.values(); }', 'findAliases(t);', 'private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } }', 'if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());', 'if (aliasVar != null) {', ''], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-163', 18, 18, 18, 18, ["// given a name context. These contexts do not have scopes. private Stack<NameContext> symbolStack = new Stack<NameContext>(); private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } @Override public void enterScope(NodeTraversal t) { symbolStack.peek().scope = t.getScope(); // NOTE(nicksantos): We use the same anonymous node for all // functions that do not have reasonable names. I can't remember // at the moment why we do this. I think it's because anonymous // nodes can never have in-edges. They're just there as a placeholder // for scope information, and do not matter in the edge propagation. } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { // Process prototype assignments to non-functions. if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode)); } return true; }", 'if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals("prototype")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { // Do not mark prototype prop assigns as a \'use\' in the global scope. addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.isObjectLit() && // Make sure that we\'re not handling object literals being // assigned to a prototype, as in: // Foo.prototype = {bar: 3, baz: 5}; !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( "prototype"))) { // var x = {a: 1, b: 2} // should count as a use of property a and b.', 'if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else {', '} // Process prototype assignments to non-functions. if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) { symbolStack.pop(); } }', '* If this is a non-function prototype assign, return the prop name. * Otherwise, return null. */ /** * Determines whether {@code n} is the FUNCTION node in a global function', "private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { // Make sure we're either in the global scope, or the function // we're looking at is the root of the current local scope. return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); } /** * Returns true if this is the r-value of an assignment. */ private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp(); /** * Returns the name of a prototype property being assigned to this r-value.", '* the R-value is used in multiple expressions (i.e., if there\'s * a prototype property assignment in a more complex expression). */ if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals("prototype")) { return true; } } } return false; } /**', '* If it is, record it and return true. Otherwise, return false. */ private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) { Node firstChild = nameNode.getFirstChild(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||', "isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, parent, gramps, t.getModule())); // If the function name is exported, we should create an edge here // so that it's never removed.", '* under an assignment (in the case of Foo.prototype = ...). * @return True if a declaration was added. */ private void processPrototypeParent(NodeTraversal t, Node n) { switch (n.getType()) { // Foo.prototype.getBar = function() { ... } case Token.GETPROP:', 'String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } break;', 'String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } } break; } } private void addGlobalUseOfSymbol(String name, JSModule module,', '/** * The variable for the root of this symbol. */ /** * Returns the module where this appears.', '*/ class GlobalFunction implements Symbol { private final Node nameNode; private final JSModule module; GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) { Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.module = module; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) {', '*/ static class AssignmentProperty implements Property { private final Node exprNode; private final JSModule module; /** * @param node An EXPR node. */ AssignmentProperty(Node node, JSModule module) { this.exprNode = node; this.module = module; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }', 'private final Node value; private final Node map; private final Node assign; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.module = module; } @Override public void remove() { map.removeChild(key); }', ' // If this is a function context, then scope will be the scope of the // corresponding function. Otherwise, it will be null. Scope scope; NameContext(NameInfo name) { this.name = name; } }', '// So if we move a prototype method into a deeper module, we must // replace it with a stub function so that it preserves its original // behavior. Node value = prop.getValue(); if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&'], ["// given a name context. These contexts do not have scopes. private Stack<NameContext> symbolStack = new Stack<NameContext>(); @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode(); if (n.isFunction()) { String propName = getPrototypePropertyNameFromRValue(n); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), t.getScope())); } else if (isGlobalFunctionDeclaration(t, n)) { Node parent = n.getParent(); String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push( new NameContext(getNameInfoForName(name, VAR), t.getScope())); } else { // NOTE(nicksantos): We use the same anonymous node for all // functions that do not have reasonable names. I can't remember // at the moment why we do this. I think it's because anonymous // nodes can never have in-edges. They're just there as a placeholder // for scope information, and do not matter in the edge propagation. symbolStack.push(new NameContext(anonymousNode, t.getScope())); } } else { Preconditions.checkState(t.inGlobalScope()); symbolStack.push(new NameContext(globalNode, t.getScope())); } } @Override public void exitScope(NodeTraversal t) { symbolStack.pop(); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { // Process prototype assignments to non-functions. String propName = processNonFunctionPrototypeAssign(n, parent); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), null)); } return true; }", 'if (n.isGetProp()) { String propName = n.getFirstChild().getNext().getString(); if (n.isQualifiedName()) { if (propName.equals("prototype")) { if (processPrototypeRef(t, n)) { return; } } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); return; } else { // Do not mark prototype prop assigns as a \'use\' in the global scope. if (n.getParent().isAssign() && n.getNext() != null) { String rValueName = getPrototypePropertyNameFromRValue(n); if (rValueName != null) { return; } } } } addSymbolUse(propName, t.getModule(), PROPERTY); } else if (n.isObjectLit()) { // Make sure that we\'re not handling object literals being // assigned to a prototype, as in: // Foo.prototype = {bar: 3, baz: 5}; String lValueName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); if (lValueName != null && lValueName.endsWith(".prototype")) { return; } // var x = {a: 1, b: 2} // should count as a use of property a and b.', 'if (var.getInitialValue() != null && var.getInitialValue().isFunction()) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, var)) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else {', '} // Process prototype assignments to non-functions. if (processNonFunctionPrototypeAssign(n, parent) != null) { symbolStack.pop(); } }', '* If this is a non-function prototype assign, return the prop name. * Otherwise, return null. */ private String processNonFunctionPrototypeAssign(Node n, Node parent) { if (isAssignRValue(n, parent) && !n.isFunction()) { return getPrototypePropertyNameFromRValue(n); } return null; } /** * Determines whether {@code n} is the FUNCTION node in a global function', "private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) { // Make sure we're either in the global scope, or the function // we're looking at is the root of the current local scope. Scope s = t.getScope(); if (!(s.isGlobal() || s.getDepth() == 1 && s.getRootNode() == n)) { return false; } return NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName(); } /** * Returns true if this is the r-value of an assignment. */ private boolean isAssignRValue(Node n, Node parent) { return parent != null && parent.isAssign() && parent.getFirstChild() != n; } /** * Returns the name of a prototype property being assigned to this r-value.", '* the R-value is used in multiple expressions (i.e., if there\'s * a prototype property assignment in a more complex expression). */ private String getPrototypePropertyNameFromRValue(Node rValue) { Node lValue = NodeUtil.getBestLValue(rValue); if (lValue == null || lValue.getParent() == null || lValue.getParent().getParent() == null || !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) || NodeUtil.isExprAssign(lValue.getParent().getParent()))) { return null; } String lValueName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue)); if (lValueName == null) { return null; } int lastDot = lValueName.lastIndexOf(\'.\'); if (lastDot == -1) { return null; } String firstPart = lValueName.substring(0, lastDot); if (!firstPart.endsWith(".prototype")) { return null; } return lValueName.substring(lastDot + 1); } /**', '* If it is, record it and return true. Otherwise, return false. */ private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Var v) { Node firstChild = nameNode.getFirstChild(); Node parent = nameNode.getParent(); if (// Check for a named FUNCTION. isGlobalFunctionDeclaration(t, parent) ||', "isGlobalFunctionDeclaration(t, firstChild)) { String name = nameNode.getString(); getNameInfoForName(name, VAR).getDeclarations().add( new GlobalFunction(nameNode, v, t.getModule())); // If the function name is exported, we should create an edge here // so that it's never removed.", '* under an assignment (in the case of Foo.prototype = ...). * @return True if a declaration was added. */ private boolean processPrototypeRef(NodeTraversal t, Node ref) { Node root = NodeUtil.getRootOfQualifiedName(ref); Node n = ref.getParent(); switch (n.getType()) { // Foo.prototype.getBar = function() { ... } case Token.GETPROP:', 'String name = dest.getString(); Property prop = new AssignmentProperty( grandParent, t.getScope().getVar(root.getString()), t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); return true; } break;', 'String name = key.getString(); Property prop = new LiteralProperty( key, key.getFirstChild(), map, n, t.getScope().getVar(root.getString()), t.getModule()); getNameInfoForName(name, PROPERTY).getDeclarations().add(prop); } return true; } break; } return false; } private void addGlobalUseOfSymbol(String name, JSModule module,', '/** * The variable for the root of this symbol. */ Var getRootVar(); /** * Returns the module where this appears.', '*/ class GlobalFunction implements Symbol { private final Node nameNode; private final Var var; private final JSModule module; GlobalFunction(Node nameNode, Var var, JSModule module) { Node parent = nameNode.getParent(); Preconditions.checkState( parent.isVar() || NodeUtil.isFunctionDeclaration(parent)); this.nameNode = nameNode; this.var = var; this.module = module; } @Override public Var getRootVar() { return var; } @Override public void remove() { Node parent = nameNode.getParent(); if (parent.isFunction() || parent.hasOneChild()) {', '*/ static class AssignmentProperty implements Property { private final Node exprNode; private final Var rootVar; private final JSModule module; /** * @param node An EXPR node. */ AssignmentProperty(Node node, Var rootVar, JSModule module) { this.exprNode = node; this.rootVar = rootVar; this.module = module; } @Override public Var getRootVar() { return rootVar; } @Override public void remove() { NodeUtil.removeChild(exprNode.getParent(), exprNode); }', 'private final Node value; private final Node map; private final Node assign; private final Var rootVar; private final JSModule module; LiteralProperty(Node key, Node value, Node map, Node assign, Var rootVar, JSModule module) { this.key = key; this.value = value; this.map = map; this.assign = assign; this.rootVar = rootVar; this.module = module; } @Override public Var getRootVar() { return rootVar; } @Override public void remove() { map.removeChild(key); }', ' // If this is a function context, then scope will be the scope of the // corresponding function. Otherwise, it will be null. final Scope scope; NameContext(NameInfo name, Scope scope) { this.name = name; this.scope = scope; } }', '// So if we move a prototype method into a deeper module, we must // replace it with a stub function so that it preserves its original // behavior. if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) { continue; } Node value = prop.getValue(); if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&'], ['private ProcessProperties() { symbolStack.push(new NameContext(globalNode)); } symbolStack.peek().scope = t.getScope(); if (isPrototypePropertyAssign(n)) { symbolStack.push(new NameContext(getNameInfoForName( n.getFirstChild().getLastChild().getString(), PROPERTY))); } else if (isGlobalFunctionDeclaration(t, n)) { String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push(new NameContext(getNameInfoForName(name, VAR))); } else if (n.isFunction()) { symbolStack.push(new NameContext(anonymousNode));', 'processPrototypeParent(t, parent); addSymbolUse(propName, t.getModule(), PROPERTY); } else if (n.isObjectLit() && !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals( "prototype"))) {', 'if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {', 'if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {', '', 'return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName()); private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) { boolean isChainedProperty = n.getFirstChild().isGetProp();', 'if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.isString() && child.getString().equals("prototype")) { return true; } } return false;', 'Node nameNode, Node parent, Node gramps) {', 'new GlobalFunction(nameNode, parent, gramps, t.getModule()));', 'private void processPrototypeParent(NodeTraversal t, Node n) {', '', '', '', 'GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {', 'AssignmentProperty(Node node, JSModule module) {', 'JSModule module) {', 'Scope scope; NameContext(NameInfo name) {', ''], ['Node n = t.getCurrentNode(); if (n.isFunction()) { String propName = getPrototypePropertyNameFromRValue(n); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), t.getScope())); } else if (isGlobalFunctionDeclaration(t, n)) { Node parent = n.getParent(); String name = parent.isName() ? parent.getString() /* VAR */ : n.getFirstChild().getString() /* named function */; symbolStack.push( new NameContext(getNameInfoForName(name, VAR), t.getScope())); } else { symbolStack.push(new NameContext(anonymousNode, t.getScope())); } } else { Preconditions.checkState(t.inGlobalScope()); symbolStack.push(new NameContext(globalNode, t.getScope())); } symbolStack.pop(); String propName = processNonFunctionPrototypeAssign(n, parent); if (propName != null) { symbolStack.push( new NameContext( getNameInfoForName(propName, PROPERTY), null));', 'if (n.isQualifiedName()) { if (processPrototypeRef(t, n)) { return; } return; if (n.getParent().isAssign() && n.getNext() != null) { String rValueName = getPrototypePropertyNameFromRValue(n); if (rValueName != null) { return; } } } addSymbolUse(propName, t.getModule(), PROPERTY); } else if (n.isObjectLit()) { String lValueName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); if (lValueName != null && lValueName.endsWith(".prototype")) { return; }', 'if (!processGlobalFunctionDeclaration(t, n, var)) {', 'if (processNonFunctionPrototypeAssign(n, parent) != null) {', 'private String processNonFunctionPrototypeAssign(Node n, Node parent) { if (isAssignRValue(n, parent) && !n.isFunction()) { return getPrototypePropertyNameFromRValue(n); } return null; }', 'Scope s = t.getScope(); if (!(s.isGlobal() || s.getDepth() == 1 && s.getRootNode() == n)) { return false; } return NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName(); private boolean isAssignRValue(Node n, Node parent) { return parent != null && parent.isAssign() && parent.getFirstChild() != n; }', 'private String getPrototypePropertyNameFromRValue(Node rValue) { Node lValue = NodeUtil.getBestLValue(rValue); if (lValue == null || lValue.getParent() == null || lValue.getParent().getParent() == null || !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) || NodeUtil.isExprAssign(lValue.getParent().getParent()))) { return null; } String lValueName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue)); if (lValueName == null) { return null; } int lastDot = lValueName.lastIndexOf(\'.\'); if (lastDot == -1) { return null; String firstPart = lValueName.substring(0, lastDot); if (!firstPart.endsWith(".prototype")) { return null; } return lValueName.substring(lastDot + 1);', 'Node nameNode, Var v) { Node parent = nameNode.getParent();', 'new GlobalFunction(nameNode, v, t.getModule()));', 'private boolean processPrototypeRef(NodeTraversal t, Node ref) { Node root = NodeUtil.getRootOfQualifiedName(ref); Node n = ref.getParent();', 't.getScope().getVar(root.getString()), return true;', 't.getScope().getVar(root.getString()), return true; return false;', 'Var getRootVar();', 'private final Var var; GlobalFunction(Node nameNode, Var var, JSModule module) { Node parent = nameNode.getParent(); this.var = var; public Var getRootVar() { return var; } @Override', 'private final Var rootVar; AssignmentProperty(Node node, Var rootVar, JSModule module) { this.rootVar = rootVar; public Var getRootVar() { return rootVar; } @Override', 'private final Var rootVar; Var rootVar, JSModule module) { this.rootVar = rootVar; public Var getRootVar() { return rootVar; } @Override', 'final Scope scope; NameContext(NameInfo name, Scope scope) { this.scope = scope;', 'if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) { continue; }'], 'a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java', 'b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java']
['Closure-164', 2, 2, 2, 2, [' boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs(); // "that" can\'t be a supertype, because it\'s missing a required argument. // NOTE(nicksantos): In our type system, we use {function(...?)} and // {function(...NoType)} to to indicate that arity should not be // checked. Strictly speaking, this is not a correct formulation, // because now a sub-function can required arguments that are var_args // in the super-function. So we special-case this. // don\'t advance if we have variable arguments if (!thisIsVarArgs) {', '} // "that" can\'t be a supertype, because it\'s missing a required arguement. return true; }'], [' boolean thisIsVarArgs = thisParam.isVarArgs(); boolean thatIsVarArgs = thatParam.isVarArgs(); boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg(); // "that" can\'t be a supertype, because it\'s missing a required argument. if (!thisIsOptional && thatIsOptional) { // NOTE(nicksantos): In our type system, we use {function(...?)} and // {function(...NoType)} to to indicate that arity should not be // checked. Strictly speaking, this is not a correct formulation, // because now a sub-function can required arguments that are var_args // in the super-function. So we special-case this. boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType()); if (!isTopFunction) { return false; } } // don\'t advance if we have variable arguments if (!thisIsVarArgs) {', '} // "that" can\'t be a supertype, because it\'s missing a required arguement. if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) { return false; } return true; }'], ['', ''], ['boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg(); boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg(); if (!thisIsOptional && thatIsOptional) { boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType()); if (!isTopFunction) { return false; } }', 'if (thisParam != null && !thisParam.isOptionalArg() && !thisParam.isVarArgs() && thatParam == null) { return false; }'], 'a/src/com/google/javascript/rhino/jstype/ArrowType.java', 'b/src/com/google/javascript/rhino/jstype/ArrowType.java']
['Closure-165', 10, 10, 10, 10, ["if (!greatestSubtype.isEmptyType()) { // We've found a type with this property. Now we just have to make // sure it's not a type used for internal bookkeeping. return true; }", "* don't actually exist in the user's program. They're just used for * bookkeeping in the type system. */ /** * Defines a property whose type is inferred.", 'private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap(); private boolean isFrozen = false; /** * Creates a record type.', '* @throws IllegalStateException if the {@code RecordProperty} associated * with a property is null. */ RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { super(registry, null, null); setPrettyPrint(true); for (String property : properties.keySet()) { RecordProperty prop = properties.get(property);', 'throw new IllegalStateException( "RecordProperty associated with a property should not be null!"); } defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } // Freeze the record type.', '} /** @return Is this synthesized for internal bookkeeping? */ @Override public boolean isEquivalentTo(JSType other) {', 'if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type', '*/ public class RecordTypeBuilder { private boolean isEmpty = true; private final JSTypeRegistry registry; private final HashMap<String, RecordProperty> properties = Maps.newHashMap();', '} /** See the comments on RecordType about synthetic types. */ /** * Adds a property with the given name and type to the record type.', '} return new RecordType( registry, Collections.unmodifiableMap(properties)); } static class RecordProperty {'], ["if (!greatestSubtype.isEmptyType()) { // We've found a type with this property. Now we just have to make // sure it's not a type used for internal bookkeeping. RecordType maybeRecordType = greatestSubtype.toMaybeRecordType(); if (maybeRecordType != null && maybeRecordType.isSynthetic()) { continue; } return true; }", "* don't actually exist in the user's program. They're just used for * bookkeeping in the type system. */ public final boolean defineSynthesizedProperty(String propertyName, JSType type, Node propertyNode) { return defineProperty(propertyName, type, false, propertyNode); } /** * Defines a property whose type is inferred.", 'private static final long serialVersionUID = 1L; private final SortedMap<String, JSType> properties = Maps.newTreeMap(); private final boolean declared; private boolean isFrozen = false; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { this(registry, properties, true); } /** * Creates a record type.', '* @throws IllegalStateException if the {@code RecordProperty} associated * with a property is null. */ RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { super(registry, null, null); setPrettyPrint(true); this.declared = declared; for (String property : properties.keySet()) { RecordProperty prop = properties.get(property);', 'throw new IllegalStateException( "RecordProperty associated with a property should not be null!"); } if (declared) { defineDeclaredProperty( property, prop.getType(), prop.getPropertyNode()); } else { defineSynthesizedProperty( property, prop.getType(), prop.getPropertyNode()); } } // Freeze the record type.', '} /** @return Is this synthesized for internal bookkeeping? */ boolean isSynthetic() { return !declared; } @Override public boolean isEquivalentTo(JSType other) {', 'if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.setSynthesized(true); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type', '*/ public class RecordTypeBuilder { private boolean isEmpty = true; private boolean isDeclared = true; private final JSTypeRegistry registry; private final HashMap<String, RecordProperty> properties = Maps.newHashMap();', '} /** See the comments on RecordType about synthetic types. */ void setSynthesized(boolean synthesized) { isDeclared = !synthesized; } /** * Adds a property with the given name and type to the record type.', '} return new RecordType( registry, Collections.unmodifiableMap(properties), isDeclared); } static class RecordProperty {'], ['', '', '', 'RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {', '', '', '', '', '', 'registry, Collections.unmodifiableMap(properties));'], ['RecordType maybeRecordType = greatestSubtype.toMaybeRecordType(); if (maybeRecordType != null && maybeRecordType.isSynthetic()) { continue; }', 'public final boolean defineSynthesizedProperty(String propertyName, JSType type, Node propertyNode) { return defineProperty(propertyName, type, false, propertyNode); }', 'private final boolean declared; RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { this(registry, properties, true); }', 'RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties, boolean declared) { this.declared = declared;', 'if (declared) { } else { defineSynthesizedProperty( property, prop.getType(), prop.getPropertyNode()); }', 'boolean isSynthetic() { return !declared; }', 'builder.setSynthesized(true);', 'private boolean isDeclared = true;', 'void setSynthesized(boolean synthesized) { isDeclared = !synthesized; }', 'registry, Collections.unmodifiableMap(properties), isDeclared);'], 'a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java', 'b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java']
['Closure-166', 1, 1, 1, 1, ['// properties on this object. if (constraint.isRecordType()) { matchRecordTypeConstraint(constraint.toObjectType()); } }'], ['// properties on this object. if (constraint.isRecordType()) { matchRecordTypeConstraint(constraint.toObjectType()); } else if (constraint.isUnionType()) { for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { if (alt.isRecordType()) { matchRecordTypeConstraint(alt.toObjectType()); } } } }'], [''], ['} else if (constraint.isUnionType()) { for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { if (alt.isRecordType()) { matchRecordTypeConstraint(alt.toObjectType()); } }'], 'a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java', 'b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java']
['Closure-167', 6, 6, 6, 6, ['if (merged != null) { return maybeRestrictTwoNames( blindScope, left, leftIsRefineable, merged.typeA, right, rightIsRefineable, merged.typeB); } return blindScope; }', '// creating new scope return maybeRestrictTwoNames( blindScope, left, leftIsRefineable, restrictedLeftType, right, rightIsRefineable, restrictedRightType); } return blindScope; }', '*/ private FlowScope maybeRestrictName( FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) { if (restrictedType != null && !restrictedType.equals(originalType)) { FlowScope informed = blindScope.createChildFlowScope(); declareNameInScope(informed, node, restrictedType); return informed;', '*/ private FlowScope maybeRestrictTwoNames( FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) { boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null; boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null; if (shouldRefineLeft || shouldRefineRight) { FlowScope informed = blindScope.createChildFlowScope(); if (shouldRefineLeft) {', 'boolean outcome) { JSType type = getTypeIfRefinable(name, blindScope); if (type != null) { JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome); FlowScope informed = blindScope.createChildFlowScope(); declareNameInScope(informed, name, restrictedType); return informed; } return blindScope; }', '* method of types to get the restricted type. */ public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) {'], ['if (merged != null) { return maybeRestrictTwoNames( blindScope, left, leftType, leftIsRefineable ? merged.typeA : null, right, rightType, rightIsRefineable ? merged.typeB : null); } return blindScope; }', '// creating new scope return maybeRestrictTwoNames( blindScope, left, leftType, leftIsRefineable ? restrictedLeftType : null, right, rightType, rightIsRefineable ? restrictedRightType : null); } return blindScope; }', '*/ private FlowScope maybeRestrictName( FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) { if (restrictedType != null && restrictedType != originalType) { FlowScope informed = blindScope.createChildFlowScope(); declareNameInScope(informed, node, restrictedType); return informed;', '*/ private FlowScope maybeRestrictTwoNames( FlowScope blindScope, Node left, JSType originalLeftType, JSType restrictedLeftType, Node right, JSType originalRightType, JSType restrictedRightType) { boolean shouldRefineLeft = restrictedLeftType != null && restrictedLeftType != originalLeftType; boolean shouldRefineRight = restrictedRightType != null && restrictedRightType != originalRightType; if (shouldRefineLeft || shouldRefineRight) { FlowScope informed = blindScope.createChildFlowScope(); if (shouldRefineLeft) {', 'boolean outcome) { JSType type = getTypeIfRefinable(name, blindScope); if (type != null) { return maybeRestrictName( blindScope, name, type, type.getRestrictedTypeGivenToBooleanOutcome(outcome)); } return blindScope; }', '* method of types to get the restricted type. */ public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) { if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); } BooleanLiteralSet literals = getPossibleToBooleanOutcomes(); if (literals.contains(outcome)) {'], ['left, leftIsRefineable, merged.typeA, right, rightIsRefineable, merged.typeB);', 'left, leftIsRefineable, restrictedLeftType, right, rightIsRefineable, restrictedRightType);', 'if (restrictedType != null && !restrictedType.equals(originalType)) {', 'Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) { leftIsRefineable && restrictedLeftType != null; rightIsRefineable && restrictedRightType != null;', 'JSType restrictedType = type.getRestrictedTypeGivenToBooleanOutcome(outcome); FlowScope informed = blindScope.createChildFlowScope(); declareNameInScope(informed, name, restrictedType); return informed;', ''], ['left, leftType, leftIsRefineable ? merged.typeA : null, right, rightType, rightIsRefineable ? merged.typeB : null);', 'left, leftType, leftIsRefineable ? restrictedLeftType : null, right, rightType, rightIsRefineable ? restrictedRightType : null);', 'if (restrictedType != null && restrictedType != originalType) {', 'Node left, JSType originalLeftType, JSType restrictedLeftType, Node right, JSType originalRightType, JSType restrictedRightType) { restrictedLeftType != null && restrictedLeftType != originalLeftType; restrictedRightType != null && restrictedRightType != originalRightType;', 'return maybeRestrictName( blindScope, name, type, type.getRestrictedTypeGivenToBooleanOutcome(outcome));', 'if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) { return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE); }'], 'a/src/com/google/javascript/rhino/jstype/JSType.java', 'b/src/com/google/javascript/rhino/jstype/JSType.java']
['Closure-168', 1, 1, 1, 1, ['data.get(t.getScopeRoot()).recordNonEmptyReturn(); } if (t.getScopeDepth() <= 2) { // The first-order function analyzer looks at two types of variables: // // 1) Local variables that are assigned in inner scopes ("escaped vars")'], ['data.get(t.getScopeRoot()).recordNonEmptyReturn(); } if (t.getScopeDepth() <= 1) { // The first-order function analyzer looks at two types of variables: // // 1) Local variables that are assigned in inner scopes ("escaped vars")'], ['if (t.getScopeDepth() <= 2) {'], ['if (t.getScopeDepth() <= 1) {'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-169', 21, 22, 22, 22, ["* @return True if our parameter spec is equal to {@code that}'s parameter * spec. */ boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) { Node thisParam = parameters.getFirstChild(); Node otherParam = that.parameters.getFirstChild(); while (thisParam != null && otherParam != null) {", '// Both parameter lists give a type for this param, it should be equal if (otherParamType != null && !thisParamType.checkEquivalenceHelper( otherParamType, tolerateUnknowns)) { return false; } } else {', '} boolean checkArrowEquivalenceHelper( ArrowType that, boolean tolerateUnknowns) { // Please keep this method in sync with the hashCode() method below. if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) { return false; } return hasEqualParameters(that, tolerateUnknowns); } @Override eleted file mode 100644', "private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call, false)) { newParamsNode = call.parameters; } else { // If the parameters are not equal, don't try to merge them.", '* have signatures, two interfaces are equal if their names match. */ boolean checkFunctionEquivalenceHelper( FunctionType that, boolean tolerateUnknowns) { if (isConstructor()) { if (that.isConstructor()) { return this == that;', '} return typeOfThis.checkEquivalenceHelper( that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns); } @Override', '} public boolean hasEqualCallType(FunctionType otherType) { return this.call.checkArrowEquivalenceHelper(otherType.call, false); } /**', '* Checks if two types are equivalent. */ public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, false); } /**', '* @see EquivalenceMethod */ public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, false); } /**', '* unknowns</a> */ public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, true); } /** * An equivalence visitor. */ boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) { if (this == that) { return true; }', "boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (tolerateUnknowns) { // If we're checking for invariance, the unknown type is invariant // with everyone. // If we're checking data flow, then two types are the same if they're // both unknown. return thisUnknown && thatUnknown;", ' if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), tolerateUnknowns); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), tolerateUnknowns); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), tolerateUnknowns); } ParameterizedType thisParamType = toMaybeParameterizedType();', 'boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { // If one of the type parameters is unknown, but the other is not, // then we consider these the same for the purposes of data flow // and invariance. paramsMatch = true; } else { paramsMatch = false; } JSType thisRootType = thisParamType == null ?', 'JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns); } if (isNominalType() && that.isNominalType()) {', 'if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, tolerateUnknowns); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns); } // Relies on the fact that for the base {@link JSType}, only one', '} boolean checkRecordEquivalenceHelper( RecordType otherRecord, boolean tolerateUnknowns) { Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) {', '} for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( properties.get(key), tolerateUnknowns)) { return false; } }', 'JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } }', " JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (!propA.isUnknownType() && !propB.isUnknownType()) { if (typeA.isPropertyTypeDeclared(property)) { // If one declared property isn't invariant, // then the whole record isn't covariant.", "// then the whole record isn't covariant. if (!propA.isSubtype(propB)) { return false; } } } }", '* and all alternates are equal. */ boolean checkUnionEquivalenceHelper( UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns && alternates.size() != that.alternates.size()) { return false; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, tolerateUnknowns)) { return false; } } return true; } private boolean hasAlternate(JSType type, boolean tolerateUnknowns) { for (JSType alternate : alternates) { if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) { return true; } }'], ["* @return True if our parameter spec is equal to {@code that}'s parameter * spec. */ boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) { Node thisParam = parameters.getFirstChild(); Node otherParam = that.parameters.getFirstChild(); while (thisParam != null && otherParam != null) {", '// Both parameter lists give a type for this param, it should be equal if (otherParamType != null && !thisParamType.checkEquivalenceHelper( otherParamType, eqMethod)) { return false; } } else {', '} boolean checkArrowEquivalenceHelper( ArrowType that, EquivalenceMethod eqMethod) { // Please keep this method in sync with the hashCode() method below. if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) { return false; } return hasEqualParameters(that, eqMethod); } @Override eleted file mode 100644', '/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * Google Inc. * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; /** * Represents different ways for comparing equality among types. * @author nicksantos@google.com (Nick Santos) */ enum EquivalenceMethod { /** * Indicates that the two types should behave exactly the same under * all type operations. * * Thus, {string} != {?} and {Unresolved} != {?} */ IDENTITY, /** * Indicates that the two types are almost exactly the same, and that a * data flow analysis algorithm comparing them should consider them equal. * * In traditional type inference, the types form a finite lattice, and this * ensures that type inference will terminate. * * In our type system, the unknown types do not obey the lattice rules. So * if we continue to perform inference over the unknown types, we may * never terminate. * * By treating all unknown types as equivalent for the purposes of data * flow analysis, we ensure that the algorithm will terminate. * * Thus, {string} != {?} and {Unresolved} ~= {?} */ DATA_FLOW, /** * Indicates that two types are invariant. * * In a type system without unknown types, this would be the same * as IDENTITY. But we always want to consider type A invariant with type B * if B is unknown. * * Thus, {string} ~= {?} and {Unresolved} ~= {?} */ INVARIANT }', "private FunctionType tryMergeFunctionPiecewise( FunctionType other, boolean leastSuper) { Node newParamsNode = null; if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) { newParamsNode = call.parameters; } else { // If the parameters are not equal, don't try to merge them.", '* have signatures, two interfaces are equal if their names match. */ boolean checkFunctionEquivalenceHelper( FunctionType that, EquivalenceMethod eqMethod) { if (isConstructor()) { if (that.isConstructor()) { return this == that;', '} return typeOfThis.checkEquivalenceHelper( that.typeOfThis, eqMethod) && call.checkArrowEquivalenceHelper(that.call, eqMethod); } @Override', '} public boolean hasEqualCallType(FunctionType otherType) { return this.call.checkArrowEquivalenceHelper( otherType.call, EquivalenceMethod.IDENTITY); } /**', '* Checks if two types are equivalent. */ public final boolean isEquivalentTo(JSType that) { return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY); } /**', '* @see EquivalenceMethod */ public final boolean isInvariant(JSType that) { return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT); } /**', '* unknowns</a> */ public final boolean differsFrom(JSType that) { return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW); } /** * An equivalence visitor. */ boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) { if (this == that) { return true; }', "boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (eqMethod == EquivalenceMethod.INVARIANT) { // If we're checking for invariance, the unknown type is invariant // with everyone. return true; } else if (eqMethod == EquivalenceMethod.DATA_FLOW) { // If we're checking data flow, then two types are the same if they're // both unknown. return thisUnknown && thatUnknown;", ' if (isUnionType() && that.isUnionType()) { return this.toMaybeUnionType().checkUnionEquivalenceHelper( that.toMaybeUnionType(), eqMethod); } if (isFunctionType() && that.isFunctionType()) { return this.toMaybeFunctionType().checkFunctionEquivalenceHelper( that.toMaybeFunctionType(), eqMethod); } if (isRecordType() && that.isRecordType()) { return this.toMaybeRecordType().checkRecordEquivalenceHelper( that.toMaybeRecordType(), eqMethod); } ParameterizedType thisParamType = toMaybeParameterizedType();', 'boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper( thatParamType.getParameterType(), eqMethod); } else if (eqMethod == EquivalenceMethod.IDENTITY) { paramsMatch = false; } else { // If one of the type parameters is unknown, but the other is not, // then we consider these the same for the purposes of data flow // and invariance. paramsMatch = true; } JSType thisRootType = thisParamType == null ?', 'JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, eqMethod); } if (isNominalType() && that.isNominalType()) {', 'if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this) .getReferencedTypeInternal().checkEquivalenceHelper( that, eqMethod); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper( ((ProxyObjectType) that).getReferencedTypeInternal(), eqMethod); } // Relies on the fact that for the base {@link JSType}, only one', '} boolean checkRecordEquivalenceHelper( RecordType otherRecord, EquivalenceMethod eqMethod) { Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) {', '} for (String key : keySet) { if (!otherProps.get(key).checkEquivalenceHelper( properties.get(key), eqMethod)) { return false; } }', 'JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && propType.isInvariant(altPropType)) { builder.addAlternate(alt); } }', " JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (typeA.isPropertyTypeDeclared(property)) { // If one declared property isn't invariant, // then the whole record isn't covariant.", "// then the whole record isn't covariant. if (!propA.isSubtype(propB)) { return false; } } }", '* and all alternates are equal. */ boolean checkUnionEquivalenceHelper( UnionType that, EquivalenceMethod eqMethod) { if (eqMethod == EquivalenceMethod.IDENTITY && alternates.size() != that.alternates.size()) { return false; } for (JSType alternate : that.alternates) { if (!hasAlternate(alternate, eqMethod)) { return false; } } return true; } private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) { for (JSType alternate : alternates) { if (alternate.checkEquivalenceHelper(type, eqMethod)) { return true; } }'], ['boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {', 'otherParamType, tolerateUnknowns)) {', 'ArrowType that, boolean tolerateUnknowns) { if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) { return hasEqualParameters(that, tolerateUnknowns);', '', 'if (call.hasEqualParameters(other.call, false)) {', 'FunctionType that, boolean tolerateUnknowns) {', 'that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);', 'return this.call.checkArrowEquivalenceHelper(otherType.call, false);', 'return checkEquivalenceHelper(that, false);', 'return checkEquivalenceHelper(that, false);', 'return !checkEquivalenceHelper(that, true); boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {', 'if (tolerateUnknowns) {', 'that.toMaybeUnionType(), tolerateUnknowns); that.toMaybeFunctionType(), tolerateUnknowns); that.toMaybeRecordType(), tolerateUnknowns);', 'thatParamType.getParameterType(), tolerateUnknowns); } else if (tolerateUnknowns) { } else { paramsMatch = false;', 'thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);', 'that, tolerateUnknowns); tolerateUnknowns);', 'RecordType otherRecord, boolean tolerateUnknowns) {', 'properties.get(key), tolerateUnknowns)) {', '(propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {', 'if (!propA.isUnknownType() && !propB.isUnknownType()) {', '}', 'UnionType that, boolean tolerateUnknowns) { if (!tolerateUnknowns if (!hasAlternate(alternate, tolerateUnknowns)) { private boolean hasAlternate(JSType type, boolean tolerateUnknowns) { if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {'], ['boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {', 'otherParamType, eqMethod)) {', 'ArrowType that, EquivalenceMethod eqMethod) { if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) { return hasEqualParameters(that, eqMethod);', '/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * Google Inc. * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; /** * Represents different ways for comparing equality among types. * @author nicksantos@google.com (Nick Santos) */ enum EquivalenceMethod { /** * Indicates that the two types should behave exactly the same under * all type operations. * * Thus, {string} != {?} and {Unresolved} != {?} */ IDENTITY, /** * Indicates that the two types are almost exactly the same, and that a * data flow analysis algorithm comparing them should consider them equal. * * In traditional type inference, the types form a finite lattice, and this * ensures that type inference will terminate. * * In our type system, the unknown types do not obey the lattice rules. So * if we continue to perform inference over the unknown types, we may * never terminate. * * By treating all unknown types as equivalent for the purposes of data * flow analysis, we ensure that the algorithm will terminate. * * Thus, {string} != {?} and {Unresolved} ~= {?} */ DATA_FLOW, /** * Indicates that two types are invariant. * * In a type system without unknown types, this would be the same * as IDENTITY. But we always want to consider type A invariant with type B * if B is unknown. * * Thus, {string} ~= {?} and {Unresolved} ~= {?} */ INVARIANT }', 'if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) {', 'FunctionType that, EquivalenceMethod eqMethod) {', 'that.typeOfThis, eqMethod) && call.checkArrowEquivalenceHelper(that.call, eqMethod);', 'return this.call.checkArrowEquivalenceHelper( otherType.call, EquivalenceMethod.IDENTITY);', 'return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);', 'return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT);', 'return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW); boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {', 'if (eqMethod == EquivalenceMethod.INVARIANT) { return true; } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {', 'that.toMaybeUnionType(), eqMethod); that.toMaybeFunctionType(), eqMethod); that.toMaybeRecordType(), eqMethod);', 'thatParamType.getParameterType(), eqMethod); } else if (eqMethod == EquivalenceMethod.IDENTITY) { paramsMatch = false; } else {', 'thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);', 'that, eqMethod); eqMethod);', 'RecordType otherRecord, EquivalenceMethod eqMethod) {', 'properties.get(key), eqMethod)) {', 'propType.isInvariant(altPropType)) {', '', '', 'UnionType that, EquivalenceMethod eqMethod) { if (eqMethod == EquivalenceMethod.IDENTITY if (!hasAlternate(alternate, eqMethod)) { private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) { if (alternate.checkEquivalenceHelper(type, eqMethod)) {'], 'a/src/com/google/javascript/rhino/jstype/UnionType.java', 'b/src/com/google/javascript/rhino/jstype/UnionType.java']
['Closure-170', 1, 1, 1, 1, [" @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && n.getString().equals(varName) && // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. !(parent.isAssign() && (parent.getFirstChild() == n))) { // Don't count lhs of top-level assignment chain numUsesWithinCfgNode++; } } }; NodeTraversal.traverse(compiler, cfgNode, gatherCb);"], [" @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && n.getString().equals(varName)) { // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) { // Don't count lhs of top-level assignment chain return; } else { numUsesWithinCfgNode++; } } } private boolean isAssignChain(Node child, Node ancestor) { for (Node n = child; n != ancestor; n = n.getParent()) { if (!n.isAssign()) { return false; } } return true; } }; NodeTraversal.traverse(compiler, cfgNode, gatherCb);"], ['if (n.isName() && n.getString().equals(varName) && !(parent.isAssign() && (parent.getFirstChild() == n))) {'], ['if (n.isName() && n.getString().equals(varName)) { if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) { return; } else { } private boolean isAssignChain(Node child, Node ancestor) { for (Node n = child; n != ancestor; n = n.getParent()) { if (!n.isAssign()) { return false; } } return true; }'], 'a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java', 'b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java']
['Closure-171', 2, 2, 2, 2, ['// See CodingConvention#getObjectLiteralCase and goog.object.reflect. // Ignore these types of literals. ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; }', '} // Prototype sets are always declared. boolean inferred = true; if (info != null) {'], ['// See CodingConvention#getObjectLiteralCase and goog.object.reflect. // Ignore these types of literals. ObjectType objectType = ObjectType.cast(type); if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) { return scope; }', '} // Prototype sets are always declared. if (qName != null && qName.endsWith(".prototype")) { return false; } boolean inferred = true; if (info != null) {'], ['if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) {', ''], ['if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) {', 'if (qName != null && qName.endsWith(".prototype")) { return false; }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-172', 1, 1, 1, 1, [' // Prototypes of constructors and interfaces are always declared. if (qName != null && qName.endsWith(".prototype")) { return false; } boolean inferred = true;'], [' // Prototypes of constructors and interfaces are always declared. if (qName != null && qName.endsWith(".prototype")) { String className = qName.substring(0, qName.lastIndexOf(".prototype")); Var slot = scope.getSlot(className); JSType classType = slot == null ? null : slot.getType(); if (classType != null && (classType.isConstructor() || classType.isInterface())) { return false; } } boolean inferred = true;'], [''], ['String className = qName.substring(0, qName.lastIndexOf(".prototype")); Var slot = scope.getSlot(className); JSType classType = slot == null ? null : slot.getType(); if (classType != null && (classType.isConstructor() || classType.isInterface())) { }'], 'a/src/com/google/javascript/jscomp/TypedScopeCreator.java', 'b/src/com/google/javascript/jscomp/TypedScopeCreator.java']
['Closure-173', 2, 2, 2, 2, ['// the IN_FOR_INIT_CLAUSE one. Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { // Assignments are the only right-associative binary operators addExpr(first, p, context); cc.addOp(opstr, true);', 'case Token.ARRAYLIT: return tryMinimizeArrayLiteral(node); default: return node; //Nothing changed } } private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall());'], ['// the IN_FOR_INIT_CLAUSE one. Context rhsContext = getContextForNoInOperator(context); if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { // Assignments are the only right-associative binary operators addExpr(first, p, context); cc.addOp(opstr, true);', 'case Token.ARRAYLIT: return tryMinimizeArrayLiteral(node); case Token.MUL: case Token.AND: case Token.OR: case Token.BITOR: case Token.BITXOR: case Token.BITAND: return tryRotateAssociativeOperator(node); default: return node; //Nothing changed } } private Node tryRotateAssociativeOperator(Node n) { if (!late) { return n; } Preconditions.checkArgument(NodeUtil.isAssociative(n.getType())); Node rhs = n.getLastChild(); if (n.getType() == rhs.getType()) { Node parent = n.getParent(); Node first = n.getFirstChild().detachFromParent(); Node second = rhs.getFirstChild().detachFromParent(); Node third = rhs.getLastChild().detachFromParent(); Node newLhs = new Node(n.getType(), first, second) .copyInformationFrom(n); Node newRoot = new Node(rhs.getType(), newLhs, third) .copyInformationFrom(rhs); parent.replaceChild(n, newRoot); reportCodeChange(); return newRoot; } return n; } private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall());'], ['if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {', ''], ['if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {', 'case Token.MUL: case Token.AND: case Token.OR: case Token.BITOR: case Token.BITXOR: case Token.BITAND: return tryRotateAssociativeOperator(node); private Node tryRotateAssociativeOperator(Node n) { if (!late) { return n; } Preconditions.checkArgument(NodeUtil.isAssociative(n.getType())); Node rhs = n.getLastChild(); if (n.getType() == rhs.getType()) { Node parent = n.getParent(); Node first = n.getFirstChild().detachFromParent(); Node second = rhs.getFirstChild().detachFromParent(); Node third = rhs.getLastChild().detachFromParent(); Node newLhs = new Node(n.getType(), first, second) .copyInformationFrom(n); Node newRoot = new Node(rhs.getType(), newLhs, third) .copyInformationFrom(rhs); parent.replaceChild(n, newRoot); reportCodeChange(); return newRoot; } return n; }'], 'a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java', 'b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java']
['Closure-174', 7, 7, 7, 7, ['} private void parse(AbstractCompiler compiler) { try { ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(),', '} if (root == null || compiler.hasHaltingErrors()) { // Most passes try to report as many errors as possible, // so there may already be errors. We only care if there were // errors in the code we just parsed. // There was a parse error or IOException, so use a dummy block. root = IR.script(); } else {', 'if (nameNode.isName()) { result = IR.var(nameNode, value); result.setJSDocInfo(info); } else { result = IR.exprResult(IR.assign(nameNode, value)); result.getFirstChild().setJSDocInfo(info); } return result;', 'for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVarAssign = parent.isVar() && n.hasChildren(); if (isVarAssign && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just', '} else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else if (isVarAssign) { Node value = v.getInitialValue().detachFromParent(); String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name);', ' // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info. Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName,', 'NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); parent.getParent().addChildBefore(newDecl, parent); // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;" v.getNameNode().addChildToFront('], ['} private void parse(AbstractCompiler compiler) { int startErrorCount = compiler.getErrorManager().getErrorCount(); try { ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(),', '} if (root == null || // Most passes try to report as many errors as possible, // so there may already be errors. We only care if there were // errors in the code we just parsed. (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) { // There was a parse error or IOException, so use a dummy block. root = IR.script(); } else {', 'if (nameNode.isName()) { result = IR.var(nameNode, value); result.setJSDocInfo(info); } else if (value != null) { result = IR.exprResult(IR.assign(nameNode, value)); result.getFirstChild().setJSDocInfo(info); } else { result = IR.exprResult(nameNode); result.getFirstChild().setJSDocInfo(info); } return result;', 'for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just', '} else if (parent.getType() == Token.LP) { // Parameters of the scope function also get a BAD_PARAMETERS // error. } else if (isVar) { Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name);', ' // Add $jscomp.scope.name = EXPR; // Make sure we copy over all the jsdoc and debug info. if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration( compiler.getCodingConvention(), globalName,', 'NodeUtil.setDebugInformation( newDecl.getFirstChild().getFirstChild(), n, name); parent.getParent().addChildBefore(newDecl, parent); } // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;" v.getNameNode().addChildToFront('], ['', 'if (root == null || compiler.hasHaltingErrors()) {', 'result = IR.exprResult(IR.assign(nameNode, value));', 'boolean isVarAssign = parent.isVar() && n.hasChildren(); if (isVarAssign && n.getFirstChild().isQualifiedName()) {', '} else if (isVarAssign) { Node value = v.getInitialValue().detachFromParent();', '', ''], ['int startErrorCount = compiler.getErrorManager().getErrorCount();', 'if (root == null || (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) {', '} else if (value != null) { result = IR.exprResult(IR.assign(nameNode, value)); result.getFirstChild().setJSDocInfo(info); result = IR.exprResult(nameNode);', 'boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {', '} else if (isVar) { Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;', 'if (value != null || v.getJSDocInfo() != null) {', '}'], 'a/src/com/google/javascript/jscomp/ScopedAliases.java', 'b/src/com/google/javascript/jscomp/ScopedAliases.java']
['Closure-175', 4, 4, 4, 4, ['private final boolean assumeStrictThis; private final boolean assumeMinimumCapture; private final Supplier<String> safeNameIdSupplier; /** * @param allowDecomposition Whether an effort should be made to break down', '} if (mode == InliningMode.DIRECT) { return canInlineReferenceDirectly(callNode, fnNode); } else { return canInlineReferenceAsStatementBlock( t, callNode, fnNode, needAliases);', '* </pre> */ private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '} } Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) { if (fnParam != null) { if (cArg != null) { if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } fnParam = fnParam.getNext(); } // Limit the inlining if (cArg != null) { if (NodeUtil.mayHaveSideEffects(cArg, compiler)) { return CanInlineResult.NO; } cArg = cArg.getNext(); } }'], ['private final boolean assumeStrictThis; private final boolean assumeMinimumCapture; private final Supplier<String> safeNameIdSupplier; private final Supplier<String> throwawayNameSupplier = new Supplier<String>() { private int nextId = 0; @Override public String get() { return String.valueOf(nextId++); } }; /** * @param allowDecomposition Whether an effort should be made to break down', '} if (mode == InliningMode.DIRECT) { return canInlineReferenceDirectly(callNode, fnNode, needAliases); } else { return canInlineReferenceAsStatementBlock( t, callNode, fnNode, needAliases);', '* </pre> */ private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode, Set<String> namesToAlias) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext();', '} } Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap( fnNode, callNode, this.throwawayNameSupplier); boolean hasArgs = !args.isEmpty(); if (hasArgs) { // Limit the inlining Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias); FunctionArgumentInjector.maybeAddTempsForCallArguments( fnNode, args, allNamesToAlias, compiler.getCodingConvention()); if (!allNamesToAlias.isEmpty()) { return CanInlineResult.NO; } }'], ['', 'return canInlineReferenceDirectly(callNode, fnNode);', 'Node callNode, Node fnNode) { Node block = fnNode.getLastChild();', 'Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) { if (fnParam != null) { if (cArg != null) { if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } fnParam = fnParam.getNext(); } if (cArg != null) { if (NodeUtil.mayHaveSideEffects(cArg, compiler)) { } cArg = cArg.getNext();'], ['private final Supplier<String> throwawayNameSupplier = new Supplier<String>() { private int nextId = 0; @Override public String get() { return String.valueOf(nextId++); } };', 'return canInlineReferenceDirectly(callNode, fnNode, needAliases);', 'Node callNode, Node fnNode, Set<String> namesToAlias) {', 'Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap( fnNode, callNode, this.throwawayNameSupplier); boolean hasArgs = !args.isEmpty(); if (hasArgs) { Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias); FunctionArgumentInjector.maybeAddTempsForCallArguments( fnNode, args, allNamesToAlias, compiler.getCodingConvention()); if (!allNamesToAlias.isEmpty()) {'], 'a/src/com/google/javascript/jscomp/FunctionInjector.java', 'b/src/com/google/javascript/jscomp/FunctionInjector.java']
['Closure-176', 3, 3, 3, 3, ["case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); // When looking at VAR initializers for declared VARs, we tend // to use the declared type over the type it's being", '// sure we back-infer the <string> element constraint on // the left hand side, so we use the left hand side. boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred(); // Makes it easier to check for NPEs. // TODO(nicksantos): This might be a better check once we have // back-inference of object/array constraints. It will probably', ' if (isVarTypeBetter) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType();'], ["case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); JSType varType = var == null ? null : var.getType(); boolean isVarDeclaration = left.hasChildren() && varType != null && !var.isTypeInferred(); // When looking at VAR initializers for declared VARs, we tend // to use the declared type over the type it's being", '// sure we back-infer the <string> element constraint on // the left hand side, so we use the left hand side. boolean isVarTypeBetter = isVarDeclaration && // Makes it easier to check for NPEs. !resultType.isNullType() && !resultType.isVoidType(); // TODO(nicksantos): This might be a better check once we have // back-inference of object/array constraints. It will probably', ' if (isVarTypeBetter) { redeclareSimpleVar(scope, left, varType); } else { redeclareSimpleVar(scope, left, resultType); } left.setJSType(resultType); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType();'], ['boolean isVarDeclaration = left.hasChildren();', 'boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();', 'left.setJSType(isVarDeclaration || leftType == null ? resultType : null);'], ['JSType varType = var == null ? null : var.getType(); boolean isVarDeclaration = left.hasChildren() && varType != null && !var.isTypeInferred();', 'boolean isVarTypeBetter = isVarDeclaration && !resultType.isNullType() && !resultType.isVoidType();', 'redeclareSimpleVar(scope, left, varType); } else { left.setJSType(resultType);'], 'a/src/com/google/javascript/jscomp/TypeInference.java', 'b/src/com/google/javascript/jscomp/TypeInference.java']
['JxPath-1', 2, 2, 2, 2, ['int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;', 'else if (test instanceof NodeTypeTest) { switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return node instanceof Element; case Compiler.NODE_TYPE_TEXT : return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT :'], ['int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;', 'else if (test instanceof NodeTypeTest) { switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return (node instanceof Element) || (node instanceof Document); case Compiler.NODE_TYPE_TEXT : return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT :'], ['return nodeType == Node.ELEMENT_NODE;', 'return node instanceof Element;'], ['return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;', 'return (node instanceof Element) || (node instanceof Document);'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java']
['JxPath-2', 4, 4, 4, 4, ['*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.model.NodePointer;', 'if (result instanceof EvalContext) { return new ValueIterator((EvalContext) result); } return ValueUtils.iterate(result); }', 'if (result instanceof EvalContext) { return (EvalContext) result; } return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale());', 'throw new UnsupportedOperationException(); } } No newline at end of file }'], ['*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.NodeSet; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.model.NodePointer;', 'if (result instanceof EvalContext) { return new ValueIterator((EvalContext) result); } if (result instanceof NodeSet) { return new ValueIterator(((NodeSet) result).getPointers().iterator()); } return ValueUtils.iterate(result); }', 'if (result instanceof EvalContext) { return (EvalContext) result; } if (result instanceof NodeSet) { return new PointerIterator(((NodeSet) result).getPointers().iterator(), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); } return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale());', 'throw new UnsupportedOperationException(); } } } No newline at end of file'], ['', '', '', '}'], ['import org.apache.commons.jxpath.NodeSet;', 'if (result instanceof NodeSet) { return new ValueIterator(((NodeSet) result).getPointers().iterator()); }', 'if (result instanceof NodeSet) { return new PointerIterator(((NodeSet) result).getPointers().iterator(), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); }', '}'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java']
['JxPath-3', 4, 4, 4, 4, ['*/ package org.apache.commons.jxpath.ri.model.beans; import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathInvalidAccessException; import org.apache.commons.jxpath.ri.QName;', 'return newParent.createAttribute(context, getName()); } else { // Consider these two use cases: // 1. The parent pointer of NullPropertyPointer is // a PropertyOwnerPointer other than NullPointer. When we call', 'return pointer; } else { if (newParent instanceof PropertyOwnerPointer) { PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; newParent = pop.getPropertyPointer();', '} return string; } No newline at end of file }'], ['*/ package org.apache.commons.jxpath.ri.model.beans; import org.apache.commons.jxpath.AbstractFactory; import org.apache.commons.jxpath.JXPathAbstractFactoryException; import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathInvalidAccessException; import org.apache.commons.jxpath.ri.QName;', 'return newParent.createAttribute(context, getName()); } else { if (parent instanceof NullPointer && parent.equals(newParent)) { throw createBadFactoryException(context.getFactory()); } // Consider these two use cases: // 1. The parent pointer of NullPropertyPointer is // a PropertyOwnerPointer other than NullPointer. When we call', 'return pointer; } else { if (parent instanceof NullPointer && parent.equals(newParent)) { throw createBadFactoryException(context.getFactory()); } if (newParent instanceof PropertyOwnerPointer) { PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; newParent = pop.getPropertyPointer();', '} return string; } private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) { return new JXPathAbstractFactoryException("Factory " + factory + " reported success creating object for path: " + asPath() + " but object was null. Terminating to avoid stack recursion."); } } No newline at end of file'], ['', '', '', '}'], ['import org.apache.commons.jxpath.AbstractFactory; import org.apache.commons.jxpath.JXPathAbstractFactoryException;', 'if (parent instanceof NullPointer && parent.equals(newParent)) { throw createBadFactoryException(context.getFactory()); }', 'if (parent instanceof NullPointer && parent.equals(newParent)) { throw createBadFactoryException(context.getFactory()); }', ' private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) { return new JXPathAbstractFactoryException("Factory " + factory + " reported success creating object for path: " + asPath() + " but object was null. Terminating to avoid stack recursion."); } }'], 'a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java']
['JxPath-4', 7, 7, 7, 7, [': current.toUpperCase().startsWith(lang.toUpperCase()); } protected String getLanguage() { Node n = node; while (n != null) { if (n.getNodeType() == Node.ELEMENT_NODE) { Element e = (Element) n; String attr = e.getAttribute("xml:lang"); if (attr != null && !attr.equals("")) { return attr; }', 'return null; } /** * Sets contents of the node to the specified value. If the value is', '} public Object getValue() { return stringValue(node); } private String stringValue(Node node) { int nodeType = node.getNodeType(); if (nodeType == Node.COMMENT_NODE) { String text = ((Comment) node).getData(); return text == null ? "" : text.trim(); } if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { String text = node.getNodeValue(); return text == null ? "" : text.trim(); } if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { String text = ((ProcessingInstruction) node).getData(); return text == null ? "" : text.trim(); } NodeList list = node.getChildNodes(); StringBuffer buf = new StringBuffer(16); for (int i = 0; i < list.getLength(); i++) { Node child = list.item(i); if (child.getNodeType() == Node.TEXT_NODE) { buf.append(child.getNodeValue()); } else { buf.append(stringValue(child)); } } return buf.toString().trim(); } /**', ' public Object getValue() { if (node instanceof Element) { return ((Element) node).getTextTrim(); } if (node instanceof Comment) { String text = ((Comment) node).getText();', '} return text; } if (node instanceof Text) { return ((Text) node).getTextTrim(); } if (node instanceof CDATA) { return ((CDATA) node).getTextTrim(); } if (node instanceof ProcessingInstruction) { String text = ((ProcessingInstruction) node).getData(); if (text != null) { text = text.trim(); } return text; } return null; } public void setValue(Object value) {', '} protected String getLanguage() { Object n = node; while (n != null) { if (n instanceof Element) { Element e = (Element) n; String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE); if (attr != null && !attr.equals("")) { return attr; }', 'return factory; } No newline at end of file }'], [': current.toUpperCase().startsWith(lang.toUpperCase()); } protected static String findEnclosingAttribute(Node n, String attrName) { while (n != null) { if (n.getNodeType() == Node.ELEMENT_NODE) { Element e = (Element) n; String attr = e.getAttribute(attrName); if (attr != null && !attr.equals("")) { return attr; }', 'return null; } protected String getLanguage() { return findEnclosingAttribute(node, "xml:lang"); } /** * Sets contents of the node to the specified value. If the value is', '} public Object getValue() { if (node.getNodeType() == Node.COMMENT_NODE) { String text = ((Comment) node).getData(); return text == null ? "" : text.trim(); } return stringValue(node); } private String stringValue(Node node) { int nodeType = node.getNodeType(); if (nodeType == Node.COMMENT_NODE) { return ""; } boolean trim = !"preserve".equals(findEnclosingAttribute(node, "xml:space")); if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { String text = node.getNodeValue(); return text == null ? "" : trim ? text.trim() : text; } if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { String text = ((ProcessingInstruction) node).getData(); return text == null ? "" : trim ? text.trim() : text; } NodeList list = node.getChildNodes(); StringBuffer buf = new StringBuffer(16); for (int i = 0; i < list.getLength(); i++) { Node child = list.item(i); buf.append(stringValue(child)); } return buf.toString(); } /**', ' public Object getValue() { if (node instanceof Element) { StringBuffer buf = new StringBuffer(); for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) { NodePointer ptr = children.getNodePointer(); if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) { buf.append(ptr.getValue()); } } return buf.toString(); } if (node instanceof Comment) { String text = ((Comment) node).getText();', '} return text; } String result = null; if (node instanceof Text) { result = ((Text) node).getText(); } if (node instanceof ProcessingInstruction) { result = ((ProcessingInstruction) node).getData(); } boolean trim = !"preserve".equals(findEnclosingAttribute(node, "space", Namespace.XML_NAMESPACE)); return result != null && trim ? result.trim() : result; } public void setValue(Object value) {', '} protected String getLanguage() { return findEnclosingAttribute(node, "lang", Namespace.XML_NAMESPACE); } protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) { while (n != null) { if (n instanceof Element) { Element e = (Element) n; String attr = e.getAttributeValue(attrName, ns); if (attr != null && !attr.equals("")) { return attr; }', 'return factory; } } No newline at end of file'], ['protected String getLanguage() { Node n = node; String attr = e.getAttribute("xml:lang");', '', 'String text = ((Comment) node).getData(); return text == null ? "" : text.trim(); return text == null ? "" : text.trim(); return text == null ? "" : text.trim(); if (child.getNodeType() == Node.TEXT_NODE) { buf.append(child.getNodeValue()); } else { } return buf.toString().trim();', 'return ((Element) node).getTextTrim();', 'return ((Text) node).getTextTrim(); } if (node instanceof CDATA) { return ((CDATA) node).getTextTrim(); String text = ((ProcessingInstruction) node).getData(); if (text != null) { text = text.trim(); } return text; return null;', 'Object n = node; String attr = e.getAttributeValue("lang", Namespace.XML_NAMESPACE);', '}'], ['protected static String findEnclosingAttribute(Node n, String attrName) { String attr = e.getAttribute(attrName);', 'protected String getLanguage() { return findEnclosingAttribute(node, "xml:lang"); }', 'if (node.getNodeType() == Node.COMMENT_NODE) { String text = ((Comment) node).getData(); return text == null ? "" : text.trim(); } return ""; boolean trim = !"preserve".equals(findEnclosingAttribute(node, "xml:space")); return text == null ? "" : trim ? text.trim() : text; return text == null ? "" : trim ? text.trim() : text; return buf.toString();', 'StringBuffer buf = new StringBuffer(); for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) { NodePointer ptr = children.getNodePointer(); if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) { buf.append(ptr.getValue()); } } return buf.toString();', 'String result = null; result = ((Text) node).getText(); result = ((ProcessingInstruction) node).getData(); boolean trim = !"preserve".equals(findEnclosingAttribute(node, "space", Namespace.XML_NAMESPACE)); return result != null && trim ? result.trim() : result;', 'return findEnclosingAttribute(node, "lang", Namespace.XML_NAMESPACE); } protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) { String attr = e.getAttributeValue(attrName, ns);', '}'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java']
['JxPath-5', 1, 1, 1, 1, ['} if (depth1 == 1) { throw new JXPathException( "Cannot compare pointers that do not belong to the same tree: \'" + p1 + "\' and \'" + p2 + "\'"); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r != 0) {'], ['} if (depth1 == 1) { return 0; } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r != 0) {'], ['throw new JXPathException( "Cannot compare pointers that do not belong to the same tree: \'" + p1 + "\' and \'" + p2 + "\'");'], ['return 0;'], 'a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java']
['JxPath-6', 1, 1, 1, 1, ['// (l == null ? "null" : l.getClass().getName()) + " " + // (r == null ? "null" : r.getClass().getName())); if (l instanceof InitialContext || l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || r instanceof SelfContext) { r = ((EvalContext) r).getSingleNodePointer(); }'], ['// (l == null ? "null" : l.getClass().getName()) + " " + // (r == null ? "null" : r.getClass().getName())); if (l instanceof InitialContext) { ((EvalContext) l).reset(); } if (l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) { ((EvalContext) r).reset(); } if (r instanceof SelfContext) { r = ((EvalContext) r).getSingleNodePointer(); }'], ['if (l instanceof InitialContext || l instanceof SelfContext) { if (r instanceof InitialContext || r instanceof SelfContext) {'], ['if (l instanceof InitialContext) { ((EvalContext) l).reset(); } if (l instanceof SelfContext) { if (r instanceof InitialContext) { ((EvalContext) r).reset(); } if (r instanceof SelfContext) {'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java']
['JxPath-7', 11, 11, 11, 11, ['*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; /** * Implementation of Expression for the operation "&gt;". *', 'super(new Expression[] { arg1, arg2 }); } public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l > r ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; /** * Implementation of Expression for the operation "&gt;=". *', 'super(new Expression[] { arg1, arg2 }); } public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l >= r ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; /** * Implementation of Expression for the operation "&lt;". *', 'super(new Expression[] { arg1, arg2 }); } public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l < r ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; /** * Implementation of Expression for the operation "&lt;=". *', 'super(new Expression[] { arg1, arg2 }); } public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l <= r ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Base implementation of Expression for the operations "&gt;", "&gt;=", "&lt;", "&lt;=". *', 'super(args); } protected final int getPrecedence() { return 3; }', 'return false; } }'], ['*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "&gt;". *', 'super(new Expression[] { arg1, arg2 }); } protected boolean evaluateCompare(int compare) { return compare > 0; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "&gt;=". *', 'super(new Expression[] { arg1, arg2 }); } protected boolean evaluateCompare(int compare) { return compare >= 0; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "&lt;". *', 'super(new Expression[] { arg1, arg2 }); } protected boolean evaluateCompare(int compare) { return compare < 0; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "&lt;=". *', 'super(new Expression[] { arg1, arg2 }); } protected boolean evaluateCompare(int compare) { return compare <= 0; } public String getSymbol() {', '*/ package org.apache.commons.jxpath.ri.compiler; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; import org.apache.commons.jxpath.ri.axes.InitialContext; import org.apache.commons.jxpath.ri.axes.SelfContext; /** * Base implementation of Expression for the operations "&gt;", "&gt;=", "&lt;", "&lt;=". *', 'super(args); } public final Object computeValue(EvalContext context) { return compute(args[0].computeValue(context), args[1] .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; } protected final int getPrecedence() { return 3; }', 'return false; } protected abstract boolean evaluateCompare(int compare); private boolean compute(Object left, Object right) { left = reduce(left); right = reduce(right); if (left instanceof InitialContext) { ((InitialContext) left).reset(); } if (right instanceof InitialContext) { ((InitialContext) right).reset(); } if (left instanceof Iterator && right instanceof Iterator) { return findMatch((Iterator) left, (Iterator) right); } if (left instanceof Iterator) { return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch((Iterator) right, left); } return evaluateCompare(compare(left, right)); } private Object reduce(Object o) { if (o instanceof SelfContext) { o = ((EvalContext) o).getSingleNodePointer(); } if (o instanceof Collection) { o = ((Collection) o).iterator(); } return o; } private boolean containsMatch(Iterator it, Object value) { while (it.hasNext()) { Object element = it.next(); if (evaluateCompare(compare(element, value))) { return true; } } return false; } private boolean findMatch(Iterator lit, Iterator rit) { HashSet left = new HashSet(); while (lit.hasNext()) { left.add(lit.next()); } while (rit.hasNext()) { if (containsMatch(left.iterator(), rit.next())) { return true; } } return false; } private int compare(Object l, Object r) { double ld = InfoSetUtil.doubleValue(l); double rd = InfoSetUtil.doubleValue(r); return ld == rd ? 0 : ld < rd ? -1 : 1; } }'], ['import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil;', 'public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l > r ? Boolean.TRUE : Boolean.FALSE;', 'import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil;', 'public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l >= r ? Boolean.TRUE : Boolean.FALSE;', 'import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil;', 'public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l < r ? Boolean.TRUE : Boolean.FALSE;', 'import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil;', 'public Object computeValue(EvalContext context) { double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); return l <= r ? Boolean.TRUE : Boolean.FALSE;', '', '', ''], ['', 'protected boolean evaluateCompare(int compare) { return compare > 0;', '', 'protected boolean evaluateCompare(int compare) { return compare >= 0;', '', 'protected boolean evaluateCompare(int compare) { return compare < 0;', '', 'protected boolean evaluateCompare(int compare) { return compare <= 0;', 'import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.InfoSetUtil; import org.apache.commons.jxpath.ri.axes.InitialContext; import org.apache.commons.jxpath.ri.axes.SelfContext;', 'public final Object computeValue(EvalContext context) { return compute(args[0].computeValue(context), args[1] .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; }', 'protected abstract boolean evaluateCompare(int compare); private boolean compute(Object left, Object right) { left = reduce(left); right = reduce(right); if (left instanceof InitialContext) { ((InitialContext) left).reset(); } if (right instanceof InitialContext) { ((InitialContext) right).reset(); } if (left instanceof Iterator && right instanceof Iterator) { return findMatch((Iterator) left, (Iterator) right); } if (left instanceof Iterator) { return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch((Iterator) right, left); } return evaluateCompare(compare(left, right)); } private Object reduce(Object o) { if (o instanceof SelfContext) { o = ((EvalContext) o).getSingleNodePointer(); } if (o instanceof Collection) { o = ((Collection) o).iterator(); } return o; } private boolean containsMatch(Iterator it, Object value) { while (it.hasNext()) { Object element = it.next(); if (evaluateCompare(compare(element, value))) { return true; } } return false; } private boolean findMatch(Iterator lit, Iterator rit) { HashSet left = new HashSet(); while (lit.hasNext()) { left.add(lit.next()); } while (rit.hasNext()) { if (containsMatch(left.iterator(), rit.next())) { return true; } } return false; } private int compare(Object l, Object r) { double ld = InfoSetUtil.doubleValue(l); double rd = InfoSetUtil.doubleValue(r); return ld == rd ? 0 : ld < rd ? -1 : 1; }'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java']
['JxPath-8', 1, 1, 1, 1, ['return containsMatch((Iterator) right, left); } double ld = InfoSetUtil.doubleValue(left); double rd = InfoSetUtil.doubleValue(right); return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1); }'], ['return containsMatch((Iterator) right, left); } double ld = InfoSetUtil.doubleValue(left); if (Double.isNaN(ld)) { return false; } double rd = InfoSetUtil.doubleValue(right); if (Double.isNaN(rd)) { return false; } return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1); }'], [''], ['if (Double.isNaN(ld)) { return false; } if (Double.isNaN(rd)) { return false; }'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java']
['JxPath-9', 7, 7, 7, 7, ['* @version $Revision$ $Date$ */ public abstract class CoreOperationCompare extends CoreOperation { public CoreOperationCompare(Expression arg1, Expression arg2) { super(new Expression[] { arg1, arg2 }); } protected int getPrecedence() {', '} protected boolean equal(Object l, Object r) { if (l instanceof Pointer && r instanceof Pointer) { if (l.equals(r)) { return true; } } if (l instanceof Pointer) { l = ((Pointer) l).getValue(); }', 'r = ((Pointer) r).getValue(); } if (l == r) { return true; } if (l instanceof Boolean || r instanceof Boolean) { return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); } //if either side is NaN, no comparison returns true: if (l instanceof Number || r instanceof Number) { return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); } if (l instanceof String || r instanceof String) { return ( InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); } return l != null && l.equals(r); } }', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; /** * Implementation of Expression for the operation "=". *', 'super(arg1, arg2); } public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE; } public String getSymbol() { return "="; }', '*/ package org.apache.commons.jxpath.ri.compiler; import org.apache.commons.jxpath.ri.EvalContext; /** * Implementation of Expression for the operation "!=". *', 'public class CoreOperationNotEqual extends CoreOperationCompare { public CoreOperationNotEqual(Expression arg1, Expression arg2) { super(arg1, arg2); } public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE; } public String getSymbol() { return "!="; }'], ['* @version $Revision$ $Date$ */ public abstract class CoreOperationCompare extends CoreOperation { private boolean invert; public CoreOperationCompare(Expression arg1, Expression arg2) { this(arg1, arg2, false); } protected CoreOperationCompare(Expression arg1, Expression arg2, boolean invert) { super(new Expression[] { arg1, arg2 }); this.invert = invert; } public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE; } protected int getPrecedence() {', '} protected boolean equal(Object l, Object r) { if (l instanceof Pointer) { l = ((Pointer) l).getValue(); }', 'r = ((Pointer) r).getValue(); } boolean result; if (l instanceof Boolean || r instanceof Boolean) { result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r); } else if (l instanceof Number || r instanceof Number) { //if either side is NaN, no comparison returns true: double ld = InfoSetUtil.doubleValue(l); if (Double.isNaN(ld)) { return false; } double rd = InfoSetUtil.doubleValue(r); if (Double.isNaN(rd)) { return false; } result = ld == rd; } else { if (l instanceof String || r instanceof String) { l = InfoSetUtil.stringValue(l); r = InfoSetUtil.stringValue(r); } result = l == r || l != null && l.equals(r); } return result ^ invert; } }', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "=". *', 'super(arg1, arg2); } public String getSymbol() { return "="; }', '*/ package org.apache.commons.jxpath.ri.compiler; /** * Implementation of Expression for the operation "!=". *', 'public class CoreOperationNotEqual extends CoreOperationCompare { public CoreOperationNotEqual(Expression arg1, Expression arg2) { super(arg1, arg2, true); } public String getSymbol() { return "!="; }'], ['', 'if (l instanceof Pointer && r instanceof Pointer) { if (l.equals(r)) { return true; } }', 'if (l == r) { return true; } return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); //if either side is NaN, no comparison returns true: if (l instanceof Number || r instanceof Number) { return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); return ( InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); return l != null && l.equals(r);', 'import org.apache.commons.jxpath.ri.EvalContext;', 'public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE; }', 'import org.apache.commons.jxpath.ri.EvalContext;', 'super(arg1, arg2); public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE; }'], ['private boolean invert; this(arg1, arg2, false); } protected CoreOperationCompare(Expression arg1, Expression arg2, boolean invert) { this.invert = invert; } public Object computeValue(EvalContext context) { return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;', '', 'boolean result; result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r); } else if (l instanceof Number || r instanceof Number) { //if either side is NaN, no comparison returns true: double ld = InfoSetUtil.doubleValue(l); if (Double.isNaN(ld)) { return false; double rd = InfoSetUtil.doubleValue(r); if (Double.isNaN(rd)) { return false; result = ld == rd; } else { l = InfoSetUtil.stringValue(l); r = InfoSetUtil.stringValue(r); } result = l == r || l != null && l.equals(r); return result ^ invert;', '', '', '', 'super(arg1, arg2, true);'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java']
['JxPath-10', 1, 1, 1, 1, ['} public final Object computeValue(EvalContext context) { return compute(args[0].computeValue(context), args[1].computeValue(context)) ? Boolean.TRUE : Boolean.FALSE; }'], ['} public final Object computeValue(EvalContext context) { return compute(args[0].compute(context), args[1].compute(context)) ? Boolean.TRUE : Boolean.FALSE; }'], ['return compute(args[0].computeValue(context), args[1].computeValue(context))'], ['return compute(args[0].compute(context), args[1].compute(context))'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java']
['JxPath-11', 5, 5, 5, 5, ['import java.util.ArrayList; import java.util.List; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', 'String testNS = null; if (testPrefix != null) { testNS = parent.getNamespaceURI(testPrefix); } if (testNS != null) {', 'import java.util.Collections; import java.util.List; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', 'ns = Namespace.XML_NAMESPACE; } else { ns = element.getNamespace(prefix); if (ns == null) { // TBD: no attributes attributes = Collections.EMPTY_LIST; return; } } } else {', 'this.position = position; return position >= 1 && position <= attributes.size(); } No newline at end of file }'], ['import java.util.ArrayList; import java.util.List; import org.apache.commons.jxpath.ri.NamespaceResolver; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', 'String testNS = null; if (testPrefix != null) { NamespaceResolver nsr = parent.getNamespaceResolver(); testNS = nsr == null ? null : nsr.getNamespaceURI(testPrefix); testNS = testNS == null ? parent.getNamespaceURI(testPrefix) : testNS; } if (testNS != null) {', 'import java.util.Collections; import java.util.List; import org.apache.commons.jxpath.ri.NamespaceResolver; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', 'ns = Namespace.XML_NAMESPACE; } else { NamespaceResolver nsr = parent.getNamespaceResolver(); if (nsr != null) { String uri = nsr.getNamespaceURI(prefix); if (uri != null) { ns = Namespace.getNamespace(prefix, uri); } } if (ns == null) { ns = element.getNamespace(prefix); if (ns == null) { // TBD: no attributes attributes = Collections.EMPTY_LIST; return; } } } } else {', 'this.position = position; return position >= 1 && position <= attributes.size(); } } No newline at end of file'], ['', 'testNS = parent.getNamespaceURI(testPrefix);', '', '', '}'], ['import org.apache.commons.jxpath.ri.NamespaceResolver;', 'NamespaceResolver nsr = parent.getNamespaceResolver(); testNS = nsr == null ? null : nsr.getNamespaceURI(testPrefix); testNS = testNS == null ? parent.getNamespaceURI(testPrefix) : testNS;', 'import org.apache.commons.jxpath.ri.NamespaceResolver;', 'NamespaceResolver nsr = parent.getNamespaceResolver(); if (nsr != null) { String uri = nsr.getNamespaceURI(prefix); if (uri != null) { ns = Namespace.getNamespace(prefix, uri); } } if (ns == null) { }', '}'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java']
['JxPath-12', 1, 1, 1, 1, ['|| testName.getName() .equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS); } return false; }'], ['|| testName.getName() .equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); } return false; }'], ['return equalStrings(namespaceURI, nodeNS);'], ['return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));'], 'a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java']
['JxPath-13', 11, 11, 11, 11, ['* @return prefix if found * @since JXPath 1.3 */ /** * Create a new NamespaceResolver.', '* @return namespace URI or null if the prefix is undefined. */ public synchronized String getNamespaceURI(String prefix) { /** * Given a prefix, returns an externally registered namespace URI.', '* @return namespace URI or null if the prefix is undefined. * @since JXPath 1.3 */ String uri = (String) namespaceMap.get(prefix); if (uri == null && pointer != null) { uri = pointer.getNamespaceURI(prefix); } if (uri == null && parent != null) { return parent.getNamespaceURI(prefix); } return uri; } /**', '* @return String prefix */ public synchronized String getPrefix(String namespaceURI) { /** * Get the nearest prefix found that matches an externally-registered namespace.', '* @return String prefix if found. * @since JXPath 1.3 */ if (reverseMap == null) { reverseMap = new HashMap(); NodeIterator ni = pointer.namespaceIterator(); if (ni != null) { for (int position = 1; ni.setPosition(position); position++) { NodePointer nsPointer = ni.getNodePointer(); String uri = nsPointer.getNamespaceURI(); String prefix = nsPointer.getName().getName(); if (!"".equals(prefix)) { reverseMap.put(uri, prefix); } } } Iterator it = namespaceMap.entrySet().iterator(); while (it.hasNext()) { Map.Entry entry = (Map.Entry) it.next();', '} } String prefix = (String) reverseMap.get(namespaceURI); if (prefix == null && parent != null) { return parent.getPrefix(namespaceURI); } return prefix; } /**', '} } No newline at end of file }', 'import org.apache.commons.jxpath.JXPathException; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.Compiler; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.compiler.NodeNameTest; import org.apache.commons.jxpath.ri.compiler.NodeTest;', 'private Map namespaces; private String defaultNamespace; private String id; public static final String XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";', '/* (non-Javadoc) * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver() */ public String getNamespaceURI(String prefix) { if (prefix == null || prefix.equals("")) {', 'Element element = (Element) node; String prefix = name.getPrefix(); if (prefix != null) { String ns = getNamespaceURI(prefix); if (ns == null) { throw new JXPathException( "Unknown namespace prefix: " + prefix);'], ['* @return prefix if found * @since JXPath 1.3 */ protected static String getPrefix(NodePointer pointer, String namespaceURI) { NodePointer currentPointer = pointer; while (currentPointer != null) { NodeIterator ni = currentPointer.namespaceIterator(); for (int position = 1; ni != null && ni.setPosition(position); position++) { NodePointer nsPointer = ni.getNodePointer(); String uri = nsPointer.getNamespaceURI(); if (uri.equals(namespaceURI)) { String prefix = nsPointer.getName().getName(); if (!"".equals(prefix)) { return prefix; } } } currentPointer = pointer.getParent(); } return null; } /** * Create a new NamespaceResolver.', '* @return namespace URI or null if the prefix is undefined. */ public synchronized String getNamespaceURI(String prefix) { String uri = getExternallyRegisteredNamespaceURI(prefix); return uri == null && pointer != null ? pointer.getNamespaceURI(prefix) : uri; } /** * Given a prefix, returns an externally registered namespace URI.', '* @return namespace URI or null if the prefix is undefined. * @since JXPath 1.3 */ protected synchronized String getExternallyRegisteredNamespaceURI( String prefix) { String uri = (String) namespaceMap.get(prefix); return uri == null && parent != null ? parent .getExternallyRegisteredNamespaceURI(prefix) : uri; } /**', '* @return String prefix */ public synchronized String getPrefix(String namespaceURI) { String prefix = getExternallyRegisteredPrefix(namespaceURI); return prefix == null && pointer != null ? getPrefix(pointer, namespaceURI) : prefix; } /** * Get the nearest prefix found that matches an externally-registered namespace.', '* @return String prefix if found. * @since JXPath 1.3 */ protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) { if (reverseMap == null) { reverseMap = new HashMap(); Iterator it = namespaceMap.entrySet().iterator(); while (it.hasNext()) { Map.Entry entry = (Map.Entry) it.next();', '} } String prefix = (String) reverseMap.get(namespaceURI); return prefix == null && parent != null ? parent .getExternallyRegisteredPrefix(namespaceURI) : prefix; } /**', '} } } No newline at end of file', 'import org.apache.commons.jxpath.JXPathException; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.Compiler; import org.apache.commons.jxpath.ri.NamespaceResolver; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.compiler.NodeNameTest; import org.apache.commons.jxpath.ri.compiler.NodeTest;', 'private Map namespaces; private String defaultNamespace; private String id; private NamespaceResolver localNamespaceResolver; public static final String XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";', '/* (non-Javadoc) * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver() */ public synchronized NamespaceResolver getNamespaceResolver() { if (localNamespaceResolver == null) { localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver()); localNamespaceResolver.setNamespaceContextPointer(this); } return localNamespaceResolver; } public String getNamespaceURI(String prefix) { if (prefix == null || prefix.equals("")) {', 'Element element = (Element) node; String prefix = name.getPrefix(); if (prefix != null) { String ns = null; NamespaceResolver nsr = getNamespaceResolver(); if (nsr != null) { ns = nsr.getNamespaceURI(prefix); } if (ns == null) { throw new JXPathException( "Unknown namespace prefix: " + prefix);'], ['', '', 'if (uri == null && pointer != null) { uri = pointer.getNamespaceURI(prefix); } if (uri == null && parent != null) { return parent.getNamespaceURI(prefix); } return uri;', '', 'NodeIterator ni = pointer.namespaceIterator(); if (ni != null) { for (int position = 1; ni.setPosition(position); position++) { NodePointer nsPointer = ni.getNodePointer(); String uri = nsPointer.getNamespaceURI(); String prefix = nsPointer.getName().getName(); if (!"".equals(prefix)) { reverseMap.put(uri, prefix); } } }', 'if (prefix == null && parent != null) { return parent.getPrefix(namespaceURI); } return prefix;', '}', '', '', '', 'String ns = getNamespaceURI(prefix);'], ['protected static String getPrefix(NodePointer pointer, String namespaceURI) { NodePointer currentPointer = pointer; while (currentPointer != null) { NodeIterator ni = currentPointer.namespaceIterator(); for (int position = 1; ni != null && ni.setPosition(position); position++) { NodePointer nsPointer = ni.getNodePointer(); String uri = nsPointer.getNamespaceURI(); if (uri.equals(namespaceURI)) { String prefix = nsPointer.getName().getName(); if (!"".equals(prefix)) { return prefix; } } } currentPointer = pointer.getParent(); } return null; }', 'String uri = getExternallyRegisteredNamespaceURI(prefix); return uri == null && pointer != null ? pointer.getNamespaceURI(prefix) : uri; }', 'protected synchronized String getExternallyRegisteredNamespaceURI( String prefix) { return uri == null && parent != null ? parent .getExternallyRegisteredNamespaceURI(prefix) : uri;', 'String prefix = getExternallyRegisteredPrefix(namespaceURI); return prefix == null && pointer != null ? getPrefix(pointer, namespaceURI) : prefix; }', 'protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) {', 'return prefix == null && parent != null ? parent .getExternallyRegisteredPrefix(namespaceURI) : prefix;', '}', 'import org.apache.commons.jxpath.ri.NamespaceResolver;', 'private NamespaceResolver localNamespaceResolver;', 'public synchronized NamespaceResolver getNamespaceResolver() { if (localNamespaceResolver == null) { localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver()); localNamespaceResolver.setNamespaceContextPointer(this); } return localNamespaceResolver; }', 'String ns = null; NamespaceResolver nsr = getNamespaceResolver(); if (nsr != null) { ns = nsr.getNamespaceURI(prefix); }'], 'a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java']
['JxPath-14', 1, 1, 1, 1, ['protected Object functionFloor(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); return new Double(Math.floor(v)); } protected Object functionCeiling(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); return new Double(Math.ceil(v)); } protected Object functionRound(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); return new Double(Math.round(v)); }'], ['protected Object functionFloor(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.floor(v)); } protected Object functionCeiling(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.ceil(v)); } protected Object functionRound(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.round(v)); }'], [''], ['if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); }'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java']
['JxPath-15', 2, 2, 2, 2, ['package org.apache.commons.jxpath.ri.axes; import java.util.ArrayList; import org.apache.commons.jxpath.BasicNodeSet; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.model.NodePointer;', 'while (ctx.nextNode()) { NodePointer ptr = ctx.getCurrentNodePointer(); if (!pointers.contains(ptr)) { nodeSet.add(ptr); pointers.add(ptr); } } } } } return super.setPosition(position); } No newline at end of file }'], ['package org.apache.commons.jxpath.ri.axes; import java.util.ArrayList; import java.util.Iterator; import org.apache.commons.jxpath.BasicNodeSet; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.model.NodePointer;', 'while (ctx.nextNode()) { NodePointer ptr = ctx.getCurrentNodePointer(); if (!pointers.contains(ptr)) { pointers.add(ptr); } } } } sortPointers(pointers); for (Iterator it = pointers.iterator(); it.hasNext();) { nodeSet.add((Pointer) it.next()); } } return super.setPosition(position); } } No newline at end of file'], ['', 'nodeSet.add(ptr); }'], ['import java.util.Iterator; import org.apache.commons.jxpath.Pointer;', 'sortPointers(pointers); for (Iterator it = pointers.iterator(); it.hasNext();) { nodeSet.add((Pointer) it.next()); } }'], 'a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java', 'b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java']
['JxPath-16', 2, 2, 2, 2, ['int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;', 'if (test instanceof NodeTypeTest) { switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return (node instanceof Element) || (node instanceof Document); case Compiler.NODE_TYPE_TEXT : return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT :'], ['int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return true; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;', 'if (test instanceof NodeTypeTest) { switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return true; case Compiler.NODE_TYPE_TEXT : return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT :'], ['return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;', 'return (node instanceof Element) || (node instanceof Document);'], ['return true;', 'return true;'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java']
['JxPath-17', 5, 5, 5, 5, ['if (testLocalName.equals("*") || testLocalName.equals(nodeLocalName)) { String testPrefix = name.getPrefix(); if (equalStrings(testPrefix, nodePrefix)) { return true; } String testNS = null; if (testPrefix != null) { testNS = parent.getNamespaceURI(testPrefix); } String nodeNS = null; if (nodePrefix != null) { nodeNS = parent.getNamespaceURI(nodePrefix); } return equalStrings(testNS, nodeNS); } return false; }', 'this.position = position; return position >= 1 && position <= attributes.size(); } No newline at end of file }', 'String lname = name.getName(); if (!lname.equals("*")) { attributes = new ArrayList(); if (ns != null) { Attribute attr = element.getAttribute(lname, ns); if (attr != null) { attributes.add(attr); } } } else {', 'List allAttributes = element.getAttributes(); for (int i = 0; i < allAttributes.size(); i++) { Attribute attr = (Attribute) allAttributes.get(i); if (attr.getNamespace().equals(ns)) { attributes.add(attr); } }', 'this.position = position; return position >= 1 && position <= attributes.size(); } No newline at end of file }'], ['if (testLocalName.equals("*") || testLocalName.equals(nodeLocalName)) { String testPrefix = name.getPrefix(); if (testPrefix == null || equalStrings(testPrefix, nodePrefix)) { return true; } if (nodePrefix == null) { return false; } return equalStrings(parent.getNamespaceURI(testPrefix), parent .getNamespaceURI(nodePrefix)); } return false; }', 'this.position = position; return position >= 1 && position <= attributes.size(); } } No newline at end of file', 'String lname = name.getName(); if (!lname.equals("*")) { attributes = new ArrayList(); Attribute attr = element.getAttribute(lname, ns); if (attr != null) { attributes.add(attr); } } else {', 'List allAttributes = element.getAttributes(); for (int i = 0; i < allAttributes.size(); i++) { Attribute attr = (Attribute) allAttributes.get(i); if (ns == Namespace.NO_NAMESPACE || attr.getNamespace().equals(ns)) { attributes.add(attr); } }', 'this.position = position; return position >= 1 && position <= attributes.size(); } } No newline at end of file'], ['if (equalStrings(testPrefix, nodePrefix)) { String testNS = null; if (testPrefix != null) { testNS = parent.getNamespaceURI(testPrefix); String nodeNS = null; if (nodePrefix != null) { nodeNS = parent.getNamespaceURI(nodePrefix); } return equalStrings(testNS, nodeNS);', '}', 'if (ns != null) { }', 'if (attr.getNamespace().equals(ns)) {', '}'], ['if (testPrefix == null || equalStrings(testPrefix, nodePrefix)) { if (nodePrefix == null) { return false; return equalStrings(parent.getNamespaceURI(testPrefix), parent .getNamespaceURI(nodePrefix));', '}', '', 'if (ns == Namespace.NO_NAMESPACE || attr.getNamespace().equals(ns)) {', '}'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java']
['JxPath-18', 4, 4, 4, 4, ['*/ package org.apache.commons.jxpath.ri.axes; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.compiler.NodeNameTest; import org.apache.commons.jxpath.ri.compiler.NodeTest; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', '* @version $Revision$ $Date$ */ public class AttributeContext extends EvalContext { private NodeTest nodeTest; private boolean setStarted = false;', 'super.setPosition(getCurrentPosition() + 1); if (!setStarted) { setStarted = true; if (!(nodeTest instanceof NodeNameTest)) { return false; } QName name = ((NodeNameTest) nodeTest).getNodeName(); iterator = parentContext.getCurrentNodePointer().attributeIterator(name); } if (iterator == null) { return false;', 'currentNodePointer = iterator.getNodePointer(); return true; } No newline at end of file }'], ['*/ package org.apache.commons.jxpath.ri.axes; import org.apache.commons.jxpath.ri.Compiler; import org.apache.commons.jxpath.ri.EvalContext; import org.apache.commons.jxpath.ri.QName; import org.apache.commons.jxpath.ri.compiler.NodeNameTest; import org.apache.commons.jxpath.ri.compiler.NodeTest; import org.apache.commons.jxpath.ri.compiler.NodeTypeTest; import org.apache.commons.jxpath.ri.model.NodeIterator; import org.apache.commons.jxpath.ri.model.NodePointer;', '* @version $Revision$ $Date$ */ public class AttributeContext extends EvalContext { private static final NodeNameTest WILDCARD_TEST = new NodeNameTest(new QName(null, "*")); private NodeTest nodeTest; private boolean setStarted = false;', 'super.setPosition(getCurrentPosition() + 1); if (!setStarted) { setStarted = true; NodeNameTest nodeNameTest = null; if (nodeTest instanceof NodeTypeTest) { if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { nodeNameTest = WILDCARD_TEST; } } else if (nodeTest instanceof NodeNameTest) { nodeNameTest = (NodeNameTest) nodeTest; } if (nodeNameTest == null) { return false; } iterator = parentContext.getCurrentNodePointer().attributeIterator( nodeNameTest.getNodeName()); } if (iterator == null) { return false;', 'currentNodePointer = iterator.getNodePointer(); return true; } } No newline at end of file'], ['', '', 'if (!(nodeTest instanceof NodeNameTest)) { QName name = ((NodeNameTest) nodeTest).getNodeName(); iterator = parentContext.getCurrentNodePointer().attributeIterator(name);', '}'], ['import org.apache.commons.jxpath.ri.Compiler; import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;', 'private static final NodeNameTest WILDCARD_TEST = new NodeNameTest(new QName(null, "*"));', 'NodeNameTest nodeNameTest = null; if (nodeTest instanceof NodeTypeTest) { if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { nodeNameTest = WILDCARD_TEST; } } else if (nodeTest instanceof NodeNameTest) { nodeNameTest = (NodeNameTest) nodeTest; } if (nodeNameTest == null) { iterator = parentContext.getCurrentNodePointer().attributeIterator( nodeNameTest.getNodeName());', '}'], 'a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java', 'b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java']
['JxPath-19', 3, 3, 3, 3, ['int count = 1; Node n = node.getPreviousSibling(); while (n != null) { if (n.getNodeType() == Node.ELEMENT_NODE) { String nm = n.getNodeName(); if (nm.equals(node.getNodeName())) { count++; } } n = n.getPreviousSibling(); } return count; } /** * Get relative position of this among all siblings.', 'String name = ((Element) node).getQualifiedName(); for (int i = 0; i < children.size(); i++) { Object child = children.get(i); if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) { count++; } if (child == node) {', 'return 1; } /** * Get relative position of this among all siblings.'], ['int count = 1; Node n = node.getPreviousSibling(); while (n != null) { if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) { count++; } n = n.getPreviousSibling(); } return count; } private boolean matchesQName(Node n) { if (getNamespaceURI() != null) { return equalStrings(getNamespaceURI(n), getNamespaceURI()) && equalStrings(node.getLocalName(), n.getLocalName()); } return equalStrings(node.getNodeName(), n.getNodeName()); } /** * Get relative position of this among all siblings.', 'String name = ((Element) node).getQualifiedName(); for (int i = 0; i < children.size(); i++) { Object child = children.get(i); if (child instanceof Element && matchesQName(((Element) child))) { count++; } if (child == node) {', 'return 1; } private boolean matchesQName(Element element) { if (getNamespaceURI() != null) { String ns = getNamespaceURI(element); if (ns == null || !ns.equals(getNamespaceURI())) { return false; } } return element.getName().equals(((Element) node).getName()); } /** * Get relative position of this among all siblings.'], ['if (n.getNodeType() == Node.ELEMENT_NODE) { String nm = n.getNodeName(); if (nm.equals(node.getNodeName())) { }', 'if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) {', ''], ['if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) { private boolean matchesQName(Node n) { if (getNamespaceURI() != null) { return equalStrings(getNamespaceURI(n), getNamespaceURI()) && equalStrings(node.getLocalName(), n.getLocalName()); } return equalStrings(node.getNodeName(), n.getNodeName()); }', 'if (child instanceof Element && matchesQName(((Element) child))) {', 'private boolean matchesQName(Element element) { if (getNamespaceURI() != null) { String ns = getNamespaceURI(element); if (ns == null || !ns.equals(getNamespaceURI())) { return false; } } return element.getName().equals(((Element) node).getName()); }'], 'a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java']
['JxPath-20', 2, 2, 2, 2, ['return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch((Iterator) right, left); } double ld = InfoSetUtil.doubleValue(left); if (Double.isNaN(ld)) {', '* @param value to look for * @return whether a match was found */ /** * Learn whether there is an intersection between two Iterators.'], ['return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch(left, (Iterator) right); } double ld = InfoSetUtil.doubleValue(left); if (Double.isNaN(ld)) {', '* @param value to look for * @return whether a match was found */ private boolean containsMatch(Object value, Iterator it) { while (it.hasNext()) { Object element = it.next(); if (compute(value, element)) { return true; } } return false; } /** * Learn whether there is an intersection between two Iterators.'], ['return containsMatch((Iterator) right, left);', ''], ['return containsMatch(left, (Iterator) right);', 'private boolean containsMatch(Object value, Iterator it) { while (it.hasNext()) { Object element = it.next(); if (compute(value, element)) { return true; } } return false; }'], 'a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java', 'b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java']
['JxPath-21', 1, 1, 1, 1, ['* @return int length */ public int getLength() { return ValueUtils.getLength(getBaseValue()); } /**'], ['* @return int length */ public int getLength() { Object baseValue = getBaseValue(); return baseValue == null ? 1 : ValueUtils.getLength(baseValue); } /**'], ['return ValueUtils.getLength(getBaseValue());'], ['Object baseValue = getBaseValue(); return baseValue == null ? 1 : ValueUtils.getLength(baseValue);'], 'a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java']
['JxPath-22', 1, 1, 1, 1, ['if (aNode.getNodeType() == Node.ELEMENT_NODE) { Attr attr = ((Element) aNode).getAttributeNode(qname); if (attr != null) { return attr.getValue(); } } aNode = aNode.getParentNode(); } return null; } return uri; } public Object getValue() {'], ['if (aNode.getNodeType() == Node.ELEMENT_NODE) { Attr attr = ((Element) aNode).getAttributeNode(qname); if (attr != null) { uri = attr.getValue(); break; } } aNode = aNode.getParentNode(); } } return "".equals(uri) ? null : uri; } public Object getValue() {'], ['return attr.getValue(); return null; return uri;'], ['uri = attr.getValue(); break; return "".equals(uri) ? null : uri;'], 'a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java', 'b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java']
['Time-1', 2, 2, 2, 2, ['DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " +', '* @return zero always */ public int compareTo(DurationField durationField) { if (durationField.isSupported()) { return 1; } return 0; }'], ['DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { if (loopUnitField.isSupported() == false) { if (lastUnitField.isSupported()) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else { throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); } } int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " +', '* @return zero always */ public int compareTo(DurationField durationField) { return 0; }'], ['} else if (compare == 0) {', 'if (durationField.isSupported()) { return 1; }'], ['if (loopUnitField.isSupported() == false) { if (lastUnitField.isSupported()) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else { throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); } } } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {', ''], 'a/src/main/java/org/joda/time/field/UnsupportedDurationField.java', 'b/src/main/java/org/joda/time/field/UnsupportedDurationField.java']
['Time-2', 3, 3, 3, 3, ['DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) {', 'if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) {', '* @return zero always */ public int compareTo(DurationField durationField) { return 0; }'], ['DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) {', 'if (compare > 0) { break; } else if (compare == 0) { if (fieldType.getRangeDurationType() == null) { break; } DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) {', '* @return zero always */ public int compareTo(DurationField durationField) { if (durationField.isSupported()) { return 1; } return 0; }'], ['if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {', '', ''], ['if (compare < 0) {', 'if (fieldType.getRangeDurationType() == null) { break; }', 'if (durationField.isSupported()) { return 1; }'], 'a/src/main/java/org/joda/time/field/UnsupportedDurationField.java', 'b/src/main/java/org/joda/time/field/UnsupportedDurationField.java']
['Time-3', 10, 10, 10, 10, ['if (type == null) { throw new IllegalArgumentException("Field must not be null"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } //-----------------------------------------------------------------------'], ['if (type == null) { throw new IllegalArgumentException("Field must not be null"); } if (amount != 0) { setMillis(type.getField(getChronology()).add(getMillis(), amount)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addYears(final int years) { if (years != 0) { setMillis(getChronology().years().add(getMillis(), years)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addWeekyears(final int weekyears) { if (weekyears != 0) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMonths(final int months) { if (months != 0) { setMillis(getChronology().months().add(getMillis(), months)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addWeeks(final int weeks) { if (weeks != 0) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addDays(final int days) { if (days != 0) { setMillis(getChronology().days().add(getMillis(), days)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addHours(final int hours) { if (hours != 0) { setMillis(getChronology().hours().add(getMillis(), hours)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMinutes(final int minutes) { if (minutes != 0) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addSeconds(final int seconds) { if (seconds != 0) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } } //-----------------------------------------------------------------------', '* @throws IllegalArgumentException if the value is invalid */ public void addMillis(final int millis) { if (millis != 0) { setMillis(getChronology().millis().add(getMillis(), millis)); } } //-----------------------------------------------------------------------'], ['', '', '', '', '', '', '', '', '', ''], ['if (amount != 0) { }', 'if (years != 0) { }', 'if (weekyears != 0) { }', 'if (months != 0) { }', 'if (weeks != 0) { }', 'if (days != 0) { }', 'if (hours != 0) { }', 'if (minutes != 0) { }', 'if (seconds != 0) { }', 'if (millis != 0) { }'], 'a/src/main/java/org/joda/time/MutableDateTime.java', 'b/src/main/java/org/joda/time/MutableDateTime.java']
['Time-4', 1, 1, 1, 1, ["System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation // this isn't overly efficient, but is safe Partial newPartial = new Partial(iChronology, newTypes, newValues); iChronology.validate(newPartial, newValues); return newPartial; }"], ["System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); // use public constructor to ensure full validation // this isn't overly efficient, but is safe Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; }"], ['Partial newPartial = new Partial(iChronology, newTypes, newValues);'], ['Partial newPartial = new Partial(newTypes, newValues, iChronology);'], 'a/src/main/java/org/joda/time/Partial.java', 'b/src/main/java/org/joda/time/Partial.java']
['Time-5', 1, 1, 1, 1, ['int years = getYears(); int months = getMonths(); if (years != 0 || months != 0) { years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); } if (months != 0) { result = result.withMonths(months); } } return result;'], ['int years = getYears(); int months = getMonths(); if (years != 0 || months != 0) { long totalMonths = years * 12L + months; if (type.isSupported(DurationFieldType.YEARS_TYPE)) { int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); result = result.withYears(normalizedYears); totalMonths = totalMonths - (normalizedYears * 12); } if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { int normalizedMonths = FieldUtils.safeToInt(totalMonths); result = result.withMonths(normalizedMonths); totalMonths = totalMonths - normalizedMonths; } if (totalMonths != 0) { throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString()); } } return result;'], ['years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); if (months != 0) { result = result.withMonths(months);'], ['long totalMonths = years * 12L + months; if (type.isSupported(DurationFieldType.YEARS_TYPE)) { int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); result = result.withYears(normalizedYears); totalMonths = totalMonths - (normalizedYears * 12); if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { int normalizedMonths = FieldUtils.safeToInt(totalMonths); result = result.withMonths(normalizedMonths); totalMonths = totalMonths - normalizedMonths; } if (totalMonths != 0) { throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString());'], 'a/src/main/java/org/joda/time/Period.java', 'b/src/main/java/org/joda/time/Period.java']
['Time-6', 3, 3, 3, 3, ['cutoverInstant = DEFAULT_CUTOVER; } else { cutoverInstant = gregorianCutover.toInstant(); } GJChronology chrono;', 'if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { instant = gregorianToJulian(instant); } }', 'if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { instant = gregorianToJulian(instant); } }'], ['cutoverInstant = DEFAULT_CUTOVER; } else { cutoverInstant = gregorianCutover.toInstant(); LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); if (cutoverDate.getYear() <= 0) { throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); } } GJChronology chrono;', 'if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { if (iConvertByWeekyear) { int wyear = iGregorianChronology.weekyear().get(instant); if (wyear <= 0) { instant = iGregorianChronology.weekyear().add(instant, -1); } } else { int year = iGregorianChronology.year().get(instant); if (year <= 0) { instant = iGregorianChronology.year().add(instant, -1); } } instant = gregorianToJulian(instant); } }', 'if (instant < iCutover) { // Only adjust if gap fully crossed. if (instant + iGapDuration < iCutover) { if (iConvertByWeekyear) { int wyear = iGregorianChronology.weekyear().get(instant); if (wyear <= 0) { instant = iGregorianChronology.weekyear().add(instant, -1); } } else { int year = iGregorianChronology.year().get(instant); if (year <= 0) { instant = iGregorianChronology.year().add(instant, -1); } } instant = gregorianToJulian(instant); } }'], ['', '', ''], ['LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); if (cutoverDate.getYear() <= 0) { throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); }', 'if (iConvertByWeekyear) { int wyear = iGregorianChronology.weekyear().get(instant); if (wyear <= 0) { instant = iGregorianChronology.weekyear().add(instant, -1); } } else { int year = iGregorianChronology.year().get(instant); if (year <= 0) { instant = iGregorianChronology.year().add(instant, -1); } }', 'if (iConvertByWeekyear) { int wyear = iGregorianChronology.weekyear().get(instant); if (wyear <= 0) { instant = iGregorianChronology.weekyear().add(instant, -1); } } else { int year = iGregorianChronology.year().get(instant); if (year <= 0) { instant = iGregorianChronology.year().add(instant, -1); } }'], 'a/src/main/java/org/joda/time/chrono/GJChronology.java', 'b/src/main/java/org/joda/time/chrono/GJChronology.java']
['Time-7', 1, 1, 1, 1, [' long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear);'], [' long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear);'], ['int defaultYear = chrono.year().get(instantLocal);'], ['int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);'], 'a/src/main/java/org/joda/time/format/DateTimeFormatter.java', 'b/src/main/java/org/joda/time/format/DateTimeFormatter.java']
['Time-8', 1, 1, 1, 1, ['if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; }'], ['if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < -59 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } if (hoursOffset > 0 && minutesOffset < 0) { throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - Math.abs(minutesOffset); } else { minutesOffset = hoursInMinutes + minutesOffset; }'], ['if (minutesOffset < 0 || minutesOffset > 59) { minutesOffset = hoursInMinutes - minutesOffset;'], ['if (minutesOffset < -59 || minutesOffset > 59) { if (hoursOffset > 0 && minutesOffset < 0) { throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); } minutesOffset = hoursInMinutes - Math.abs(minutesOffset);'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-9', 3, 3, 3, 3, ['/** The time zone for Universal Coordinated Time */ public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0); /** Maximum offset. */ /** The instance that is providing time zones. */ private static Provider cProvider;', 'if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) {', '* @return the DateTimeZone object for the offset */ public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); }'], ['/** The time zone for Universal Coordinated Time */ public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0); /** Maximum offset. */ private static final int MAX_MILLIS = (86400 * 1000) - 1; /** The instance that is providing time zones. */ private static Provider cProvider;', 'if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) {', '* @return the DateTimeZone object for the offset */ public static DateTimeZone forOffsetMillis(int millisOffset) { if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { throw new IllegalArgumentException("Millis out of range: " + millisOffset); } String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); }'], ['', 'int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);', ''], ['private static final int MAX_MILLIS = (86400 * 1000) - 1;', 'if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } int hoursInMinutes = hoursOffset * 60; minutesOffset = hoursInMinutes - minutesOffset; minutesOffset = hoursInMinutes + minutesOffset;', 'if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { throw new IllegalArgumentException("Millis out of range: " + millisOffset); }'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-10', 2, 2, 2, 2, ['/** Serialization version. */ private static final long serialVersionUID = 9386874258972L; /** The start of 1972. */ /** The period in the units of this period. */ private volatile int iPeriod;', 'throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); } Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L)); return values[0]; }'], ['/** Serialization version. */ private static final long serialVersionUID = 9386874258972L; /** The start of 1972. */ private static final long START_1972 = 2L * 365L * 86400L * 1000L; /** The period in the units of this period. */ private volatile int iPeriod;', 'throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); } Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972)); return values[0]; }'], ['', 'int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));'], ['private static final long START_1972 = 2L * 365L * 86400L * 1000L;', 'int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));'], 'a/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java', 'b/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java']
['Time-11', 1, 1, 1, 1, [' static Chronology cLenientISO; static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } /** * Gets a flag indicating that verbose logging is required.'], [' static Chronology cLenientISO; static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { protected Boolean initialValue() { return Boolean.FALSE; } }; /** * Gets a flag indicating that verbose logging is required.'], ['static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }'], ['static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { protected Boolean initialValue() { return Boolean.FALSE; } };'], 'a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java', 'b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java']
['Time-12', 4, 4, 4, 4, ['if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) );', 'if (date == null) { throw new IllegalArgumentException("The date must not be null"); } // handle years in era BC return new LocalDate( date.getYear() + 1900, date.getMonth() + 1,', 'if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY),', 'if (date == null) { throw new IllegalArgumentException("The date must not be null"); } // handle years in era BC return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,'], ['if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) );', 'if (date == null) { throw new IllegalArgumentException("The date must not be null"); } if (date.getTime() < 0) { // handle years in era BC GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1,', 'if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY),', 'if (date == null) { throw new IllegalArgumentException("The date must not be null"); } if (date.getTime() < 0) { // handle years in era BC GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); } return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1,'], ['yearOfEra,', '', 'yearOfEra,', ''], ['int era = calendar.get(Calendar.ERA); (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),', 'if (date.getTime() < 0) { GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); }', 'int era = calendar.get(Calendar.ERA); (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),', 'if (date.getTime() < 0) { GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); }'], 'a/src/main/java/org/joda/time/LocalDateTime.java', 'b/src/main/java/org/joda/time/LocalDateTime.java']
['Time-13', 3, 3, 3, 3, ['if (iFieldType >= SECONDS_MILLIS) { // valueLong contains the seconds and millis fields // the minimum output is 0.000, which is 4 or 5 digits with a negative sum = Math.max(sum, 4); // plus one for the decimal point sum++; if (iFieldType == SECONDS_OPTIONAL_MILLIS &&', 'if (iPrefix != null) { iPrefix.printTo(buf, value); } int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value);', "if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3); }"], ['if (iFieldType >= SECONDS_MILLIS) { // valueLong contains the seconds and millis fields // the minimum output is 0.000, which is 4 or 5 digits with a negative sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); // plus one for the decimal point sum++; if (iFieldType == SECONDS_OPTIONAL_MILLIS &&', 'if (iPrefix != null) { iPrefix.printTo(buf, value); } int bufLen = buf.length(); int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value);', "if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { buf.insert(bufLen, '-'); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3); }"], ['sum = Math.max(sum, 4);', '', ''], ['sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));', 'int bufLen = buf.length();', "if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { buf.insert(bufLen, '-'); }"], 'a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java', 'b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java']
['Time-14', 1, 1, 1, 1, ['if (valueToAdd == 0) { return values; } // month is largest field and being added to, such as month-day if (DateTimeUtils.isContiguous(partial)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) {'], ['if (valueToAdd == 0) { return values; } if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { // month is largest field and being added to, such as month-day int curMonth0 = partial.getValue(0) - 1; int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; return set(partial, 0, values, newMonth); } if (DateTimeUtils.isContiguous(partial)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) {'], [''], ['if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { int curMonth0 = partial.getValue(0) - 1; int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; return set(partial, 0, values, newMonth); }'], 'a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java', 'b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java']
['Time-15', 1, 1, 1, 1, ['public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: return -val1; case 0: return 0L;'], ['public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: if (val1 == Long.MIN_VALUE) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); } return -val1; case 0: return 0L;'], [''], ['if (val1 == Long.MIN_VALUE) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); }'], 'a/src/main/java/org/joda/time/field/FieldUtils.java', 'b/src/main/java/org/joda/time/field/FieldUtils.java']
['Time-16', 1, 1, 1, 1, ['chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) {'], ['chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal)); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) {'], ['instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);'], ['instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));'], 'a/src/main/java/org/joda/time/format/DateTimeFormatter.java', 'b/src/main/java/org/joda/time/format/DateTimeFormatter.java']
['Time-17', 1, 1, 1, 1, ['// a bit messy, but will work in all non-pathological cases // evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore); // calculate result // currently in later offset // currently in earlier offset } // System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + " " + new DateTime(transitionStart, this));'], ['// a bit messy, but will work in all non-pathological cases // evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } // calculate result long afterStart = instant - overlapStart; if (afterStart >= diff) { // currently in later offset return earlierOrLater ? instant : instant - diff; } else { // currently in earlier offset return earlierOrLater ? instant + diff : instant; } } // System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + " " + new DateTime(transitionStart, this));'], ['long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);'], ['long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } long afterStart = instant - overlapStart; if (afterStart >= diff) { return earlierOrLater ? instant : instant - diff; } else { return earlierOrLater ? instant + diff : instant; }'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-18', 1, 1, 1, 1, [" // Assume date is Gregorian. long instant; instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant < iCutoverMillis) { // Maybe it's Julian. instant = iJulianChronology.getDateTimeMillis"], [" // Assume date is Gregorian. long instant; try { instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } catch (IllegalFieldValueException ex) { if (monthOfYear != 2 || dayOfMonth != 29) { throw ex; } instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant >= iCutoverMillis) { throw ex; } } if (instant < iCutoverMillis) { // Maybe it's Julian. instant = iJulianChronology.getDateTimeMillis"], [''], ['try { } catch (IllegalFieldValueException ex) { if (monthOfYear != 2 || dayOfMonth != 29) { throw ex; } instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant >= iCutoverMillis) { throw ex; } }'], 'a/src/main/java/org/joda/time/chrono/GJChronology.java', 'b/src/main/java/org/joda/time/chrono/GJChronology.java']
['Time-19', 1, 1, 1, 1, ['return offsetLocal; } } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);'], ['return offsetLocal; } } } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);'], ['} else if (offsetLocal > 0) {'], ['} else if (offsetLocal >= 0) {'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-20', 1, 1, 1, 1, [' public int parseInto(DateTimeParserBucket bucket, String text, int position) { String str = text.substring(position); for (String id : ALL_IDS) { if (str.startsWith(id)) { bucket.setZone(DateTimeZone.forID(id)); return position + id.length(); } } return ~position; } }'], [' public int parseInto(DateTimeParserBucket bucket, String text, int position) { String str = text.substring(position); String best = null; for (String id : ALL_IDS) { if (str.startsWith(id)) { if (best == null || id.length() > best.length()) { best = id; } } } if (best != null) { bucket.setZone(DateTimeZone.forID(best)); return position + best.length(); } return ~position; } }'], ['bucket.setZone(DateTimeZone.forID(id)); return position + id.length();'], ['String best = null; if (best == null || id.length() > best.length()) { best = id; } if (best != null) { bucket.setZone(DateTimeZone.forID(best)); return position + best.length(); }'], 'a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java', 'b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java']
['Time-21', 1, 1, 1, 1, ['if (byNameKeyCache == null) { byIdCache.put(id, byNameKeyCache = createCache()); String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); String[] setLoc = null; for (String[] strings : zoneStringsLoc) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setLoc = strings; byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]}); // need to handle case where summer and winter have the same // abbreviation, such as EST in Australia [1716305] // we handle this by appending "-Summer", cf ZoneInfoCompiler if (setLoc[2].equals(setLoc[4])) { byNameKeyCache.put(setLoc[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); } else { byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]}); } break; } } }'], ['if (byNameKeyCache == null) { byIdCache.put(id, byNameKeyCache = createCache()); String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); String[] setEn = null; for (String[] strings : zoneStringsEn) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setEn = strings; break; } } String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); String[] setLoc = null; for (String[] strings : zoneStringsLoc) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setLoc = strings; break; } } if (setEn != null && setLoc != null) { byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]}); // need to handle case where summer and winter have the same // abbreviation, such as EST in Australia [1716305] // we handle this by appending "-Summer", cf ZoneInfoCompiler if (setEn[2].equals(setEn[4])) { byNameKeyCache.put(setEn[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); } else { byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]}); } } }'], ['byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]}); if (setLoc[2].equals(setLoc[4])) { byNameKeyCache.put(setLoc[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]}); } break;'], ['String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); String[] setEn = null; for (String[] strings : zoneStringsEn) { if (strings != null && strings.length == 5 && id.equals(strings[0])) { setEn = strings; break; } } break; } } if (setEn != null && setLoc != null) { byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]}); if (setEn[2].equals(setEn[4])) { byNameKeyCache.put(setEn[4] + "-Summer", new String[] {setLoc[4], setLoc[3]}); byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});'], 'a/src/main/java/org/joda/time/tz/DefaultNameProvider.java', 'b/src/main/java/org/joda/time/tz/DefaultNameProvider.java']
['Time-22', 1, 1, 1, 1, ['* @param duration the duration, in milliseconds */ protected BasePeriod(long duration) { this(duration, null, null); // bug [3264409] } /**'], ['* @param duration the duration, in milliseconds */ protected BasePeriod(long duration) { super(); // bug [3264409] iType = PeriodType.time(); int[] values = ISOChronology.getInstanceUTC().get(this, duration); iType = PeriodType.standard(); iValues = new int[8]; System.arraycopy(values, 0, iValues, 4, 4); } /**'], ['this(duration, null, null);'], ['super(); iType = PeriodType.time(); int[] values = ISOChronology.getInstanceUTC().get(this, duration); iType = PeriodType.standard(); iValues = new int[8]; System.arraycopy(values, 0, iValues, 4, 4);'], 'a/src/main/java/org/joda/time/base/BasePeriod.java', 'b/src/main/java/org/joda/time/base/BasePeriod.java']
['Time-23', 2, 2, 2, 2, ['// Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put("GMT", "UTC"); map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu"); // JDK 1.1 compatible map.put("AST", "America/Anchorage");', 'map.put("PNT", "America/Phoenix"); map.put("CST", "America/Chicago"); map.put("EST", "America/New_York"); // JDK 1.1 compatible map.put("IET", "America/Indianapolis"); map.put("PRT", "America/Puerto_Rico"); map.put("CNT", "America/St_Johns"); map.put("AGT", "America/Buenos_Aires"); map.put("BET", "America/Sao_Paulo"); map.put("WET", "Europe/London"); map.put("ECT", "Europe/Paris"); map.put("ART", "Africa/Cairo"); map.put("CAT", "Africa/Harare"); map.put("EET", "Europe/Bucharest"); map.put("EAT", "Africa/Addis_Ababa"); map.put("MET", "Asia/Tehran"); map.put("NET", "Asia/Yerevan"); map.put("PLT", "Asia/Karachi"); map.put("IST", "Asia/Calcutta"); map.put("BST", "Asia/Dhaka"); map.put("VST", "Asia/Saigon"); map.put("CTT", "Asia/Shanghai"); map.put("JST", "Asia/Tokyo"); map.put("ACT", "Australia/Darwin");'], ['// Backwards compatibility with TimeZone. map = new HashMap<String, String>(); map.put("GMT", "UTC"); map.put("WET", "WET"); map.put("CET", "CET"); map.put("MET", "CET"); map.put("ECT", "CET"); map.put("EET", "EET"); map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu"); // JDK 1.1 compatible map.put("AST", "America/Anchorage");', 'map.put("PNT", "America/Phoenix"); map.put("CST", "America/Chicago"); map.put("EST", "America/New_York"); // JDK 1.1 compatible map.put("IET", "America/Indiana/Indianapolis"); map.put("PRT", "America/Puerto_Rico"); map.put("CNT", "America/St_Johns"); map.put("AGT", "America/Argentina/Buenos_Aires"); map.put("BET", "America/Sao_Paulo"); map.put("ART", "Africa/Cairo"); map.put("CAT", "Africa/Harare"); map.put("EAT", "Africa/Addis_Ababa"); map.put("NET", "Asia/Yerevan"); map.put("PLT", "Asia/Karachi"); map.put("IST", "Asia/Kolkata"); map.put("BST", "Asia/Dhaka"); map.put("VST", "Asia/Ho_Chi_Minh"); map.put("CTT", "Asia/Shanghai"); map.put("JST", "Asia/Tokyo"); map.put("ACT", "Australia/Darwin");'], ['', 'map.put("IET", "America/Indianapolis"); map.put("AGT", "America/Buenos_Aires"); map.put("WET", "Europe/London"); map.put("ECT", "Europe/Paris"); map.put("EET", "Europe/Bucharest"); map.put("MET", "Asia/Tehran"); map.put("IST", "Asia/Calcutta"); map.put("VST", "Asia/Saigon");'], ['map.put("WET", "WET"); map.put("CET", "CET"); map.put("MET", "CET"); map.put("ECT", "CET"); map.put("EET", "EET");', 'map.put("IET", "America/Indiana/Indianapolis"); map.put("AGT", "America/Argentina/Buenos_Aires"); map.put("IST", "Asia/Kolkata"); map.put("VST", "Asia/Ho_Chi_Minh");'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-24', 1, 1, 1, 1, ['for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage("Cannot parse \\"" + text + \'"\');'], ['for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage("Cannot parse \\"" + text + \'"\');'], [''], ['if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } }'], 'a/src/main/java/org/joda/time/format/DateTimeParserBucket.java', 'b/src/main/java/org/joda/time/format/DateTimeParserBucket.java']
['Time-25', 1, 1, 1, 1, ['return offsetLocal; } } } return offsetAdjusted; }'], ['return offsetLocal; } } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }'], [''], ['} else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } }'], 'a/src/main/java/org/joda/time/DateTimeZone.java', 'b/src/main/java/org/joda/time/DateTimeZone.java']
['Time-26', 8, 8, 8, 8, ['* @throws IllegalArgumentException if the zone has no equivalent local time * @since 2.0 */ /** * Converts a local instant to a standard UTC instant with the same', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), "Illegal instant due to time zone offset transition: " +', '// cannot verify that new value stuck because set may be lenient long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false); } public int getDifference(long minuendInstant, long subtrahendInstant) {', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false); } }', 'long localInstant = iBase.getZone().convertUTCToLocal(instant); long difference = FieldUtils.safeSubtract(value, get(instant)); localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference); return iBase.getZone().convertLocalToUTC(localInstant, false); } }'], ['* @throws IllegalArgumentException if the zone has no equivalent local time * @since 2.0 */ public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } /** * Converts a local instant to a standard UTC instant with the same', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false, instant); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false, instant); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); return iZone.convertLocalToUTC(localInstant, false, instant); } } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false, instant); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), "Illegal instant due to time zone offset transition: " +', '// cannot verify that new value stuck because set may be lenient long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false, instant); } public int getDifference(long minuendInstant, long subtrahendInstant) {', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false, instant); } }', '} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false, instant); } }', 'long localInstant = iBase.getZone().convertUTCToLocal(instant); long difference = FieldUtils.safeSubtract(value, get(instant)); localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference); return iBase.getZone().convertLocalToUTC(localInstant, false, instant); } }'], ['', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false); long result = iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iZone.convertLocalToUTC(localInstant, false);', 'return iBase.getZone().convertLocalToUTC(localInstant, false);'], ['public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); }', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant); long result = iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iZone.convertLocalToUTC(localInstant, false, instant);', 'return iBase.getZone().convertLocalToUTC(localInstant, false, instant);'], 'a/src/main/java/org/joda/time/field/LenientDateTimeField.java', 'b/src/main/java/org/joda/time/field/LenientDateTimeField.java']
['Time-27', 1, 1, 1, 1, ['int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); } Object[] comp = createComposite(elementPairs); if (notPrinter) {'], ['int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); } } Object[] comp = createComposite(elementPairs); if (notPrinter) {'], [''], ['if (sep.iAfterParser == null && sep.iAfterPrinter == null) { }'], 'a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java', 'b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java']
['JacksonCore-1', 3, 3, 3, 3, [' public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException { return new BigDecimal(numStr); } public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {', 'public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException { return new BigDecimal(buffer, offset, len); } }', "return NumberInput.parseBigDecimal(_resultArray); } // Or a shared buffer? if (_inputStart >= 0) { return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen); } // Or if not, just a single buffer (the usual case) if (_segmentSize == 0) { return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize); } // If not, let's just get it aggregated..."], [' public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException { try { return new BigDecimal(numStr); } catch (NumberFormatException e) { throw _badBigDecimal(numStr); } } public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {', 'public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException { try { return new BigDecimal(buffer, offset, len); } catch (NumberFormatException e) { throw _badBigDecimal(new String(buffer, offset, len)); } } private static NumberFormatException _badBigDecimal(String str) { return new NumberFormatException("Value \\""+str+"\\" can not be represented as BigDecimal"); } }', "return NumberInput.parseBigDecimal(_resultArray); } // Or a shared buffer? if ((_inputStart >= 0) && (_inputBuffer != null)) { return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen); } // Or if not, just a single buffer (the usual case) if ((_segmentSize == 0) && (_currentSegment != null)) { return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize); } // If not, let's just get it aggregated..."], ['', '', 'if (_inputStart >= 0) { if (_segmentSize == 0) {'], ['try { } catch (NumberFormatException e) { throw _badBigDecimal(numStr); }', 'try { } catch (NumberFormatException e) { throw _badBigDecimal(new String(buffer, offset, len)); } private static NumberFormatException _badBigDecimal(String str) { return new NumberFormatException("Value \\""+str+"\\" can not be represented as BigDecimal"); }', 'if ((_inputStart >= 0) && (_inputBuffer != null)) { if ((_segmentSize == 0) && (_currentSegment != null)) {'], 'a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java', 'b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java']
['JacksonCore-2', 8, 8, 8, 8, ['--ptr; // need to push back following separator _inputPtr = ptr; // As per #105, need separating space between root values; check here int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return reset(negative, intLen, fractLen, expLen);', '// Ok; unless we hit end-of-input, need to push last char read back if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); // And there we have it!', '* NOTE: caller MUST ensure there is at least one character available; * and that input pointer is AT given char (not past) */ // caller had pushed it back, before calling; reset /* /**********************************************************', '--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); // As per #105, need separating space between root values; check here // And there we have it! return resetInt(negative, intLen);', '--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); // As per #105, need separating space between root values; check here // And there we have it! return resetInt(negative, intPartLength);', 'if (!eof) { --_inputPtr; // As per #105, need separating space between root values; check here } _textBuffer.setCurrentLength(outPtr);', '* NOTE: caller MUST ensure there is at least one character available; * and that input pointer is AT given char (not past) */ // caller had pushed it back, before calling; reset // TODO? Handle UTF-8 char decoding for error reporting /* /**********************************************************', '} break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } }'], ['--ptr; // need to push back following separator _inputPtr = ptr; // As per #105, need separating space between root values; check here if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return reset(negative, intLen, fractLen, expLen);', '// Ok; unless we hit end-of-input, need to push last char read back if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr); // And there we have it!', "* NOTE: caller MUST ensure there is at least one character available; * and that input pointer is AT given char (not past) */ private final void _verifyRootSpace(int ch) throws IOException { // caller had pushed it back, before calling; reset ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); } /* /**********************************************************", '--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); // As per #105, need separating space between root values; check here if (_parsingContext.inRoot()) { _verifyRootSpace(c); } // And there we have it! return resetInt(negative, intLen);', '--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); // As per #105, need separating space between root values; check here if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); } // And there we have it! return resetInt(negative, intPartLength);', 'if (!eof) { --_inputPtr; // As per #105, need separating space between root values; check here if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr);', "* NOTE: caller MUST ensure there is at least one character available; * and that input pointer is AT given char (not past) */ private final void _verifyRootSpace(int ch) throws IOException { // caller had pushed it back, before calling; reset ++_inputPtr; // TODO? Handle UTF-8 char decoding for error reporting switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); } /* /**********************************************************", '} break; default: // e.g. -1 _reportInvalidChar(i); } }'], ['', '', '', '', '', '', '', 'if (i < 32) { _throwInvalidSpace(i); }'], ['if (_parsingContext.inRoot()) { _verifyRootSpace(ch); }', 'if (_parsingContext.inRoot()) { _verifyRootSpace(c); }', "private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); }", 'if (_parsingContext.inRoot()) { _verifyRootSpace(c); }', 'if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); }', 'if (_parsingContext.inRoot()) { _verifyRootSpace(c); }', "private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); }", ''], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-3', 1, 1, 1, 1, ['_inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = bufferRecyclable; }'], ['_inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _currInputRowStart = start; // If we have offset, need to omit that from byte offset, so: _currInputProcessed = -start; _bufferRecyclable = bufferRecyclable; }'], [''], ['_currInputRowStart = start; _currInputProcessed = -start;'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-4', 1, 1, 1, 1, ["final char[] curr = _currentSegment; // Let's grow by 50% by default final int len = curr.length; // but above intended maximum, slow to increase by 25% int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); return (_currentSegment = Arrays.copyOf(curr, newLen)); }"], ["final char[] curr = _currentSegment; // Let's grow by 50% by default final int len = curr.length; int newLen = len + (len >> 1); // but above intended maximum, slow to increase by 25% if (newLen > MAX_SEGMENT_LEN) { newLen = len + (len >> 2); } return (_currentSegment = Arrays.copyOf(curr, newLen)); }"], ['int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));'], ['int newLen = len + (len >> 1); if (newLen > MAX_SEGMENT_LEN) { newLen = len + (len >> 2); }'], 'a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java', 'b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java']
['JacksonCore-5', 1, 1, 1, 1, ["return -1; } for (int i = 0; i < len; ++i) { char c = str.charAt(i++); if (c > '9' || c < '0') { return -1; }"], ["return -1; } for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { return -1; }"], ['char c = str.charAt(i++);'], ['char c = str.charAt(i);'], 'a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java', 'b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java']
['JacksonCore-6', 1, 1, 1, 1, ["return -1; } // [core#176]: no leading zeroes allowed for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { return -1; }"], ["return -1; } // [core#176]: no leading zeroes allowed char c = str.charAt(0); if (c <= '0') { return (len == 1 && c == '0') ? 0 : -1; } if (c > '9') { return -1; } for (int i = 1; i < len; ++i) { c = str.charAt(i); if (c > '9' || c < '0') { return -1; }"], ['for (int i = 0; i < len; ++i) { char c = str.charAt(i);'], ["char c = str.charAt(0); if (c <= '0') { return (len == 1 && c == '0') ? 0 : -1; } if (c > '9') { return -1; } for (int i = 1; i < len; ++i) { c = str.charAt(i);"], 'a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java', 'b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java']
['JacksonCore-7', 1, 1, 1, 1, ['public int writeValue() { // Most likely, object: if (_type == TYPE_OBJECT) { _gotName = false; ++_index; return STATUS_OK_AFTER_COLON;'], ['public int writeValue() { // Most likely, object: if (_type == TYPE_OBJECT) { if (!_gotName) { return STATUS_EXPECT_NAME; } _gotName = false; ++_index; return STATUS_OK_AFTER_COLON;'], [''], ['if (!_gotName) { return STATUS_EXPECT_NAME; }'], 'a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java', 'b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java']
['JacksonCore-8', 1, 1, 1, 1, ['return (_resultArray = _resultString.toCharArray()); } // Nope; but does it fit in just one segment? if (!_hasSegments) return _currentSegment; // Nope, need to have/create a non-segmented array and return it return contentsAsArray(); }'], ['return (_resultArray = _resultString.toCharArray()); } // Nope; but does it fit in just one segment? if (!_hasSegments && _currentSegment != null) return _currentSegment; // Nope, need to have/create a non-segmented array and return it return contentsAsArray(); }'], ['if (!_hasSegments) return _currentSegment;'], ['if (!_hasSegments && _currentSegment != null) return _currentSegment;'], 'a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java', 'b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java']
['JacksonCore-9', 6, 6, 6, 6, ['if (_currToken == JsonToken.VALUE_STRING) { return getText(); } return getValueAsString(null); }', 'if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; }', '} return _textBuffer.contentsAsString(); } return super.getValueAsString(null); }', '} return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); }', '} return _textBuffer.contentsAsString(); } return super.getValueAsString(null); }', '} return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); }'], ['if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return getValueAsString(null); }', 'if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; }', '} return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(null); }', '} return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(defValue); }', '} return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(null); }', '} return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(defValue); }'], ['', '', '', '', '', ''], ['if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }', 'if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-10', 2, 2, 2, 2, ['/* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array, * since "long names" area follows. Instead, need to calculate from hash size. */ if (_spilloverEnd >= hashArea.length) { if (_failOnDoS) { _reportTooManyCollisions(); }', '* to work it out, but this is the simplest, fast and seems to do ok. */ hash += (hash >>> 16); // to xor hi- and low- 16-bits hash ^= (hash >>> 12); return hash; }'], ['/* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array, * since "long names" area follows. Instead, need to calculate from hash size. */ final int end = (_hashSize << 3); if (_spilloverEnd >= end) { if (_failOnDoS) { _reportTooManyCollisions(); }', '* to work it out, but this is the simplest, fast and seems to do ok. */ hash += (hash >>> 16); // to xor hi- and low- 16-bits hash ^= (hash << 3); // shuffle back a bit hash += (hash >>> 12); // and bit more return hash; }'], ['if (_spilloverEnd >= hashArea.length) {', 'hash ^= (hash >>> 12);'], ['final int end = (_hashSize << 3); if (_spilloverEnd >= end) {', 'hash ^= (hash << 3); // shuffle back a bit hash += (hash >>> 12); // and bit more'], 'a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java', 'b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java']
['JacksonCore-11', 1, 1, 1, 1, ['_hashShared = false; // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure // we rehash as needed, as need-rehash flag is not copied from parent } if (_needRehash) { rehash();'], ['_hashShared = false; // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure // we rehash as needed, as need-rehash flag is not copied from parent _verifyNeedForRehash(); } if (_needRehash) { rehash();'], [''], ['_verifyNeedForRehash();'], 'a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java', 'b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java']
['JacksonCore-12', 8, 8, 8, 8, ["if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); /* And should we now have a name? Always true for Object contexts, since * the intermediate 'expect-value' state is never retained.", 'boolean inObject = _parsingContext.inObject(); if (inObject) { // First, field name itself: String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } // Ok: we must have a value... what is it?', 'if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { // when doing literal match, must consider escaping: char[] nameChars = sstr.asQuotedChars();', 'if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;', 'private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; switch (i) { case \'"\':', '_parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;', 'public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr()); }', '_nameInputTotal, -1L, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr()); }'], ["if (_parsingContext.expectComma()) { i = _skipComma(i); } /* And should we now have a name? Always true for Object contexts, since * the intermediate 'expect-value' state is never retained.", 'boolean inObject = _parsingContext.inObject(); if (inObject) { // First, field name itself: _updateNameLocation(); String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } _updateLocation(); // Ok: we must have a value... what is it?', 'if (_parsingContext.expectComma()) { i = _skipComma(i); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return false; } _updateNameLocation(); if (i == INT_QUOTE) { // when doing literal match, must consider escaping: char[] nameChars = sstr.asQuotedChars();', 'if (_parsingContext.expectComma()) { i = _skipComma(i); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return null; } _updateNameLocation(); String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;', 'private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; _updateLocation(); switch (i) { case \'"\':', '_parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;', 'public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); if (_currToken == JsonToken.FIELD_NAME) { return new JsonLocation(src, -1L, _nameInputTotal, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, -1L, _tokenInputTotal, _tokenInputRow, getTokenColumnNr()); }', '_nameInputTotal, -1L, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, _tokenInputTotal, -1L, _tokenInputRow, getTokenColumnNr()); }'], ['_updateLocation();', '', '_updateLocation();', '_updateLocation();', '', '', '-1L, getTokenCharacterOffset(), getTokenLineNr(),', 'getTokenCharacterOffset(), -1L, getTokenLineNr(),'], ['', '_updateNameLocation(); _updateLocation();', '_updateLocation(); _updateNameLocation();', '_updateLocation(); _updateNameLocation(); _updateLocation();', '_updateLocation();', '_updateLocation();', 'if (_currToken == JsonToken.FIELD_NAME) { return new JsonLocation(src, -1L, _nameInputTotal, _nameInputRow, _tokenInputCol); } -1L, _tokenInputTotal, _tokenInputRow,', '_tokenInputTotal, -1L, _tokenInputRow,'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-13', 1, 1, 1, 1, ['return this; } @Override protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {'], ['return this; } @Override public JsonGenerator disable(Feature f) { super.disable(f); if (f == Feature.QUOTE_FIELD_NAMES) { _cfgUnqNames = true; } return this; } @Override protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {'], [''], ['@Override public JsonGenerator disable(Feature f) { super.disable(f); if (f == Feature.QUOTE_FIELD_NAMES) { _cfgUnqNames = true; } return this; }'], 'a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java', 'b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java']
['JacksonCore-14', 1, 1, 1, 1, [' protected final void _verifyRelease(byte[] toRelease, byte[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException("Trying to release buffer not owned by the context"); } }'], [' protected final void _verifyRelease(byte[] toRelease, byte[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException("Trying to release buffer smaller than original"); } }'], ['if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } return new IllegalArgumentException("Trying to release buffer not owned by the context");'], ['if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } return new IllegalArgumentException("Trying to release buffer smaller than original");'], 'a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java', 'b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java']
['JacksonCore-15', 1, 1, 1, 1, ['//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken // check for no buffered context _exposedContext - null //If all the conditions matches then check for scalar / non-scalar property //if not scalar and ended successfully, then return null //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null // Anything buffered? TokenFilterContext ctxt = _exposedContext;'], ['//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken // check for no buffered context _exposedContext - null //If all the conditions matches then check for scalar / non-scalar property if(!_allowMultipleMatches && _currToken != null && _exposedContext == null){ //if not scalar and ended successfully, then return null if((_currToken.isStructEnd() && _headContext.isStartHandled()) ){ return (_currToken = null); } //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null else if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && _itemFilter == TokenFilter.INCLUDE_ALL) { return (_currToken = null); } } // Anything buffered? TokenFilterContext ctxt = _exposedContext;'], [''], ['if(!_allowMultipleMatches && _currToken != null && _exposedContext == null){ if((_currToken.isStructEnd() && _headContext.isStartHandled()) ){ return (_currToken = null); } else if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && _itemFilter == TokenFilter.INCLUDE_ALL) { return (_currToken = null); } }'], 'a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java', 'b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java']
['JacksonCore-16', 3, 3, 3, 3, ['* * @since 2.8 */ /* *******************************************************', 'protected JsonParserSequence(JsonParser[] parsers) { super(parsers[0]); _parsers = parsers; _nextParser = 1; }', '} @Override public JsonToken nextToken() throws IOException, JsonParseException { JsonToken t = delegate.nextToken(); if (t != null) return t; while (switchToNext()) { t = delegate.nextToken(); if (t != null) return t; } return null; } /*'], ['* * @since 2.8 */ protected boolean _suppressNextToken; /* *******************************************************', 'protected JsonParserSequence(JsonParser[] parsers) { super(parsers[0]); _suppressNextToken = delegate.hasCurrentToken(); _parsers = parsers; _nextParser = 1; }', '} @Override public JsonToken nextToken() throws IOException { if (delegate == null) { return null; } if (_suppressNextToken) { _suppressNextToken = false; return delegate.currentToken(); } JsonToken t = delegate.nextToken(); while ((t == null) && switchToNext()) { t = delegate.hasCurrentToken() ? delegate.currentToken() : delegate.nextToken(); } return t; } /*'], ['', '', 'public JsonToken nextToken() throws IOException, JsonParseException if (t != null) return t; while (switchToNext()) { t = delegate.nextToken(); if (t != null) return t; return null;'], ['protected boolean _suppressNextToken;', '_suppressNextToken = delegate.hasCurrentToken();', 'public JsonToken nextToken() throws IOException if (delegate == null) { return null; } if (_suppressNextToken) { _suppressNextToken = false; return delegate.currentToken(); } while ((t == null) && switchToNext()) { t = delegate.hasCurrentToken() ? delegate.currentToken() : delegate.nextToken(); return t;'], 'a/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java', 'b/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java']
['JacksonCore-17', 3, 3, 3, 3, ["final char[] buf = _charBuffer; // minor optimization: see if we can just get and copy // If not, need segmented approach. For speed, let's also use input buffer // size that is guaranteed to fit in output buffer; each char can expand to // at most 3 bytes, so at most 1/3 of buffer size. while (len > 0) { int len2 = Math.min(buf.length, len); text.getChars(offset, offset+len2, buf, 0); writeRaw(buf, 0, len2); // If this is NOT the last segment and if the last character looks like // split surrogate second half, drop it offset += len2; len -= len2; }", '* * @since 2.8.2 */ /* /**********************************************************', 'if (ch <= SURR2_LAST) { // yes, outside of BMP // Do we have second part? if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError("Split surrogate on writeRaw() input (last character)"); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1;'], ["final char[] buf = _charBuffer; // minor optimization: see if we can just get and copy if (len <= buf.length) { text.getChars(offset, offset+len, buf, 0); _writeRawSegment(buf, 0, len); return; } // If not, need segmented approach. For speed, let's also use input buffer // size that is guaranteed to fit in output buffer; each char can expand to // at most 3 bytes, so at most 1/3 of buffer size. final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16 final int maxBytes = maxChunk * 3; while (len > 0) { int len2 = Math.min(maxChunk, len); text.getChars(offset, offset+len2, buf, 0); if ((_outputTail + maxBytes) > _outputEnd) { _flushBuffer(); } // If this is NOT the last segment and if the last character looks like // split surrogate second half, drop it if (len > 0) { char ch = buf[len2-1]; if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) { --len2; } } _writeRawSegment(buf, 0, len2); offset += len2; len -= len2; }", '* * @since 2.8.2 */ private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException { main_loop: while (offset < end) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= end) { break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, end); } } } /* /**********************************************************', 'if (ch <= SURR2_LAST) { // yes, outside of BMP // Do we have second part? if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(String.format( "Split surrogate on writeRaw() input (last character): first character 0x%4x", ch)); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1;'], ['int len2 = Math.min(buf.length, len); writeRaw(buf, 0, len2);', '', '_reportError("Split surrogate on writeRaw() input (last character)");'], ['if (len <= buf.length) { text.getChars(offset, offset+len, buf, 0); _writeRawSegment(buf, 0, len); return; } final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16 final int maxBytes = maxChunk * 3; int len2 = Math.min(maxChunk, len); if ((_outputTail + maxBytes) > _outputEnd) { _flushBuffer(); } if (len > 0) { char ch = buf[len2-1]; if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) { --len2; } } _writeRawSegment(buf, 0, len2);', 'private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException { main_loop: while (offset < end) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= end) { break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, end); } } }', '_reportError(String.format( "Split surrogate on writeRaw() input (last character): first character 0x%4x", ch));'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java']
['JacksonCore-18', 4, 4, 4, 4, ['* * @since 2.7.7 */ /* /**********************************************************', '* @since 2.7.7 */ protected String _asString(BigDecimal value) throws IOException { // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector return value.toString(); }', 'if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString()); } else { writeRaw(_asString(value)); }', 'if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { writeRaw(value.toPlainString()); } else { writeRaw(_asString(value)); }'], ['* * @since 2.7.7 */ protected final static int MAX_BIG_DECIMAL_SCALE = 9999; /* /**********************************************************', '* @since 2.7.7 */ protected String _asString(BigDecimal value) throws IOException { if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector int scale = value.scale(); if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) { _reportError(String.format( "Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]", scale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE)); } return value.toPlainString(); } return value.toString(); }', 'if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(_asString(value)); } else { writeRaw(_asString(value)); }', 'if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(_asString(value)); } else { writeRaw(_asString(value)); }'], ['', '', 'String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString());', 'String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { writeRaw(value.toPlainString());'], ['protected final static int MAX_BIG_DECIMAL_SCALE = 9999;', 'if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { int scale = value.scale(); if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) { _reportError(String.format( "Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]", scale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE)); } return value.toPlainString(); }', '_writeQuotedRaw(_asString(value));', '_writeQuotedRaw(_asString(value));'], 'a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java', 'b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java']
['JacksonCore-19', 2, 2, 2, 2, ["int fractLen = 0; // And then see if we get other parts if (c == '.') { // yes, fraction outBuf[outPtr++] = c; fract_loop:", ' // And then see if we get other parts if (c == INT_PERIOD) { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop:'], ["int fractLen = 0; // And then see if we get other parts if (c == '.') { // yes, fraction if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; fract_loop:", ' // And then see if we get other parts if (c == INT_PERIOD) { // yes, fraction if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; fract_loop:'], ['', ''], ['if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }', 'if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }'], 'a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java']
['JacksonCore-20', 1, 1, 1, 1, ['*/ public void writeEmbeddedObject(Object object) throws IOException { // 01-Sep-2016, tatu: As per [core#318], handle small number of cases throw new JsonGenerationException("No native support for writing embedded objects", this); }'], ['*/ public void writeEmbeddedObject(Object object) throws IOException { // 01-Sep-2016, tatu: As per [core#318], handle small number of cases if (object == null) { writeNull(); return; } if (object instanceof byte[]) { writeBinary((byte[]) object); return; } throw new JsonGenerationException("No native support for writing embedded objects of type " +object.getClass().getName(), this); }'], ['throw new JsonGenerationException("No native support for writing embedded objects",'], ['if (object == null) { writeNull(); return; } if (object instanceof byte[]) { writeBinary((byte[]) object); return; } throw new JsonGenerationException("No native support for writing embedded objects of type " +object.getClass().getName(),'], 'a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java', 'b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java']
['JacksonCore-21', 2, 2, 2, 2, ['// If all the conditions matches then check for scalar / non-scalar property if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) { //if not scalar and ended successfully, and !includePath, then return null if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null);', 'if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } } } // Anything buffered?'], ['// If all the conditions matches then check for scalar / non-scalar property if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) { //if not scalar and ended successfully, and !includePath, then return null if (!_includePath) { if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null);', 'if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } } } } // Anything buffered?'], ['', ''], ['if (!_includePath) {', '}'], 'a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java', 'b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java']
['JacksonCore-22', 7, 7, 7, 7, ['} _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_includePath) { return (_currToken = t); } }', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return (_currToken = t); } } // Otherwise not included (leaves must be explicitly included)', '} _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_includePath) { return (_currToken = t); } // if (_includeImmediateParent) { ...', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return (_currToken = t); } } // Otherwise not included (leaves must be explicitly included)', 'continue main_loop; } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { return _nextBuffered(buffRoot); } }', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return _nextBuffered(buffRoot); } } // Otherwise not included (leaves must be explicitly included)', '} } @Override public JsonToken nextValue() throws IOException {'], ['} _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_verifyAllowedMatches() && _includePath) { return (_currToken = t); } }', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { if (_verifyAllowedMatches()) { return (_currToken = t); } } } // Otherwise not included (leaves must be explicitly included)', '} _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_verifyAllowedMatches() && _includePath) { return (_currToken = t); } // if (_includeImmediateParent) { ...', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { if (_verifyAllowedMatches()) { return (_currToken = t); } } } // Otherwise not included (leaves must be explicitly included)', 'continue main_loop; } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) { return _nextBuffered(buffRoot); } }', 'f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { if (_verifyAllowedMatches()) { return _nextBuffered(buffRoot); } } } // Otherwise not included (leaves must be explicitly included)', '} } private final boolean _verifyAllowedMatches() throws IOException { if (_matchCount == 0 || _allowMultipleMatches) { ++_matchCount; return true; } return false; } @Override public JsonToken nextValue() throws IOException {'], ['if (_includePath) {', '', 'if (_includePath) {', '', 'if (f == TokenFilter.INCLUDE_ALL) {', '', ''], ['if (_verifyAllowedMatches() && _includePath) {', 'if (_verifyAllowedMatches()) { }', 'if (_verifyAllowedMatches() && _includePath) {', 'if (_verifyAllowedMatches()) { }', 'if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {', 'if (_verifyAllowedMatches()) { }', 'private final boolean _verifyAllowedMatches() throws IOException { if (_matchCount == 0 || _allowMultipleMatches) { ++_matchCount; return true; } return false; }'], 'a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java', 'b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java']
['JacksonCore-23', 1, 1, 1, 1, [' @Override public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }'], [' @Override public DefaultPrettyPrinter createInstance() { if (getClass() != DefaultPrettyPrinter.class) { // since 2.10 throw new IllegalStateException("Failed `createInstance()`: "+getClass().getName() +" does not override method; it has to"); } return new DefaultPrettyPrinter(this); }'], [''], ['if (getClass() != DefaultPrettyPrinter.class) { // since 2.10 throw new IllegalStateException("Failed `createInstance()`: "+getClass().getName() +" does not override method; it has to"); }'], 'a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java', 'b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java']
['JacksonCore-24', 4, 4, 4, 4, ['// @since 2.9.8 protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException { final String numDesc = _longIntegerDesc(rawNum); _reportError("Numeric value (%s) out of range of %s", numDesc, (expType == NR_LONG) ? "long" : "int"); } /*', '// Let\'s verify it\'s lossless conversion by simple roundtrip int result = (int) _numberLong; if (((long) result) != _numberLong) { _reportError("Numeric value ("+getText()+") out of range of int"); } _numberInt = result; } else if ((_numTypesValid & NR_BIGINT) != 0) {', ' // @since 2.10 protected void reportOverflowInt(String numDesc) throws IOException { _reportError(String.format("Numeric value (%s) out of range of int (%d - %s)", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE)); } // @since 2.10 /** * Method called to throw an exception for integral (not floating point) input', ' // @since 2.10 protected void reportOverflowLong(String numDesc) throws IOException { _reportError(String.format("Numeric value (%s) out of range of long (%d - %s)", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE)); } // @since 2.10 /** * @since 2.10'], ['// @since 2.9.8 protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException { if (expType == NR_INT) { reportOverflowInt(rawNum); } else { reportOverflowLong(rawNum); } } /*', "// Let's verify it's lossless conversion by simple roundtrip int result = (int) _numberLong; if (((long) result) != _numberLong) { reportOverflowInt(getText(), currentToken()); } _numberInt = result; } else if ((_numTypesValid & NR_BIGINT) != 0) {", ' // @since 2.10 protected void reportOverflowInt(String numDesc) throws IOException { reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT); } // @since 2.10 protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format("Numeric value (%s) out of range of int (%d - %s)", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE), inputType, Integer.TYPE); } /** * Method called to throw an exception for integral (not floating point) input', ' // @since 2.10 protected void reportOverflowLong(String numDesc) throws IOException { reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT); } // @since 2.10 protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format("Numeric value (%s) out of range of long (%d - %s)", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE), inputType, Long.TYPE); } /** * @since 2.10'], ['final String numDesc = _longIntegerDesc(rawNum); _reportError("Numeric value (%s) out of range of %s", numDesc, (expType == NR_LONG) ? "long" : "int");', '_reportError("Numeric value ("+getText()+") out of range of int");', '_reportError(String.format("Numeric value (%s) out of range of int (%d - %s)", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));', '_reportError(String.format("Numeric value (%s) out of range of long (%d - %s)", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));'], ['if (expType == NR_INT) { reportOverflowInt(rawNum); } else { reportOverflowLong(rawNum); }', 'reportOverflowInt(getText(), currentToken());', 'reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT); protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format("Numeric value (%s) out of range of int (%d - %s)", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE), inputType, Integer.TYPE); }', 'reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT); protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format("Numeric value (%s) out of range of long (%d - %s)", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE), inputType, Long.TYPE); }'], 'a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java', 'b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java']
['JacksonCore-25', 1, 1, 1, 1, ['} char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) { if (codes[i] != 0) { break; }'], ['} char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i < maxCode) { if (codes[i] != 0) { break; }'], ['if (i <= maxCode) {'], ['if (i < maxCode) {'], 'a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java']
['JacksonCore-26', 1, 1, 1, 1, ['_currInputRowStart = start - (_inputEnd - _currInputRowStart); // And then update buffer settings _inputBuffer = buf; _inputPtr = start; _inputEnd = end;'], ['_currInputRowStart = start - (_inputEnd - _currInputRowStart); // And then update buffer settings _currBufferStart = start; _inputBuffer = buf; _inputPtr = start; _inputEnd = end;'], [''], ['_currBufferStart = start;'], 'a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java', 'b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java']
['Codec-1', 3, 3, 3, 3, ['} // 1. Convert to lowercase txt = txt.toLowerCase(); // 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", "");', '} // single character is itself if (txt.length() == 1) { return txt.toUpperCase() ; } char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;', '} } if (count == len) { return str.toUpperCase(); } return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH); }'], ['} // 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); // 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", "");', '} // single character is itself if (txt.length() == 1) { return txt.toUpperCase(java.util.Locale.ENGLISH) ; } char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;', '} } if (count == len) { return str.toUpperCase(java.util.Locale.ENGLISH); } return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH); }'], ['txt = txt.toLowerCase();', 'return txt.toUpperCase() ;', 'return str.toUpperCase();'], ['txt = txt.toLowerCase(java.util.Locale.ENGLISH);', 'return txt.toUpperCase(java.util.Locale.ENGLISH) ;', 'return str.toUpperCase(java.util.Locale.ENGLISH);'], 'a/src/java/org/apache/commons/codec/language/SoundexUtils.java', 'b/src/java/org/apache/commons/codec/language/SoundexUtils.java']
['Codec-2', 1, 1, 1, 1, ['} break; } if (lineLength > 0) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; }'], ['} break; } if (lineLength > 0 && pos > 0) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; }'], ['if (lineLength > 0) {'], ['if (lineLength > 0 && pos > 0) {'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-3', 1, 1, 1, 1, ['if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { //-- obvious germanic --// result.append(\'K\'); } else if (contains(value, index + 1, 4, "IER")) { result.append(\'J\'); } else { result.append(\'J\', \'K\');'], ['if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { //-- obvious germanic --// result.append(\'K\'); } else if (contains(value, index + 1, 3, "IER")) { result.append(\'J\'); } else { result.append(\'J\', \'K\');'], ['} else if (contains(value, index + 1, 4, "IER")) {'], ['} else if (contains(value, index + 1, 3, "IER")) {'], 'a/src/java/org/apache/commons/codec/language/DoubleMetaphone.java', 'b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java']
['Codec-4', 1, 1, 1, 1, ['* </p> */ public Base64() { this(false); } /**'], ['* </p> */ public Base64() { this(0); } /**'], ['this(false);'], ['this(0);'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-5', 1, 1, 1, 1, ["// EOF (-1) and first time '=' character is encountered in stream. // This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { x = x << 6; switch (modulus) {"], ["// EOF (-1) and first time '=' character is encountered in stream. // This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); } x = x << 6; switch (modulus) {"], [''], ['if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); }'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-6', 3, 3, 3, 3, ['} else if (len == 0) { return 0; } else { /* Rationale for while-loop on (readLen == 0): -----', '----- This is a fix for CODEC-101 */ if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);', 'base64.decode(buf, 0, c); } } return base64.readResults(b, offset, len); } }'], ['} else if (len == 0) { return 0; } else { int readLen = 0; /* Rationale for while-loop on (readLen == 0): -----', '----- This is a fix for CODEC-101 */ while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf);', 'base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; } }'], ['', '', 'return base64.readResults(b, offset, len);'], ['int readLen = 0;', 'while (readLen == 0) {', 'readLen = base64.readResults(b, offset, len); } return readLen;'], 'a/src/java/org/apache/commons/codec/binary/Base64InputStream.java', 'b/src/java/org/apache/commons/codec/binary/Base64InputStream.java']
['Codec-7', 1, 1, 1, 1, ['* @since 1.4 */ public static String encodeBase64String(byte[] binaryData) { return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); } /**'], ['* @since 1.4 */ public static String encodeBase64String(byte[] binaryData) { return StringUtils.newStringUtf8(encodeBase64(binaryData, false)); } /**'], ['return StringUtils.newStringUtf8(encodeBase64(binaryData, true));'], ['return StringUtils.newStringUtf8(encodeBase64(binaryData, false));'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-8', 2, 2, 2, 2, ['return eof ? -1 : 0; } void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } } /** * <p> * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with', 'if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else {'], ['return eof ? -1 : 0; } /** * <p> * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with', 'if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (doEncode) { base64.encode(buf, 0, c); } else {'], ['void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } }', 'if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); }'], ['', ''], 'a/src/java/org/apache/commons/codec/binary/Base64InputStream.java', 'b/src/java/org/apache/commons/codec/binary/Base64InputStream.java']
['Codec-9', 1, 1, 1, 1, ['return binaryData; } long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len +'], ['return binaryData; } long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len +'], ['long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);'], ['long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);'], 'a/src/java/org/apache/commons/codec/binary/Base64.java', 'b/src/java/org/apache/commons/codec/binary/Base64.java']
['Codec-10', 1, 1, 1, 1, ['txt = txt.replaceAll("^gn", "2n"); // End txt = txt.replaceAll("^mb", "m2"); // 4. Handle replacements txt = txt.replaceAll("cq", "2q");'], ['txt = txt.replaceAll("^gn", "2n"); // End txt = txt.replaceAll("mb$", "m2"); // 4. Handle replacements txt = txt.replaceAll("cq", "2q");'], ['txt = txt.replaceAll("^mb", "m2");'], ['txt = txt.replaceAll("mb$", "m2");'], 'a/src/java/org/apache/commons/codec/language/Caverphone.java', 'b/src/java/org/apache/commons/codec/language/Caverphone.java']
['Codec-11', 7, 7, 7, 7, [' private static final byte SPACE = 32; /** Safe line length for quoted printable encoded text. */ // Static initializer for printable chars collection static {', '* the buffer to write to * @return The number of bytes written to the <code>buffer</code> */ private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { buffer.write(ESCAPE_CHAR); char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)); char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16)); buffer.write(hex1); buffer.write(hex2); } /**', '* the byte array * @return the unsigned octet at position <code>index</code> from the array */ /** * Write a byte to the buffer.', '* the buffer to write to * @return the number of bytes that have been written to the buffer */ /** * Checks whether the given byte is whitespace.', '* byte to be checked * @return <code>true</code> if the byte is either a space or tab character */ /** * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.', "printable = PRINTABLE_CHARS; } ByteArrayOutputStream buffer = new ByteArrayOutputStream(); // encode up to buffer.length - 3, the last three octets will be treated // separately for simplification of note #3 // up to this length it is safe to add any byte, encoded or not for (byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); } else { // rule #3: whitespace at the end of a line *must* be encoded // rule #5: soft line break encodeQuotedPrintable(b, buffer); } } // rule #3: whitespace at the end of a line *must* be encoded // if we would do a soft break line after this octet, encode whitespace // note #3: '=' *must not* be the ultimate or penultimate character // simplification: if < 6 bytes left, do a soft line break as we may need // exactly 6 bytes space for the last 2 bytes // rule #3: trailing whitespace shall be encoded return buffer.toByteArray(); }", 'if (b == ESCAPE_CHAR) { try { // if the next octet is a CR we have found a soft line break int u = Utils.digit16(bytes[++i]); int l = Utils.digit16(bytes[++i]); buffer.write((char) ((u << 4) + l)); } catch (ArrayIndexOutOfBoundsException e) { throw new DecoderException("Invalid quoted-printable encoding", e); } } else { // every other octet is appended except for CR & LF buffer.write(b); }'], [' private static final byte SPACE = 32; private static final byte CR = 13; private static final byte LF = 10; /** Safe line length for quoted printable encoded text. */ private static final int SAFE_LENGTH = 73; // Static initializer for printable chars collection static {', '* the buffer to write to * @return The number of bytes written to the <code>buffer</code> */ private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { buffer.write(ESCAPE_CHAR); char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16)); char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16)); buffer.write(hex1); buffer.write(hex2); return 3; } /**', '* the byte array * @return the unsigned octet at position <code>index</code> from the array */ private static int getUnsignedOctet(final int index, final byte[] bytes) { int b = bytes[index]; if (b < 0) { b = 256 + b; } return b; } /** * Write a byte to the buffer.', '* the buffer to write to * @return the number of bytes that have been written to the buffer */ private static int encodeByte(final int b, final boolean encode, final ByteArrayOutputStream buffer) { if (encode) { return encodeQuotedPrintable(b, buffer); } else { buffer.write(b); return 1; } } /** * Checks whether the given byte is whitespace.', '* byte to be checked * @return <code>true</code> if the byte is either a space or tab character */ private static boolean isWhitespace(final int b) { return b == SPACE || b == TAB; } /** * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.', "printable = PRINTABLE_CHARS; } ByteArrayOutputStream buffer = new ByteArrayOutputStream(); int pos = 1; // encode up to buffer.length - 3, the last three octets will be treated // separately for simplification of note #3 for (int i = 0; i < bytes.length - 3; i++) { int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { // up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { // rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); // rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } // rule #3: whitespace at the end of a line *must* be encoded // if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytes.length - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); // note #3: '=' *must not* be the ultimate or penultimate character // simplification: if < 6 bytes left, do a soft line break as we may need // exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytes.length - 2; i < bytes.length; i++) { b = getUnsignedOctet(i, bytes); // rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); } return buffer.toByteArray(); }", 'if (b == ESCAPE_CHAR) { try { // if the next octet is a CR we have found a soft line break if (bytes[++i] == CR) { continue; } int u = Utils.digit16(bytes[i]); int l = Utils.digit16(bytes[++i]); buffer.write((char) ((u << 4) + l)); } catch (ArrayIndexOutOfBoundsException e) { throw new DecoderException("Invalid quoted-printable encoding", e); } } else if (b != CR && b != LF) { // every other octet is appended except for CR & LF buffer.write(b); }'], ['', 'private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {', '', '', '', 'for (byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); encodeQuotedPrintable(b, buffer);', 'int u = Utils.digit16(bytes[++i]); } else {'], ['private static final byte CR = 13; private static final byte LF = 10; private static final int SAFE_LENGTH = 73;', 'private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) { return 3;', 'private static int getUnsignedOctet(final int index, final byte[] bytes) { int b = bytes[index]; if (b < 0) { b = 256 + b; } return b; }', 'private static int encodeByte(final int b, final boolean encode, final ByteArrayOutputStream buffer) { if (encode) { return encodeQuotedPrintable(b, buffer); } else { buffer.write(b); return 1; } }', 'private static boolean isWhitespace(final int b) { return b == SPACE || b == TAB; }', 'int pos = 1; for (int i = 0; i < bytes.length - 3; i++) { int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { pos += encodeByte(b, !printable.get(b), buffer); encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; int b = getUnsignedOctet(bytes.length - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytes.length - 2; i < bytes.length; i++) { b = getUnsignedOctet(i, bytes); encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); }', 'if (bytes[++i] == CR) { continue; } int u = Utils.digit16(bytes[i]); } else if (b != CR && b != LF) {'], 'a/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java', 'b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java']
['Codec-12', 2, 2, 2, 2, ['* * @throws IllegalArgumentException if the provided skip length is negative */ // skip in chunks of 512 bytes /** * {@inheritDoc}', '* @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>, * <code>1</code> otherwise */ // Note: the logic is similar to the InflaterInputStream: // as long as we have not reached EOF, indicate that there is more // data available. As we do not know for sure how much data is left, // just return 1 as a safe guess. // use the EOF flag of the underlying codec instance }'], ['* * @throws IllegalArgumentException if the provided skip length is negative */ @Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length"); } // skip in chunks of 512 bytes final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; } /** * {@inheritDoc}', '* @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>, * <code>1</code> otherwise */ public int available() throws IOException { // Note: the logic is similar to the InflaterInputStream: // as long as we have not reached EOF, indicate that there is more // data available. As we do not know for sure how much data is left, // just return 1 as a safe guess. // use the EOF flag of the underlying codec instance if (baseNCodec.eof) { return 0; } else { return 1; } } }'], ['', ''], ['@Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length"); } final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; }', 'public int available() throws IOException { if (baseNCodec.eof) { return 0; } else { return 1; } }'], 'a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java', 'b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java']
['Codec-13', 3, 4, 4, 4, ['* @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null} * @since 1.10 */ /** * Calls {@link String#getBytes(Charset)}', ' import org.apache.commons.codec.EncoderException; import org.apache.commons.codec.StringEncoder; /** * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence', '* {@code false} otherwise. */ public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) { return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate)); } /**'], ['package org.apache.commons.codec.binary; /** * <p> * Operations on {@link CharSequence} that are {@code null} safe. * </p> * <p> * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release). * </p> * * @see CharSequence * @since 1.10 */ public class CharSequenceUtils { /** * Green implementation of regionMatches. * * @param cs * the {@code CharSequence} to be processed * @param ignoreCase * whether or not to be case insensitive * @param thisStart * the index to start on the {@code cs} CharSequence * @param substring * the {@code CharSequence} to be looked for * @param start * the index to start on the {@code substring} CharSequence * @param length * character length of the region * @return whether the region matched */ static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { if (cs instanceof String && substring instanceof String) { return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); } int index1 = thisStart; int index2 = start; int tmpLen = length; while (tmpLen-- > 0) { char c1 = cs.charAt(index1++); char c2 = substring.charAt(index2++); if (c1 == c2) { continue; } if (!ignoreCase) { return false; } // The same check as in String.regionMatches(): if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { return false; } } return true; } }', '* @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null} * @since 1.10 */ public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); } /** * Calls {@link String#getBytes(Charset)}', ' import org.apache.commons.codec.EncoderException; import org.apache.commons.codec.StringEncoder; import org.apache.commons.codec.binary.StringUtils; /** * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence', '* {@code false} otherwise. */ public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) { return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate)); } /**'], ['', '', '', 'return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));'], ['package org.apache.commons.codec.binary; /** * <p> * Operations on {@link CharSequence} that are {@code null} safe. * </p> * <p> * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release). * </p> * * @see CharSequence * @since 1.10 */ public class CharSequenceUtils { /** * Green implementation of regionMatches. * * @param cs * the {@code CharSequence} to be processed * @param ignoreCase * whether or not to be case insensitive * @param thisStart * the index to start on the {@code cs} CharSequence * @param substring * the {@code CharSequence} to be looked for * @param start * the index to start on the {@code substring} CharSequence * @param length * character length of the region * @return whether the region matched */ static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { if (cs instanceof String && substring instanceof String) { return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); } int index1 = thisStart; int index2 = start; int tmpLen = length; while (tmpLen-- > 0) { char c1 = cs.charAt(index1++); char c2 = substring.charAt(index2++); if (c1 == c2) { continue; } if (!ignoreCase) { return false; } // The same check as in String.regionMatches(): if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { return false; } } return true; } }', 'public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); }', 'import org.apache.commons.codec.binary.StringUtils;', 'return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));'], 'a/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java', 'b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java']
['Codec-14', 5, 8, 8, 8, [' private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class); private static final String LANGUAGE_RULES_RN = "org/apache/commons/codec/language/bm/lang.txt"; static { for (final NameType s : NameType.values()) { Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s))); } }', 'import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TreeSet; import org.apache.commons.codec.language.bm.Languages.LanguageSet; import org.apache.commons.codec.language.bm.Rule.Phoneme;', 'return phonemeBuilder; } final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR); for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) { PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());', '// the phonemes map orders the phonemes only based on their text, but ignores the language set // when adding new phonemes, check for equal phonemes and merge their language set, otherwise // phonemes with the same text but different language set get lost phonemes.addAll(subBuilder.getPhonemes()); } return new PhonemeBuilder(phonemes); } /**', '* @param lang the language set to merge * @return a new Phoneme */ @Override public String toString() {'], [' private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class); private static final String LANGUAGE_RULES_RN = "org/apache/commons/codec/language/bm/%s_lang.txt"; static { for (final NameType s : NameType.values()) { Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s))); } }', 'import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TreeMap; import org.apache.commons.codec.language.bm.Languages.LanguageSet; import org.apache.commons.codec.language.bm.Rule.Phoneme;', 'return phonemeBuilder; } final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR); for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) { PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());', '// the phonemes map orders the phonemes only based on their text, but ignores the language set // when adding new phonemes, check for equal phonemes and merge their language set, otherwise // phonemes with the same text but different language set get lost for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) { if (phonemes.containsKey(newPhoneme)) { final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme); final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages()); phonemes.put(mergedPhoneme, mergedPhoneme); } else { phonemes.put(newPhoneme, newPhoneme); } } } return new PhonemeBuilder(phonemes.keySet()); } /**', '* @param lang the language set to merge * @return a new Phoneme */ public Phoneme mergeWithLanguage(final LanguageSet lang) { return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang)); } @Override public String toString() {', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // ASHKENAZIC // 1. following are rules to accept the language // 1.1 Special letter combinations zh polish+russian+german+english true eau french true [aoeiu]h german true ^vogel german, true vogel$ german true witz german true tz$ german+russian+english true ^tz russian+english true ge spanish true gi spanish true ghe romanian true ghi romanian true vici$ romanian true schi$ romanian true chsch german true tsch german true ssch german true sch$ german+russian true ^sch german+russian true ^rz polish true rz$ polish+german true [^aoeiu]rz polish true rz[^aoeiu] polish true cki$ polish true ska$ polish true cka$ polish true ue german+russian true ae german+russian+english true oe german+french+russian+english true th$ german true ^th german true th[^aoeiu] german true mann german true cz polish true cy polish true niew polish true stein german true heim$ german true heimer$ german true ii$ russian true iy$ russian true yy$ russian true yi$ russian true yj$ russian true ij$ russian true gaus$ russian true gauz$ russian true gauz$ russian true goltz$ russian true gol\'tz$ russian true golts$ russian true gol\'ts$ russian true ^goltz russian true ^gol\'tz russian true ^golts russian true ^gol\'ts russian true gendler$ russian true gejmer$ russian true gejm$ russian true geimer$ russian true geim$ russian true geymer russian true geym$ russian true gof$ russian true thal german true zweig german true ck$ german+english true c$ polish+romanian+hungarian true sz polish+hungarian true gue spanish+french true gui spanish+french true guy french true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german true gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian true ly hungarian+russian+polish true ny hungarian+russian+polish true ty hungarian+russian+polish true // 1.2 special characters  romanian+french true  romanian true  french true  german true  hungarian+spanish true  polish true  polish true  french true  polish true  french+hungarian+spanish true  french true  french true  hungarian+spanish true  romanian+french true  polish true  polish true  spanish true  polish+hungarian+spanish true  german+hungarian true  hungarian true  romanian true  polish true  romanian true  german+hungarian true  french true  hungarian true  hungarian+spanish true  polish true  polish true  german true // Every Cyrillic word has at least one Cyrillic vowel ()  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true // Hebrew  hebrew true  hebrew true  ebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew false o cyrillic+hebrew false e cyrillic+hebrew false i cyrillic+hebrew false y cyrillic+hebrew+romanian false u cyrillic+hebrew false v[^aoeiu] german false // in german "v" can be found before a vowel only y[^aoeiu] german false // in german "y" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french false ou german false aj german+english+french false ej german+english+french false oj german+english+french false uj german+english+french false k romanian false v polish false ky polish false eu russian+polish false w french+romanian+spanish+hungarian+russian false kie french+spanish false gie french+romanian+spanish false q hungarian+polish+russian+romanian false sch hungarian+polish+french+spanish false ^h russian false', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // GENERIC // 1. following are rules to accept the language // 1.1 Special letter combinations ^o english true ^o\' english true ^mc english true ^fitz english true ceau french+romanian true eau romanian true eau$ french true // mp: I\'ve added this eaux$ french true // mp: I\'ve added this ault$ french true oult$ french true eux$ french true eix$ french true glou$ greeklatin true uu dutch true tx spanish true witz german true tz$ german+russian+english true ^tz russian+english true poulos$ greeklatin true pulos$ greeklatin true iou greeklatin true sj$ dutch true ^sj dutch true ge spanish true gi spanish true ghe romanian+greeklatin true ghi romanian+greeklatin true escu$ romanian true esco$ romanian true vici$ romanian true schi$ romanian true ii$ russian true iy$ russian true yy$ russian true yi$ russian true ^rz polish true rz$ polish+german true [bcdfgklmnpstwz]rz polish true rz[bcdfghklmnpstw] polish true cki$ polish true ska$ polish true cka$ polish true ae german+russian+english true oe german+french+russian+english+dutch true th$ german+english true ^th german+english+greeklatin true mann german true cz polish true cy polish+greeklatin true niew polish true etti$ italian true eti$ italian true ati$ italian true ato$ italian true [aoei]no$ italian true [aoei]ni$ italian true esi$ italian true oli$ italian true field$ english true stein german true heim$ german true heimer$ german true thal german true zweig german true [aeou]h german true h german true h german true h german true [ln]h[ao]$ portuguese true [ln]h[aou] portuguese+french+german+dutch+czech+spanish+turkish true chsch german true tsch german true sch$ german+russian true ^sch german+russian true ck$ german+english true c$ polish+romanian+hungarian+czech+turkish true sz polish+hungarian true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german+dutch true gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian+french+greeklatin true guy french true gu[ei] spanish+french+portuguese true gu[ao] spanish+portuguese true gi[aou] italian+greeklatin true ly hungarian+russian+polish+greeklatin true ny hungarian+russian+polish+spanish+greeklatin true ty hungarian+russian+polish+greeklatin true // 1.2 special characters  polish true  french+spanish+portuguese+turkish true  czech true  czech true  turkish true  polish true  polish true  spanish true  czech true  czech true  polish true  romanian+turkish true  czech true  romanian true  czech true  polish true  polish true  german true  german true  hungarian+spanish+portuguese+czech+greeklatin true  romanian+french+portuguese true  romanian true  polish true  portuguese true  portuguese true  polish true  french+hungarian+czech+greeklatin true  french+spanish+italian true  french true  czech true  french+portuguese true  hungarian+spanish+portuguese+czech+greeklatin true  romanian+french true  turkish true  polish+hungarian+spanish+italian+portuguese+czech+greeklatin true  german+hungarian+turkish true  french+portuguese true  portuguese+hungarian true  italian+spanish true  hungarian true  hungarian+spanish+portuguese+czech+greeklatin true  german+hungarian+spanish+portuguese+turkish true  french true  czech true  czech+greeklatin true // Every Cyrillic word has at least one Cyrillic vowel ()  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true // Every Greek word has at least one Greek vowel  greek true  greek true  greek true  greek true  greek true  greek true  greek true // Arabic (only initial)  arabic true // alif (isol + init)  arabic true // ba\'  arabic true // ta\'  arabic true // tha\'  arabic true // jim  arabic true // h.a\' \' arabic true // kha\'  arabic true // dal (isol + init)  arabic true // dhal (isol + init)  arabic true // ra\' (isol + init)  arabic true // za\' (isol + init)  arabic true // sin  arabic true // shin  arabic true // s.ad  arabic true // d.ad  arabic true // t.a\'  arabic true // z.a\'  arabic true // \'ayn  arabic true // ghayn  arabic true // fa\'  arabic true // qaf  arabic true // kaf  arabic true // lam  arabic true // mim  arabic true // nun  arabic true // ha\'  arabic true // waw (isol + init)  arabic true // ya\'  arabic true // alif madda  arabic true // alif + diacritic  arabic true // alif + hamza  arabic true // waw + hamza  arabic true // ya\' + hamza  arabic true // ligature l+a // Hebrew  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew+greek+arabic false o cyrillic+hebrew+greek+arabic false e cyrillic+hebrew+greek+arabic false i cyrillic+hebrew+greek+arabic false y cyrillic+hebrew+greek+arabic+romanian+dutch false u cyrillic+hebrew+greek+arabic false j italian false j[^aoeiuy] french+spanish+portuguese+greeklatin false g czech false k romanian+spanish+portuguese+french+italian false q hungarian+polish+russian+romanian+czech+dutch+turkish+greeklatin false v polish false w french+romanian+spanish+hungarian+russian+czech+turkish+greeklatin false x czech+hungarian+dutch+turkish false // polish excluded from the list dj spanish+turkish false v[^aoeiu] german false // in german, "v" can be found before a vowel only y[^aoeiu] german false // in german, "y" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french+turkish false ou german false a[eiou] turkish false // no diphthongs in Turkish [eaiou] turkish false [eaiou] turkish false e[aiou] turkish false i[aeou] turkish false o[aieu] turkish false u[aieo] turkish false aj german+english+french+dutch false ej german+english+french+dutch false oj german+english+french+dutch false uj german+english+french+dutch false eu russian+polish false ky polish false kie french+spanish+greeklatin false gie portuguese+romanian+spanish+greeklatin false ch[aou] italian false ch turkish false son$ german false sc[ei] french false sch hungarian+polish+french+spanish false ^h russian false', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // SEPHARDIC // 1. following are rules to accept the language // 1.1 Special letter combinations eau french true ou french true gni italian+french true tx spanish true tj spanish true gy french true guy french true sh spanish+portuguese true // English, but no sign for /sh/ in these languages lh portuguese true nh portuguese true ny spanish true gue spanish+french true gui spanish+french true gia italian true gie italian true gio italian true giu italian true // 1.2 special characters  spanish true  portuguese+french true  portuguese+spanish true  portuguese true  portuguese true  french+portuguese true  portuguese+spanish true  french true  french+portuguese true  portuguese true  italian+spanish true  portuguese+spanish true  french true  portuguese+spanish true // Hebrew  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a hebrew false o hebrew false e hebrew false i hebrew false y hebrew false u hebrew false kh spanish false gua italian false guo italian false  italian false cha italian false cho italian false chu italian false j italian false dj spanish false sce french false sci french false  french false  portuguese false'], ['private static final String LANGUAGE_RULES_RN = "org/apache/commons/codec/language/bm/lang.txt"; Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));', 'import java.util.TreeSet;', 'final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);', 'phonemes.addAll(subBuilder.getPhonemes()); return new PhonemeBuilder(phonemes);', '', '', '', ''], ['private static final String LANGUAGE_RULES_RN = "org/apache/commons/codec/language/bm/%s_lang.txt"; Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));', 'import java.util.TreeMap;', 'final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);', 'for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) { if (phonemes.containsKey(newPhoneme)) { final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme); final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages()); phonemes.put(mergedPhoneme, mergedPhoneme); } else { phonemes.put(newPhoneme, newPhoneme); } } return new PhonemeBuilder(phonemes.keySet());', 'public Phoneme mergeWithLanguage(final LanguageSet lang) { return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang)); }', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // ASHKENAZIC // 1. following are rules to accept the language // 1.1 Special letter combinations zh polish+russian+german+english true eau french true [aoeiu]h german true ^vogel german, true vogel$ german true witz german true tz$ german+russian+english true ^tz russian+english true ge spanish true gi spanish true ghe romanian true ghi romanian true vici$ romanian true schi$ romanian true chsch german true tsch german true ssch german true sch$ german+russian true ^sch german+russian true ^rz polish true rz$ polish+german true [^aoeiu]rz polish true rz[^aoeiu] polish true cki$ polish true ska$ polish true cka$ polish true ue german+russian true ae german+russian+english true oe german+french+russian+english true th$ german true ^th german true th[^aoeiu] german true mann german true cz polish true cy polish true niew polish true stein german true heim$ german true heimer$ german true ii$ russian true iy$ russian true yy$ russian true yi$ russian true yj$ russian true ij$ russian true gaus$ russian true gauz$ russian true gauz$ russian true goltz$ russian true gol\'tz$ russian true golts$ russian true gol\'ts$ russian true ^goltz russian true ^gol\'tz russian true ^golts russian true ^gol\'ts russian true gendler$ russian true gejmer$ russian true gejm$ russian true geimer$ russian true geim$ russian true geymer russian true geym$ russian true gof$ russian true thal german true zweig german true ck$ german+english true c$ polish+romanian+hungarian true sz polish+hungarian true gue spanish+french true gui spanish+french true guy french true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german true gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian true ly hungarian+russian+polish true ny hungarian+russian+polish true ty hungarian+russian+polish true // 1.2 special characters  romanian+french true  romanian true  french true  german true  hungarian+spanish true  polish true  polish true  french true  polish true  french+hungarian+spanish true  french true  french true  hungarian+spanish true  romanian+french true  polish true  polish true  spanish true  polish+hungarian+spanish true  german+hungarian true  hungarian true  romanian true  polish true  romanian true  german+hungarian true  french true  hungarian true  hungarian+spanish true  polish true  polish true  german true // Every Cyrillic word has at least one Cyrillic vowel ()  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true // Hebrew  hebrew true  hebrew true  ebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew false o cyrillic+hebrew false e cyrillic+hebrew false i cyrillic+hebrew false y cyrillic+hebrew+romanian false u cyrillic+hebrew false v[^aoeiu] german false // in german "v" can be found before a vowel only y[^aoeiu] german false // in german "y" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french false ou german false aj german+english+french false ej german+english+french false oj german+english+french false uj german+english+french false k romanian false v polish false ky polish false eu russian+polish false w french+romanian+spanish+hungarian+russian false kie french+spanish false gie french+romanian+spanish false q hungarian+polish+russian+romanian false sch hungarian+polish+french+spanish false ^h russian false', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // GENERIC // 1. following are rules to accept the language // 1.1 Special letter combinations ^o english true ^o\' english true ^mc english true ^fitz english true ceau french+romanian true eau romanian true eau$ french true // mp: I\'ve added this eaux$ french true // mp: I\'ve added this ault$ french true oult$ french true eux$ french true eix$ french true glou$ greeklatin true uu dutch true tx spanish true witz german true tz$ german+russian+english true ^tz russian+english true poulos$ greeklatin true pulos$ greeklatin true iou greeklatin true sj$ dutch true ^sj dutch true ge spanish true gi spanish true ghe romanian+greeklatin true ghi romanian+greeklatin true escu$ romanian true esco$ romanian true vici$ romanian true schi$ romanian true ii$ russian true iy$ russian true yy$ russian true yi$ russian true ^rz polish true rz$ polish+german true [bcdfgklmnpstwz]rz polish true rz[bcdfghklmnpstw] polish true cki$ polish true ska$ polish true cka$ polish true ae german+russian+english true oe german+french+russian+english+dutch true th$ german+english true ^th german+english+greeklatin true mann german true cz polish true cy polish+greeklatin true niew polish true etti$ italian true eti$ italian true ati$ italian true ato$ italian true [aoei]no$ italian true [aoei]ni$ italian true esi$ italian true oli$ italian true field$ english true stein german true heim$ german true heimer$ german true thal german true zweig german true [aeou]h german true h german true h german true h german true [ln]h[ao]$ portuguese true [ln]h[aou] portuguese+french+german+dutch+czech+spanish+turkish true chsch german true tsch german true sch$ german+russian true ^sch german+russian true ck$ german+english true c$ polish+romanian+hungarian+czech+turkish true sz polish+hungarian true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german+dutch true gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian+french+greeklatin true guy french true gu[ei] spanish+french+portuguese true gu[ao] spanish+portuguese true gi[aou] italian+greeklatin true ly hungarian+russian+polish+greeklatin true ny hungarian+russian+polish+spanish+greeklatin true ty hungarian+russian+polish+greeklatin true // 1.2 special characters  polish true  french+spanish+portuguese+turkish true  czech true  czech true  turkish true  polish true  polish true  spanish true  czech true  czech true  polish true  romanian+turkish true  czech true  romanian true  czech true  polish true  polish true  german true  german true  hungarian+spanish+portuguese+czech+greeklatin true  romanian+french+portuguese true  romanian true  polish true  portuguese true  portuguese true  polish true  french+hungarian+czech+greeklatin true  french+spanish+italian true  french true  czech true  french+portuguese true  hungarian+spanish+portuguese+czech+greeklatin true  romanian+french true  turkish true  polish+hungarian+spanish+italian+portuguese+czech+greeklatin true  german+hungarian+turkish true  french+portuguese true  portuguese+hungarian true  italian+spanish true  hungarian true  hungarian+spanish+portuguese+czech+greeklatin true  german+hungarian+spanish+portuguese+turkish true  french true  czech true  czech+greeklatin true // Every Cyrillic word has at least one Cyrillic vowel ()  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true  cyrillic true // Every Greek word has at least one Greek vowel  greek true  greek true  greek true  greek true  greek true  greek true  greek true // Arabic (only initial)  arabic true // alif (isol + init)  arabic true // ba\'  arabic true // ta\'  arabic true // tha\'  arabic true // jim  arabic true // h.a\' \' arabic true // kha\'  arabic true // dal (isol + init)  arabic true // dhal (isol + init)  arabic true // ra\' (isol + init)  arabic true // za\' (isol + init)  arabic true // sin  arabic true // shin  arabic true // s.ad  arabic true // d.ad  arabic true // t.a\'  arabic true // z.a\'  arabic true // \'ayn  arabic true // ghayn  arabic true // fa\'  arabic true // qaf  arabic true // kaf  arabic true // lam  arabic true // mim  arabic true // nun  arabic true // ha\'  arabic true // waw (isol + init)  arabic true // ya\'  arabic true // alif madda  arabic true // alif + diacritic  arabic true // alif + hamza  arabic true // waw + hamza  arabic true // ya\' + hamza  arabic true // ligature l+a // Hebrew  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew+greek+arabic false o cyrillic+hebrew+greek+arabic false e cyrillic+hebrew+greek+arabic false i cyrillic+hebrew+greek+arabic false y cyrillic+hebrew+greek+arabic+romanian+dutch false u cyrillic+hebrew+greek+arabic false j italian false j[^aoeiuy] french+spanish+portuguese+greeklatin false g czech false k romanian+spanish+portuguese+french+italian false q hungarian+polish+russian+romanian+czech+dutch+turkish+greeklatin false v polish false w french+romanian+spanish+hungarian+russian+czech+turkish+greeklatin false x czech+hungarian+dutch+turkish false // polish excluded from the list dj spanish+turkish false v[^aoeiu] german false // in german, "v" can be found before a vowel only y[^aoeiu] german false // in german, "y" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french+turkish false ou german false a[eiou] turkish false // no diphthongs in Turkish [eaiou] turkish false [eaiou] turkish false e[aiou] turkish false i[aeou] turkish false o[aieu] turkish false u[aieo] turkish false aj german+english+french+dutch false ej german+english+french+dutch false oj german+english+french+dutch false uj german+english+french+dutch false eu russian+polish false ky polish false kie french+spanish+greeklatin false gie portuguese+romanian+spanish+greeklatin false ch[aou] italian false ch turkish false son$ german false sc[ei] french false sch hungarian+polish+french+spanish false ^h russian false', '/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // SEPHARDIC // 1. following are rules to accept the language // 1.1 Special letter combinations eau french true ou french true gni italian+french true tx spanish true tj spanish true gy french true guy french true sh spanish+portuguese true // English, but no sign for /sh/ in these languages lh portuguese true nh portuguese true ny spanish true gue spanish+french true gui spanish+french true gia italian true gie italian true gio italian true giu italian true // 1.2 special characters  spanish true  portuguese+french true  portuguese+spanish true  portuguese true  portuguese true  french+portuguese true  portuguese+spanish true  french true  french+portuguese true  portuguese true  italian+spanish true  portuguese+spanish true  french true  portuguese+spanish true // Hebrew  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true  hebrew true // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a hebrew false o hebrew false e hebrew false i hebrew false y hebrew false u hebrew false kh spanish false gua italian false guo italian false  italian false cha italian false cho italian false chu italian false j italian false dj spanish false sce french false sci french false  french false  portuguese false'], 'a/src/main/resources/org/apache/commons/codec/language/bm/sep_lang.txt\t2020-01-24 12:25:47.065255433 -0800', 'b/src/main/resources/org/apache/commons/codec/language/bm/sep_lang.txt\t1969-12-31 16:00:00.000000000 -0800']
['Codec-15', 1, 1, 1, 1, ["final char mappedChar = this.map(str.charAt(index)); // HW rule check if (index > 1 && mappedChar != '0') { final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == hwChar) { final char preHWChar = str.charAt(index - 2); final char firstCode = this.map(preHWChar); if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) { return 0; } } } return mappedChar;"], ["final char mappedChar = this.map(str.charAt(index)); // HW rule check if (index > 1 && mappedChar != '0') { for (int i=index-1 ; i>=0 ; i--) { final char prevChar = str.charAt(i); if (this.map(prevChar)==mappedChar) { return 0; } if ('H'!=prevChar && 'W'!=prevChar) { break; } } } return mappedChar;"], ["final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == hwChar) { final char preHWChar = str.charAt(index - 2); final char firstCode = this.map(preHWChar); if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {"], ["for (int i=index-1 ; i>=0 ; i--) { final char prevChar = str.charAt(i); if (this.map(prevChar)==mappedChar) { if ('H'!=prevChar && 'W'!=prevChar) { break; }"], 'a/src/main/java/org/apache/commons/codec/language/Soundex.java', 'b/src/main/java/org/apache/commons/codec/language/Soundex.java']
['Codec-16', 1, 1, 1, 1, ['-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7 -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O 25, 26, 27, 28, 29, 30, 31, 32, }; /**'], ['-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7 -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O 25, 26, 27, 28, 29, 30, 31, // 50-57 P-V }; /**'], ['25, 26, 27, 28, 29, 30, 31, 32,'], ['25, 26, 27, 28, 29, 30, 31, // 50-57 P-V'], 'a/src/main/java/org/apache/commons/codec/binary/Base32.java', 'b/src/main/java/org/apache/commons/codec/binary/Base32.java']
['Codec-17', 1, 1, 1, 1, ['* @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException */ public static String newStringIso8859_1(final byte[] bytes) { return new String(bytes, Charsets.ISO_8859_1); } /**'], ['* @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException */ public static String newStringIso8859_1(final byte[] bytes) { return newString(bytes, Charsets.ISO_8859_1); } /**'], ['return new String(bytes, Charsets.ISO_8859_1);'], ['return newString(bytes, Charsets.ISO_8859_1);'], 'a/src/main/java/org/apache/commons/codec/binary/StringUtils.java', 'b/src/main/java/org/apache/commons/codec/binary/StringUtils.java']
['Codec-18', 1, 1, 1, 1, ['if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); } /**'], ['if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); } /**'], ['return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));'], ['return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());'], 'a/src/main/java/org/apache/commons/codec/binary/StringUtils.java', 'b/src/main/java/org/apache/commons/codec/binary/StringUtils.java']
['Jsoup-1', 1, 1, 1, 1, [' for (Node node: toMove) { element.removeChild(node); body().appendChild(new TextNode(" ", "")); body().appendChild(node); } }'], [' for (Node node: toMove) { element.removeChild(node); body().prependChild(node); body().prependChild(new TextNode(" ", "")); } }'], ['body().appendChild(new TextNode(" ", "")); body().appendChild(node);'], ['body().prependChild(node); body().prependChild(new TextNode(" ", ""));'], 'a/src/main/java/org/jsoup/nodes/Document.java', 'b/src/main/java/org/jsoup/nodes/Document.java']
['Jsoup-2', 1, 1, 1, 1, ['if (tag.isData()) { String data = tq.chompTo("</" + tagName); tq.chompTo(">"); Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)'], ['if (tag.isData()) { String data = tq.chompTo("</" + tagName); tq.chompTo(">"); popStackToClose(tag); Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)'], [''], ['popStackToClose(tag);'], 'a/src/main/java/org/jsoup/parser/Parser.java', 'b/src/main/java/org/jsoup/parser/Parser.java']
['Jsoup-3', 13, 13, 13, 13, ['public Element append(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body(); for (Node node : fragment.childNodes()) { node.parentNode = null; appendChild(node);', 'public Element prepend(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body(); List<Node> nodes = fragment.childNodes(); for (int i = nodes.size() - 1; i >= 0; i--) { Node node = nodes.get(i);', 'public Element wrap(String html) { Validate.notEmpty(html); Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); Elements wrapChildren = wrapBody.children(); Element wrap = wrapChildren.first(); if (wrap == null) // nothing to wrap with; noop', 'private final TokenQueue tq; private final Document doc; private String baseUri; private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html);', '@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body */ private Document parse() { while (!tq.isEmpty()) {', 'Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); if (!validAncestor) { // create implicit parent around this child Tag parentTag = childTag.getImplicitParent(); Element implicit = new Element(parentTag, baseUri);', 'if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node // otherwise, look up the stack for valid ancestors for (int i = stack.size() -1; i >= 0; i--) { Element el = stack.get(i); Tag parent2 = el.tag(); if (parent2.isValidParent(childTag)) { return true; } }', 'private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag(String tagName) { this.tagName = tagName.toLowerCase();', "return false; // don't allow children to contain their parent (directly) return true; }", 'return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean isValidParent(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag', 'createBlock("TITLE").setAncestor("HEAD", "BODY").setContainDataOnly(); createInline("BASE").setAncestor("HEAD", "BODY").setEmpty(); createBlock("FRAME").setAncestor("FRAMESET").setEmpty(); createBlock("NOFRAMES").setAncestor("FRAMESET").setContainDataOnly();', 'createInline("TEXTAREA").setAncestor("FORM").setContainDataOnly(); createInline("LABEL").setAncestor("FORM").setOptionalClosing(); // not self createInline("BUTTON").setAncestor("FORM"); // bunch of excludes not defined createInline("OPTGROUP").setAncestor("SELECT"); createInline("OPTION").setAncestor("SELECT").setContainDataOnly(); createBlock("FIELDSET").setAncestor("FORM"); createInline("LEGEND").setAncestor("FIELDSET"); // other createInline("AREA").setEmpty(); // not an inline per-se createInline("PARAM").setAncestor("OBJECT").setEmpty(); createBlock("INS"); // only within body createBlock("DEL"); // only within body createBlock("DL"); createInline("DT").setAncestor("DL").setOptionalClosing(); createInline("DD").setAncestor("DL").setOptionalClosing(); createBlock("LI").setAncestor("UL", "OL").setOptionalClosing(); // only within OL or UL. // tables createBlock("TABLE"); // specific list of only includes (tr, td, thead etc) not implemented createBlock("CAPTION").setAncestor("TABLE"); createBlock("THEAD").setAncestor("TABLE").setOptionalClosing(); createBlock("TFOOT").setAncestor("TABLE").setOptionalClosing(); createBlock("TBODY").setAncestor("TABLE").setOptionalClosing(); createBlock("COLGROUP").setAncestor("TABLE").setOptionalClosing(); createBlock("COL").setAncestor("COLGROUP").setEmpty(); createBlock("TR").setAncestor("TABLE").setOptionalClosing(); createBlock("TH").setAncestor("TR").setOptionalClosing(); createBlock("TD").setAncestor("TR").setOptionalClosing(); } private static Tag createBlock(String tagName) {', 'return this; } }'], ['public Element append(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body(); for (Node node : fragment.childNodes()) { node.parentNode = null; appendChild(node);', 'public Element prepend(String html) { Validate.notNull(html); Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body(); List<Node> nodes = fragment.childNodes(); for (int i = nodes.size() - 1; i >= 0; i--) { Node node = nodes.get(i);', 'public Element wrap(String html) { Validate.notEmpty(html); Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body(); Elements wrapChildren = wrapBody.children(); Element wrap = wrapChildren.first(); if (wrap == null) // nothing to wrap with; noop', 'private final TokenQueue tq; private final Document doc; private String baseUri; private boolean relaxed = false; private Parser(String html, String baseUri, boolean isBodyFragment) { Validate.notNull(html);', '@param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs. @return Document, with empty head, and HTML parsed into body */ public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); parser.relaxed = true; return parser.parse(); } private Document parse() { while (!tq.isEmpty()) {', 'Tag childTag = child.tag(); boolean validAncestor = stackHasValidParent(childTag); if (!validAncestor && !relaxed) { // create implicit parent around this child Tag parentTag = childTag.getImplicitParent(); Element implicit = new Element(parentTag, baseUri);', 'if (stack.size() == 1 && childTag.equals(htmlTag)) return true; // root is valid for html node if (childTag.requiresSpecificParent()) return stack.getLast().tag().isValidParent(childTag); // otherwise, look up the stack for valid ancestors for (int i = stack.size() -1; i >= 0; i--) { Element el = stack.get(i); Tag parent2 = el.tag(); if (parent2.isValidAncestor(childTag)) { return true; } }', 'private boolean empty = false; // can hold nothing; e.g. img private boolean preserveWhitespace = false; // for pre, textarea, script etc private List<Tag> ancestors; // elements must be a descendant of one of these ancestors private Tag parent; // if not null, elements must be a direct child of parent private Tag(String tagName) { this.tagName = tagName.toLowerCase();', "return false; // don't allow children to contain their parent (directly) if (this.requiresSpecificParent() && this.getImplicitParent().equals(child)) return false; return true; }", 'return (!ancestors.isEmpty()) ? ancestors.get(0) : null; } boolean requiresSpecificParent() { return this.parent != null; } boolean isValidParent(Tag child) { return this.equals(child.parent); } boolean isValidAncestor(Tag child) { if (child.ancestors.isEmpty()) return true; // HTML tag', 'createBlock("TITLE").setAncestor("HEAD", "BODY").setContainDataOnly(); createInline("BASE").setAncestor("HEAD", "BODY").setEmpty(); createBlock("FRAME").setParent("FRAMESET").setEmpty(); createBlock("NOFRAMES").setParent("FRAMESET").setContainDataOnly();', 'createInline("TEXTAREA").setAncestor("FORM").setContainDataOnly(); createInline("LABEL").setAncestor("FORM").setOptionalClosing(); // not self createInline("BUTTON").setAncestor("FORM"); // bunch of excludes not defined createInline("OPTGROUP").setParent("SELECT"); // only contain option createInline("OPTION").setParent("SELECT").setContainDataOnly(); createBlock("FIELDSET").setAncestor("FORM"); createInline("LEGEND").setAncestor("FIELDSET"); // other createInline("AREA").setEmpty(); // not an inline per-se createInline("PARAM").setParent("OBJECT").setEmpty(); createBlock("INS"); // only within body createBlock("DEL"); // only within body createBlock("DL"); createInline("DT").setParent("DL").setOptionalClosing(); // only within DL. createInline("DD").setParent("DL").setOptionalClosing(); // only within DL. createBlock("LI").setAncestor("UL", "OL").setOptionalClosing(); // only within OL or UL. // tables createBlock("TABLE"); // specific list of only includes (tr, td, thead etc) not implemented createBlock("CAPTION").setParent("TABLE"); createBlock("THEAD").setParent("TABLE").setOptionalClosing(); // just TR createBlock("TFOOT").setParent("TABLE").setOptionalClosing(); // just TR createBlock("TBODY").setParent("TABLE").setOptionalClosing(); // optional / implicit open too. just TR createBlock("COLGROUP").setParent("TABLE").setOptionalClosing(); // just COL createBlock("COL").setParent("COLGROUP").setEmpty(); createBlock("TR").setParent("TABLE").setOptionalClosing(); // just TH, TD createBlock("TH").setParent("TR").setOptionalClosing(); createBlock("TD").setParent("TR").setOptionalClosing(); } private static Tag createBlock(String tagName) {', 'return this; } private Tag setParent(String tagName) { parent = Tag.valueOf(tagName); setAncestor(tagName); return this; } }'], ['Element fragment = Parser.parseBodyFragment(html, baseUri).body();', 'Element fragment = Parser.parseBodyFragment(html, baseUri).body();', 'Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();', '', '', 'if (!validAncestor) {', 'if (parent2.isValidParent(childTag)) {', '', '', '', 'createBlock("FRAME").setAncestor("FRAMESET").setEmpty(); createBlock("NOFRAMES").setAncestor("FRAMESET").setContainDataOnly();', 'createInline("OPTGROUP").setAncestor("SELECT"); createInline("OPTION").setAncestor("SELECT").setContainDataOnly(); createInline("PARAM").setAncestor("OBJECT").setEmpty(); createInline("DT").setAncestor("DL").setOptionalClosing(); createInline("DD").setAncestor("DL").setOptionalClosing(); createBlock("CAPTION").setAncestor("TABLE"); createBlock("THEAD").setAncestor("TABLE").setOptionalClosing(); createBlock("TFOOT").setAncestor("TABLE").setOptionalClosing(); createBlock("TBODY").setAncestor("TABLE").setOptionalClosing(); createBlock("COLGROUP").setAncestor("TABLE").setOptionalClosing(); createBlock("COL").setAncestor("COLGROUP").setEmpty(); createBlock("TR").setAncestor("TABLE").setOptionalClosing(); createBlock("TH").setAncestor("TR").setOptionalClosing(); createBlock("TD").setAncestor("TR").setOptionalClosing();', ''], ['Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();', 'Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();', 'Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body();', 'private boolean relaxed = false;', 'public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) { Parser parser = new Parser(bodyHtml, baseUri, true); parser.relaxed = true; return parser.parse(); }', 'if (!validAncestor && !relaxed) {', 'if (childTag.requiresSpecificParent()) return stack.getLast().tag().isValidParent(childTag); if (parent2.isValidAncestor(childTag)) {', 'private Tag parent; // if not null, elements must be a direct child of parent', 'if (this.requiresSpecificParent() && this.getImplicitParent().equals(child)) return false;', 'boolean requiresSpecificParent() { return this.parent != null; } return this.equals(child.parent); } boolean isValidAncestor(Tag child) {', 'createBlock("FRAME").setParent("FRAMESET").setEmpty(); createBlock("NOFRAMES").setParent("FRAMESET").setContainDataOnly();', 'createInline("OPTGROUP").setParent("SELECT"); // only contain option createInline("OPTION").setParent("SELECT").setContainDataOnly(); createInline("PARAM").setParent("OBJECT").setEmpty(); createInline("DT").setParent("DL").setOptionalClosing(); // only within DL. createInline("DD").setParent("DL").setOptionalClosing(); // only within DL. createBlock("CAPTION").setParent("TABLE"); createBlock("THEAD").setParent("TABLE").setOptionalClosing(); // just TR createBlock("TFOOT").setParent("TABLE").setOptionalClosing(); // just TR createBlock("TBODY").setParent("TABLE").setOptionalClosing(); // optional / implicit open too. just TR createBlock("COLGROUP").setParent("TABLE").setOptionalClosing(); // just COL createBlock("COL").setParent("COLGROUP").setEmpty(); createBlock("TR").setParent("TABLE").setOptionalClosing(); // just TH, TD createBlock("TH").setParent("TR").setOptionalClosing(); createBlock("TD").setParent("TR").setOptionalClosing();', 'private Tag setParent(String tagName) { parent = Tag.valueOf(tagName); setAncestor(tagName); return this; }'], 'a/src/main/java/org/jsoup/parser/Tag.java', 'b/src/main/java/org/jsoup/parser/Tag.java']
['Jsoup-4', 2, 2, 2, 2, ['} catch (NumberFormatException e) { } // skip } else { String name = m.group(1).toLowerCase(); if (full.containsKey(name)) charval = full.get(name); }', ' for (Object[] entity : baseArray) { Character c = Character.valueOf((char) ((Integer) entity[1]).intValue()); baseByVal.put(c, ((String) entity[0]).toLowerCase()); } for (Object[] entity : fullArray) { Character c = Character.valueOf((char) ((Integer) entity[1]).intValue()); full.put((String) entity[0], c); fullByVal.put(c, ((String) entity[0]).toLowerCase()); } }'], ['} catch (NumberFormatException e) { } // skip } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }', ' for (Object[] entity : baseArray) { Character c = Character.valueOf((char) ((Integer) entity[1]).intValue()); baseByVal.put(c, ((String) entity[0])); } for (Object[] entity : fullArray) { Character c = Character.valueOf((char) ((Integer) entity[1]).intValue()); full.put((String) entity[0], c); fullByVal.put(c, ((String) entity[0])); } }'], ['String name = m.group(1).toLowerCase();', 'baseByVal.put(c, ((String) entity[0]).toLowerCase()); fullByVal.put(c, ((String) entity[0]).toLowerCase());'], ['String name = m.group(1);', 'baseByVal.put(c, ((String) entity[0])); fullByVal.put(c, ((String) entity[0]));'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-5', 1, 1, 1, 1, ['if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume(); return null; }'], ['if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck tq.advance(); return null; }'], ['tq.consume();'], ['if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck tq.advance();'], 'a/src/main/java/org/jsoup/parser/Parser.java', 'b/src/main/java/org/jsoup/parser/Parser.java']
['Jsoup-6', 1, 1, 1, 1, [' if (charval != -1 || charval > 0xFFFF) { // out of range String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); } } m.appendTail(accum);'], [' if (charval != -1 || charval > 0xFFFF) { // out of range String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string } } m.appendTail(accum);'], ['m.appendReplacement(accum, c); m.appendReplacement(accum, m.group(0));'], ['m.appendReplacement(accum, Matcher.quoteReplacement(c)); m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-7', 3, 3, 3, 3, [' import org.jsoup.helper.Validate; import org.jsoup.parser.Tag; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder;', 'normaliseTextNodes(htmlEl); normaliseTextNodes(this); return this; }', '} // merge multiple <head> or <body> contents into one, delete the remainder, and ensure they are owned by <html> // ensure parented by <html> // fast method to get first by tag name, used for html, head, body finders private Element findFirstElementByTagName(String tag, Node node) {'], [' import org.jsoup.helper.Validate; import org.jsoup.parser.Tag; import org.jsoup.select.Elements; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder;', 'normaliseTextNodes(htmlEl); normaliseTextNodes(this); normaliseStructure("head", htmlEl); normaliseStructure("body", htmlEl); return this; }', '} // merge multiple <head> or <body> contents into one, delete the remainder, and ensure they are owned by <html> private void normaliseStructure(String tag, Element htmlEl) { Elements elements = this.getElementsByTag(tag); Element master = elements.first(); // will always be available as created above if not existent if (elements.size() > 1) { // dupes, move contents to master List<Node> toMove = new ArrayList<Node>(); for (int i = 1; i < elements.size(); i++) { Node dupe = elements.get(i); for (Node node : dupe.childNodes) toMove.add(node); dupe.remove(); } for (Node dupe : toMove) master.appendChild(dupe); } // ensure parented by <html> if (!master.parent().equals(htmlEl)) { htmlEl.appendChild(master); // includes remove() } } // fast method to get first by tag name, used for html, head, body finders private Element findFirstElementByTagName(String tag, Node node) {'], ['', '', ''], ['import org.jsoup.select.Elements;', 'normaliseStructure("head", htmlEl); normaliseStructure("body", htmlEl);', 'private void normaliseStructure(String tag, Element htmlEl) { Elements elements = this.getElementsByTag(tag); Element master = elements.first(); // will always be available as created above if not existent if (elements.size() > 1) { // dupes, move contents to master List<Node> toMove = new ArrayList<Node>(); for (int i = 1; i < elements.size(); i++) { Node dupe = elements.get(i); for (Node node : dupe.childNodes) toMove.add(node); dupe.remove(); } for (Node dupe : toMove) master.appendChild(dupe); } if (!master.parent().equals(htmlEl)) { htmlEl.appendChild(master); // includes remove() } }'], 'a/src/main/java/org/jsoup/nodes/Document.java', 'b/src/main/java/org/jsoup/nodes/Document.java']
['Jsoup-8', 1, 1, 1, 1, ['} protected void outerHtml(StringBuilder accum) { new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this); } // if this node has no document (or parent), retrieve the default output settings /** Get the outer HTML of this node.'], ['} protected void outerHtml(StringBuilder accum) { new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this); } // if this node has no document (or parent), retrieve the default output settings private Document.OutputSettings getOutputSettings() { return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document("")).outputSettings(); } /** Get the outer HTML of this node.'], ['new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);'], ['new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this); private Document.OutputSettings getOutputSettings() { return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document("")).outputSettings(); }'], 'a/src/main/java/org/jsoup/nodes/Node.java', 'b/src/main/java/org/jsoup/nodes/Node.java']
['Jsoup-9', 1, 1, 1, 1, ['private static final Map<Character, String> xhtmlByVal; private static final Map<Character, String> baseByVal; private static final Map<Character, String> fullByVal; private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?"); static String escape(String string, Document.OutputSettings out) { return escape(string, out.encoder(), out.escapeMode());'], ['private static final Map<Character, String> xhtmlByVal; private static final Map<Character, String> baseByVal; private static final Map<Character, String> fullByVal; private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?"); static String escape(String string, Document.OutputSettings out) { return escape(string, out.encoder(), out.escapeMode());'], ['private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?");'], ['private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?");'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-10', 1, 1, 1, 1, ["return abs.toExternalForm(); } // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) {"], ['return abs.toExternalForm(); } // workaround: java resolves \'//path/file + ?foo\' to \'//path/?foo\', not \'//path/file?foo\' as desired if (relUrl.startsWith("?")) relUrl = base.getPath() + relUrl; URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) {'], [''], ['if (relUrl.startsWith("?")) relUrl = base.getPath() + relUrl;'], 'a/src/main/java/org/jsoup/nodes/Node.java', 'b/src/main/java/org/jsoup/nodes/Node.java']
['Jsoup-11', 4, 4, 4, 4, ['if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements elements.add(root); combinator(tq.consume().toString()); } else { addElements(findElements()); // chomp first element matcher off queue }', 'return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { // unhandled throw new SelectorParseException("Could not parse query \'%s\': unexpected token at \'%s\'", query, tq.remainder()); }', '} // :not(selector) // direct child descendants private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {', '} // exclude set. package open so that Elements can implement .not() selector. public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params) {'], ['if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements elements.add(root); combinator(tq.consume().toString()); } else if (tq.matches(":has(")) { elements.addAll(root.getAllElements()); } else { addElements(findElements()); // chomp first element matcher off queue }', 'return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not(); } else { // unhandled throw new SelectorParseException("Could not parse query \'%s\': unexpected token at \'%s\'", query, tq.remainder()); }', '} // :not(selector) private Elements not() { tq.consume(":not"); String subQuery = tq.chompBalanced(\'(\', \')\'); Validate.notEmpty(subQuery, ":not(selector) subselect must not be empty"); return filterOut(root.getAllElements(), select(subQuery, root)); } // direct child descendants private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {', '} // exclude set. package open so that Elements can implement .not() selector. static Elements filterOut(Collection<Element> elements, Collection<Element> outs) { Elements output = new Elements(); for (Element el: elements) { boolean found = false; for (Element out: outs) { if (el.equals(out)) { found = true; break; } } if (!found) output.add(el); } return output; } public static class SelectorParseException extends IllegalStateException { public SelectorParseException(String msg, Object... params) {'], ['', '', '', ''], ['} else if (tq.matches(":has(")) { elements.addAll(root.getAllElements());', '} else if (tq.matches(":not(")) { return not();', 'private Elements not() { tq.consume(":not"); String subQuery = tq.chompBalanced(\'(\', \')\'); Validate.notEmpty(subQuery, ":not(selector) subselect must not be empty"); return filterOut(root.getAllElements(), select(subQuery, root)); }', 'static Elements filterOut(Collection<Element> elements, Collection<Element> outs) { Elements output = new Elements(); for (Element el: elements) { boolean found = false; for (Element out: outs) { if (el.equals(out)) { found = true; break; } } if (!found) output.add(el); } return output; }'], 'a/src/main/java/org/jsoup/select/Selector.java', 'b/src/main/java/org/jsoup/select/Selector.java']
['Jsoup-12', 2, 2, 2, 2, [" private void combinator(char combinator) { tq.consumeWhitespace(); String subQuery = tq.consumeToAny(combinators); Elements output; if (combinator == '>')", 'elements.clear(); elements.addAll(output); } private Elements findElements() { if (tq.matchChomp("#")) {'], [" private void combinator(char combinator) { tq.consumeWhitespace(); String subQuery = consumeSubQuery(); // support multi > childs Elements output; if (combinator == '>')", 'elements.clear(); elements.addAll(output); } private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced(\'(\', \')\')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced(\'[\', \']\')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } private Elements findElements() { if (tq.matchChomp("#")) {'], ['String subQuery = tq.consumeToAny(combinators);', ''], ['String subQuery = consumeSubQuery(); // support multi > childs', 'private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced(\'(\', \')\')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced(\'[\', \']\')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); }'], 'a/src/main/java/org/jsoup/select/Selector.java', 'b/src/main/java/org/jsoup/select/Selector.java']
['Jsoup-13', 1, 1, 1, 1, ['public boolean hasAttr(String attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }'], ['public boolean hasAttr(String attributeKey) { Validate.notNull(attributeKey); if (attributeKey.toLowerCase().startsWith("abs:")) { String key = attributeKey.substring("abs:".length()); if (attributes.hasKey(key) && !absUrl(key).equals("")) return true; } return attributes.hasKey(attributeKey); }'], [''], ['if (attributeKey.toLowerCase().startsWith("abs:")) { String key = attributeKey.substring("abs:".length()); if (attributes.hasKey(key) && !absUrl(key).equals("")) return true; }'], 'a/src/main/java/org/jsoup/nodes/Node.java', 'b/src/main/java/org/jsoup/nodes/Node.java']
['Jsoup-14', 2, 2, 2, 2, ['return tagPending.tagName.equals(lastStartTag.tagName); } boolean isTrackErrors() { return trackErrors;', 'if (r.matches(\'/\')) { t.createTempBuffer(); t.advanceTransition(RCDATAEndTagOpen); // diverge from spec: got a start tag, but there\'s no appropriate end tag (</title>), so rather than // consuming to EOF; break out here } else { t.emit("<"); t.transition(Rcdata);'], ['return tagPending.tagName.equals(lastStartTag.tagName); } String appropriateEndTagName() { return lastStartTag.tagName; } boolean isTrackErrors() { return trackErrors;', 'if (r.matches(\'/\')) { t.createTempBuffer(); t.advanceTransition(RCDATAEndTagOpen); } else if (r.matchesLetter() && !r.containsIgnoreCase("</" + t.appropriateEndTagName())) { // diverge from spec: got a start tag, but there\'s no appropriate end tag (</title>), so rather than // consuming to EOF; break out here t.tagPending = new Token.EndTag(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); // undo "<" t.transition(Data); } else { t.emit("<"); t.transition(Rcdata);'], ['', ''], ['String appropriateEndTagName() { return lastStartTag.tagName; }', '} else if (r.matchesLetter() && !r.containsIgnoreCase("</" + t.appropriateEndTagName())) { t.tagPending = new Token.EndTag(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); // undo "<" t.transition(Data);'], 'a/src/main/java/org/jsoup/parser/TokeniserState.java', 'b/src/main/java/org/jsoup/parser/TokeniserState.java']
['Jsoup-15', 1, 1, 1, 1, ['if (!html.hasAttr(attribute.getKey())) html.attributes().put(attribute); } } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "style", "title")) { return tb.process(t, InHead); } else if (name.equals("body")) { tb.error(this);'], ['if (!html.hasAttr(attribute.getKey())) html.attributes().put(attribute); } } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "script", "style", "title")) { return tb.process(t, InHead); } else if (name.equals("body")) { tb.error(this);'], ['} else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "style", "title")) {'], ['} else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "script", "style", "title")) {'], 'a/src/main/java/org/jsoup/parser/TreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/TreeBuilderState.java']
['Jsoup-16', 3, 3, 3, 3, ['package org.jsoup.nodes; import org.jsoup.helper.StringUtil; /** * A {@code <!DOCTPYE>} node.', 'public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr("name", name); attr("publicId", publicId); attr("systemId", systemId);', ' @Override void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) { accum.append("<!DOCTYPE html"); if (!StringUtil.isBlank(attr("publicId"))) accum.append(" PUBLIC \\"").append(attr("publicId")).append("\\""); if (!StringUtil.isBlank(attr("systemId"))) accum.append(\' \').append(attr("systemId")).append("\\""); accum.append(\'>\'); }'], ['package org.jsoup.nodes; import org.jsoup.helper.StringUtil; import org.jsoup.helper.Validate; /** * A {@code <!DOCTPYE>} node.', 'public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); Validate.notEmpty(name); attr("name", name); attr("publicId", publicId); attr("systemId", systemId);', ' @Override void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) { accum.append("<!DOCTYPE ").append(attr("name")); if (!StringUtil.isBlank(attr("publicId"))) accum.append(" PUBLIC \\"").append(attr("publicId")).append("\\""); if (!StringUtil.isBlank(attr("systemId"))) accum.append(" \\"").append(attr("systemId")).append("\\""); accum.append(\'>\'); }'], ['', '', 'accum.append("<!DOCTYPE html"); accum.append(\' \').append(attr("systemId")).append("\\"");'], ['import org.jsoup.helper.Validate;', 'Validate.notEmpty(name);', 'accum.append("<!DOCTYPE ").append(attr("name")); accum.append(" \\"").append(attr("systemId")).append("\\"");'], 'a/src/main/java/org/jsoup/nodes/DocumentType.java', 'b/src/main/java/org/jsoup/nodes/DocumentType.java']
['Jsoup-17', 1, 1, 1, 1, ['} }; private static String nullString = String.valueOf(0x0000); abstract boolean process(Token t, TreeBuilder tb);'], ["} }; private static String nullString = String.valueOf('\\u0000'); abstract boolean process(Token t, TreeBuilder tb);"], ['private static String nullString = String.valueOf(0x0000);'], ["private static String nullString = String.valueOf('\\u0000');"], 'a/src/main/java/org/jsoup/parser/TreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/TreeBuilderState.java']
['Jsoup-18', 2, 2, 2, 2, [' CharacterReader(String input) { Validate.notNull(input); this.input = input; this.length = input.length();', '} String consumeToEnd() { String data = input.substring(pos, input.length() - 1); pos = input.length(); return data; }'], [' CharacterReader(String input) { Validate.notNull(input); input = input.replaceAll("\\r\\n?", "\\n"); // normalise carriage returns to newlines this.input = input; this.length = input.length();', '} String consumeToEnd() { String data = input.substring(pos, input.length()); pos = input.length(); return data; }'], ['', 'String data = input.substring(pos, input.length() - 1);'], ['input = input.replaceAll("\\r\\n?", "\\n"); // normalise carriage returns to newlines', 'String data = input.substring(pos, input.length());'], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-19', 1, 1, 1, 1, ['// try to resolve relative urls to abs, and optionally update the attribute so output html has abs. // rels without a baseuri get removed String value = el.absUrl(attr.getKey()); if (!preserveRelativeLinks) attr.setValue(value);'], ['// try to resolve relative urls to abs, and optionally update the attribute so output html has abs. // rels without a baseuri get removed String value = el.absUrl(attr.getKey()); if (value.length() == 0) value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols if (!preserveRelativeLinks) attr.setValue(value);'], [''], ['if (value.length() == 0) value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols'], 'a/src/main/java/org/jsoup/safety/Whitelist.java', 'b/src/main/java/org/jsoup/safety/Whitelist.java']
['Jsoup-20', 1, 1, 1, 1, ["// there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight // into head mode doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName);"], ["// there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight // into head mode if (docData.charAt(0) == 65279) docData = docData.substring(1); doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName);"], [''], ['if (docData.charAt(0) == 65279) docData = docData.substring(1);'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-21', 3, 3, 3, 3, ['this.evaluators.addAll(evaluators); } public void add(Evaluator e) { evaluators.add(e);', '// hierarchy and extras boolean seenWhite = tq.consumeWhitespace(); if (tq.matchChomp(",")) { CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals); evals.clear(); evals.add(or); while (!tq.isEmpty()) { String subQuery = tq.chompTo(","); or.add(parse(subQuery)); } } else if (tq.matchesAny(combinators)) { combinator(tq.consume()); } else if (seenWhite) { combinator(\' \');', 'evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e))); else if (combinator == \'~\') evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e))); else throw new Selector.SelectorParseException("Unknown combinator: " + combinator); }'], ['this.evaluators.addAll(evaluators); } Or() { super(); } public void add(Evaluator e) { evaluators.add(e);', "// hierarchy and extras boolean seenWhite = tq.consumeWhitespace(); if (tq.matchesAny(combinators)) { combinator(tq.consume()); } else if (seenWhite) { combinator(' ');", 'evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e))); else if (combinator == \'~\') evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e))); else if (combinator == \',\') { // group or CombiningEvaluator.Or or; if (e instanceof CombiningEvaluator.Or) { or = (CombiningEvaluator.Or) e; or.add(f); } else { or = new CombiningEvaluator.Or(); or.add(e); or.add(f); } evals.add(or); } else throw new Selector.SelectorParseException("Unknown combinator: " + combinator); }'], ['', 'if (tq.matchChomp(",")) { CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals); evals.clear(); evals.add(or); while (!tq.isEmpty()) { String subQuery = tq.chompTo(","); or.add(parse(subQuery)); } } else if (tq.matchesAny(combinators)) {', ''], ['Or() { super(); }', 'if (tq.matchesAny(combinators)) {', "else if (combinator == ',') { // group or CombiningEvaluator.Or or; if (e instanceof CombiningEvaluator.Or) { or = (CombiningEvaluator.Or) e; or.add(f); } else { or = new CombiningEvaluator.Or(); or.add(e); or.add(f); } evals.add(or); }"], 'a/src/main/java/org/jsoup/select/QueryParser.java', 'b/src/main/java/org/jsoup/select/QueryParser.java']
['Jsoup-22', 6, 6, 6, 6, ['* @return sibling elements */ public Elements siblingElements() { return parent().children(); } /**', '* @see #previousElementSibling() */ public Element nextElementSibling() { List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index);', '* @see #nextElementSibling() */ public Element previousElementSibling() { List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index);', '@return node siblings. If the node has no parent, returns an empty list. */ public List<Node> siblingNodes() { return parent().childNodes(); } /**', '@return the previous sibling, or null if this is the first sibling */ public Node previousSibling() { List<Node> siblings = parentNode.childNodes; Integer index = siblingIndex();', 'contents = new ArrayList<Element>(); } public Elements(Collection<Element> elements) { contents = new ArrayList<Element>(elements);'], ['* @return sibling elements */ public Elements siblingElements() { if (parentNode == null) return new Elements(0); List<Element> elements = parent().children(); Elements siblings = new Elements(elements.size() - 1); for (Element el: elements) if (el != this) siblings.add(el); return siblings; } /**', '* @see #previousElementSibling() */ public Element nextElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index);', '* @see #nextElementSibling() */ public Element previousElementSibling() { if (parentNode == null) return null; List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index);', '@return node siblings. If the node has no parent, returns an empty list. */ public List<Node> siblingNodes() { if (parentNode == null) return Collections.emptyList(); List<Node> nodes = parentNode.childNodes; List<Node> siblings = new ArrayList<Node>(nodes.size() - 1); for (Node node: nodes) if (node != this) siblings.add(node); return siblings; } /**', '@return the previous sibling, or null if this is the first sibling */ public Node previousSibling() { if (parentNode == null) return null; // root List<Node> siblings = parentNode.childNodes; Integer index = siblingIndex();', 'contents = new ArrayList<Element>(); } public Elements(int initialCapacity) { contents = new ArrayList<Element>(initialCapacity); } public Elements(Collection<Element> elements) { contents = new ArrayList<Element>(elements);'], ['return parent().children();', '', '', 'return parent().childNodes();', '', ''], ['if (parentNode == null) return new Elements(0); List<Element> elements = parent().children(); Elements siblings = new Elements(elements.size() - 1); for (Element el: elements) if (el != this) siblings.add(el); return siblings;', 'if (parentNode == null) return null;', 'if (parentNode == null) return null;', 'if (parentNode == null) return Collections.emptyList(); List<Node> nodes = parentNode.childNodes; List<Node> siblings = new ArrayList<Node>(nodes.size() - 1); for (Node node: nodes) if (node != this) siblings.add(node); return siblings;', 'if (parentNode == null) return null; // root', 'public Elements(int initialCapacity) { contents = new ArrayList<Element>(initialCapacity); }'], 'a/src/main/java/org/jsoup/select/Elements.java', 'b/src/main/java/org/jsoup/select/Elements.java']
['Jsoup-23', 2, 2, 2, 2, ['return input.substring(start, pos); } String consumeHexSequence() { int start = pos;', "} } else { // named // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found String nameRef = reader.consumeLetterSequence(); String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches boolean looksLegit = reader.matches(';'); boolean found = false;"], ["return input.substring(start, pos); } String consumeLetterThenDigitSequence() { int start = pos; while (!isEmpty()) { char c = input.charAt(pos); if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) pos++; else break; } while (!isEmpty()) { char c = input.charAt(pos); if (c >= '0' && c <= '9') pos++; else break; } return input.substring(start, pos); } String consumeHexSequence() { int start = pos;", "} } else { // named // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found String nameRef = reader.consumeLetterThenDigitSequence(); String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches boolean looksLegit = reader.matches(';'); boolean found = false;"], ['', 'String nameRef = reader.consumeLetterSequence();'], ["String consumeLetterThenDigitSequence() { int start = pos; while (!isEmpty()) { char c = input.charAt(pos); if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) pos++; else break; } while (!isEmpty()) { char c = input.charAt(pos); if (c >= '0' && c <= '9') pos++; else break; } return input.substring(start, pos); }", 'String nameRef = reader.consumeLetterThenDigitSequence();'], 'a/src/main/java/org/jsoup/parser/Tokeniser.java', 'b/src/main/java/org/jsoup/parser/Tokeniser.java']
['Jsoup-24', 1, 1, 1, 1, ['String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); r.advance(); return; }'], ['String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); return; }'], ['r.advance();'], [''], 'a/src/main/java/org/jsoup/parser/TokeniserState.java', 'b/src/main/java/org/jsoup/parser/TokeniserState.java']
['Jsoup-25', 1, 1, 1, 1, ['private static final String[] formatAsInlineTags = { "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style" }; private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title"}; static { // creates'], ['private static final String[] formatAsInlineTags = { "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style" }; private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title", "textarea"}; static { // creates'], ['private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title"};'], ['private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title", "textarea"};'], 'a/src/main/java/org/jsoup/parser/Tag.java', 'b/src/main/java/org/jsoup/parser/Tag.java']
['Jsoup-26', 1, 1, 1, 1, ['Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); copySafeNodes(dirtyDocument.body(), clean.body()); return clean;'], ["Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body. copySafeNodes(dirtyDocument.body(), clean.body()); return clean;"], [''], ["if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body."], 'a/src/main/java/org/jsoup/safety/Cleaner.java', 'b/src/main/java/org/jsoup/safety/Cleaner.java']
['Jsoup-27', 1, 1, 1, 1, ['Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); charset = charset.toUpperCase(Locale.ENGLISH); return charset; } return null; }'], ['Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset; } return null; }'], ['return charset;'], ['if (Charset.isSupported(charset)) return charset; if (Charset.isSupported(charset)) return charset;'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-28', 6, 6, 6, 6, ['package org.jsoup.nodes; import java.io.IOException; import java.io.InputStream;', '* @return true if a known named entity in the base set * @see #isNamedEntity(String) */ /** * Get the Character value of the named entity', '* @return */ static String unescape(String string, boolean strict) { if (!string.contains("&")) return string; Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string); StringBuffer accum = new StringBuffer(string.length()); while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); } if (charval != -1 || charval > 0xFFFF) { String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); } } m.appendTail(accum); return accum.toString(); } // xhtml has restricted entities', '* @param inAttribute if the string is to be escaped in strict mode (as attributes are) * @return an unescaped string */ /** * @param bodyHtml HTML to parse', '} else { // named // get as many letters as possible, and look for matching entities. String nameRef = reader.consumeLetterThenDigitSequence(); String origNameRef = new String(nameRef); boolean looksLegit = reader.matches(\';\'); // found if a base named entity without a ;, or an extended entity with the ;. boolean found = false; while (nameRef.length() > 0 && !found) { if (Entities.isNamedEntity(nameRef)) found = true; else { nameRef = nameRef.substring(0, nameRef.length()-1); reader.unconsume(); } } if (!found) { reader.rewindToMark(); if (looksLegit) // named with semicolon characterReferenceError(String.format("invalid named referenece \'%s\'", origNameRef)); return null; } if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\'=\', \'-\', \'_\'))) {', '* @param inAttribute * @return unescaped string from reader */ }'], ['package org.jsoup.nodes; import org.jsoup.parser.Parser; import java.io.IOException; import java.io.InputStream;', '* @return true if a known named entity in the base set * @see #isNamedEntity(String) */ public static boolean isBaseNamedEntity(String name) { return base.containsKey(name); } /** * Get the Character value of the named entity', '* @return */ static String unescape(String string, boolean strict) { return Parser.unescapeEntities(string, strict); } // xhtml has restricted entities', '* @param inAttribute if the string is to be escaped in strict mode (as attributes are) * @return an unescaped string */ public static String unescapeEntities(String string, boolean inAttribute) { Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking()); return tokeniser.unescapeEntities(inAttribute); } /** * @param bodyHtml HTML to parse', '} else { // named // get as many letters as possible, and look for matching entities. String nameRef = reader.consumeLetterThenDigitSequence(); boolean looksLegit = reader.matches(\';\'); // found if a base named entity without a ;, or an extended entity with the ;. boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit)); if (!found) { reader.rewindToMark(); if (looksLegit) // named with semicolon characterReferenceError(String.format("invalid named referenece \'%s\'", nameRef)); return null; } if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny(\'=\', \'-\', \'_\'))) {', "* @param inAttribute * @return unescaped string from reader */ String unescapeEntities(boolean inAttribute) { StringBuilder builder = new StringBuilder(); while (!reader.isEmpty()) { builder.append(reader.consumeTo('&')); if (reader.matches('&')) { reader.consume(); Character c = consumeCharacterReference(null, inAttribute); if (c == null) builder.append('&'); else builder.append(c); } } return builder.toString(); } }"], ['', '', 'if (!string.contains("&")) return string; Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string); StringBuffer accum = new StringBuffer(string.length()); while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); } if (charval != -1 || charval > 0xFFFF) { String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); } } m.appendTail(accum); return accum.toString();', '', 'String origNameRef = new String(nameRef); boolean found = false; while (nameRef.length() > 0 && !found) { if (Entities.isNamedEntity(nameRef)) found = true; else { nameRef = nameRef.substring(0, nameRef.length()-1); reader.unconsume(); } } characterReferenceError(String.format("invalid named referenece \'%s\'", origNameRef));', ''], ['import org.jsoup.parser.Parser;', 'public static boolean isBaseNamedEntity(String name) { return base.containsKey(name); }', 'return Parser.unescapeEntities(string, strict);', 'public static String unescapeEntities(String string, boolean inAttribute) { Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking()); return tokeniser.unescapeEntities(inAttribute); }', 'boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit)); characterReferenceError(String.format("invalid named referenece \'%s\'", nameRef));', "String unescapeEntities(boolean inAttribute) { StringBuilder builder = new StringBuilder(); while (!reader.isEmpty()) { builder.append(reader.consumeTo('&')); if (reader.matches('&')) { reader.consume(); Character c = consumeCharacterReference(null, inAttribute); if (c == null) builder.append('&'); else builder.append(c); } } return builder.toString(); }"], 'a/src/main/java/org/jsoup/parser/Tokeniser.java', 'b/src/main/java/org/jsoup/parser/Tokeniser.java']
['Jsoup-29', 2, 2, 2, 2, ['package org.jsoup.nodes; import org.jsoup.helper.Validate; import org.jsoup.parser.Tag; import org.jsoup.select.Elements;', 'public String title() { // title is a preserve whitespace tag (for document output), but normalised here Element titleEl = getElementsByTag("title").first(); return titleEl != null ? titleEl.text().trim() : ""; } /**'], ['package org.jsoup.nodes; import org.jsoup.helper.StringUtil; import org.jsoup.helper.Validate; import org.jsoup.parser.Tag; import org.jsoup.select.Elements;', 'public String title() { // title is a preserve whitespace tag (for document output), but normalised here Element titleEl = getElementsByTag("title").first(); return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : ""; } /**'], ['', 'return titleEl != null ? titleEl.text().trim() : "";'], ['import org.jsoup.helper.StringUtil;', 'return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : "";'], 'a/src/main/java/org/jsoup/nodes/Document.java', 'b/src/main/java/org/jsoup/nodes/Document.java']
['Jsoup-30', 3, 3, 3, 3, ['import org.jsoup.helper.Validate; import org.jsoup.nodes.*; import org.jsoup.parser.Tag; import java.util.List;', '/** Iterates the input and copies trusted nodes (tags, attributes, text) into the destination. */ private int copySafeNodes(Element root, Element destination) { List<Node> sourceChildren = root.childNodes(); int numDiscarded = 0; for (Node source : sourceChildren) { if (source instanceof Element) { Element sourceEl = (Element) source;', 'destination.appendChild(destChild); numDiscarded += meta.numAttribsDiscarded; numDiscarded += copySafeNodes(sourceEl, destChild); } else { numDiscarded++; numDiscarded += copySafeNodes(sourceEl, destination); } } else if (source instanceof TextNode) { TextNode sourceText = (TextNode) source; TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri()); destination.appendChild(destText); } } return numDiscarded; } private ElementMeta createSafeElement(Element sourceEl) {'], ['import org.jsoup.helper.Validate; import org.jsoup.nodes.*; import org.jsoup.parser.Tag; import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import java.util.List;', '/** Iterates the input and copies trusted nodes (tags, attributes, text) into the destination. */ private final class CleaningVisitor implements NodeVisitor { private int numDiscarded = 0; private final Element root; private Element destination; // current element to append nodes to private CleaningVisitor(Element root, Element destination) { this.root = root; this.destination = destination; } public void head(Node source, int depth) { if (source instanceof Element) { Element sourceEl = (Element) source;', "destination.appendChild(destChild); numDiscarded += meta.numAttribsDiscarded; destination = destChild; } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded. numDiscarded++; } } else if (source instanceof TextNode) { TextNode sourceText = (TextNode) source; TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri()); destination.appendChild(destText); } else { // else, we don't care about comments, xml proc instructions, etc numDiscarded++; } } public void tail(Node source, int depth) { if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) { destination = destination.parent(); // would have descended, so pop destination stack } } } private int copySafeNodes(Element source, Element dest) { CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest); NodeTraversor traversor = new NodeTraversor(cleaningVisitor); traversor.traverse(source); return cleaningVisitor.numDiscarded; } private ElementMeta createSafeElement(Element sourceEl) {"], ['', 'private int copySafeNodes(Element root, Element destination) { List<Node> sourceChildren = root.childNodes(); int numDiscarded = 0; for (Node source : sourceChildren) {', 'numDiscarded += copySafeNodes(sourceEl, destChild); } else { numDiscarded += copySafeNodes(sourceEl, destination); return numDiscarded;'], ['import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor;', 'private final class CleaningVisitor implements NodeVisitor { private int numDiscarded = 0; private final Element root; private Element destination; // current element to append nodes to private CleaningVisitor(Element root, Element destination) { this.root = root; this.destination = destination; } public void head(Node source, int depth) {', "destination = destChild; } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded. } else { // else, we don't care about comments, xml proc instructions, etc numDiscarded++; public void tail(Node source, int depth) { if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) { destination = destination.parent(); // would have descended, so pop destination stack } } } private int copySafeNodes(Element source, Element dest) { CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest); NodeTraversor traversor = new NodeTraversor(cleaningVisitor); traversor.traverse(source); return cleaningVisitor.numDiscarded;"], 'a/src/main/java/org/jsoup/safety/Cleaner.java', 'b/src/main/java/org/jsoup/safety/Cleaner.java']
['Jsoup-31', 3, 3, 3, 3, [' static class Comment extends Token { final StringBuilder data = new StringBuilder(); Comment() { type = TokenType.Comment;', "// rewind to capture character that lead us here r.unconsume(); Token.Comment comment = new Token.Comment(); comment.data.append(r.consumeTo('>')); // todo: replace nullChar with replaceChar t.emit(comment);", 'void insert(Token.Comment commentToken) { Comment comment = new Comment(commentToken.getData(), baseUri); Node insert = comment; insertNode(insert); }'], [' static class Comment extends Token { final StringBuilder data = new StringBuilder(); boolean bogus = false; Comment() { type = TokenType.Comment;', "// rewind to capture character that lead us here r.unconsume(); Token.Comment comment = new Token.Comment(); comment.bogus = true; comment.data.append(r.consumeTo('>')); // todo: replace nullChar with replaceChar t.emit(comment);", 'void insert(Token.Comment commentToken) { Comment comment = new Comment(commentToken.getData(), baseUri); Node insert = comment; if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml) String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { String declaration = data.substring(1); insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!")); } } insertNode(insert); }'], ['', '', ''], ['boolean bogus = false;', 'comment.bogus = true;', 'if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml) String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { String declaration = data.substring(1); insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!")); } }'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-32', 1, 1, 1, 1, ['@Override public Element clone() { Element clone = (Element) super.clone(); clone.classNames(); return clone; } }'], ['@Override public Element clone() { Element clone = (Element) super.clone(); clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames return clone; } }'], ['clone.classNames();'], ['clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-33', 1, 1, 1, 1, ['if (startTag.isSelfClosing()) { Element el = insertEmpty(startTag); stack.add(el); tokeniser.emit(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in. emitted for yielded processing return el; }'], ['if (startTag.isSelfClosing()) { Element el = insertEmpty(startTag); stack.add(el); tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data tokeniser.emit(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in. emitted for yielded processing return el; }'], [''], ['tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java']
['Jsoup-34', 1, 1, 1, 1, ['while(++offset < length && startChar != input[offset]); int i = offset + 1; int last = i + seq.length()-1; if (offset < length) { for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) // found full sequence return offset - pos;'], ['while(++offset < length && startChar != input[offset]); int i = offset + 1; int last = i + seq.length()-1; if (offset < length && last <= length) { for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) // found full sequence return offset - pos;'], ['if (offset < length) {'], ['if (offset < length && last <= length) {'], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-35', 1, 1, 1, 1, ['} Element adopter = new Element(formatEl.tag(), tb.getBaseUri()); Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]); for (Node childNode : childNodes) { adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.'], ['} Element adopter = new Element(formatEl.tag(), tb.getBaseUri()); adopter.attributes().addAll(formatEl.attributes()); Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]); for (Node childNode : childNodes) { adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.'], [''], ['adopter.attributes().addAll(formatEl.attributes());'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-36', 4, 4, 4, 4, ['import java.io.*; import java.nio.ByteBuffer; import java.nio.charset.Charset; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Locale;', '* */ public class DataUtil { private static final Pattern charsetPattern = Pattern.compile("(?i)\\\\bcharset=\\\\s*\\"?([^\\\\s;\\"]*)"); static final String defaultCharset = "UTF-8"; // used if not found in header or meta charset private static final int bufferSize = 0x20000; // ~130K.', 'String foundCharset; if (meta.hasAttr("http-equiv")) { foundCharset = getCharsetFromContentType(meta.attr("content")); } else { foundCharset = meta.attr("charset"); } if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode charsetName = foundCharset; byteData.rewind(); docData = Charset.forName(foundCharset).decode(byteData).toString();', 'Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset; // if our advanced charset matching fails.... we just take the default } return null; }'], ['import java.io.*; import java.nio.ByteBuffer; import java.nio.charset.Charset; import java.nio.charset.IllegalCharsetNameException; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Locale;', '* */ public class DataUtil { private static final Pattern charsetPattern = Pattern.compile("(?i)\\\\bcharset=\\\\s*(?:\\"|\')?([^\\\\s,;\\"\']*)"); static final String defaultCharset = "UTF-8"; // used if not found in header or meta charset private static final int bufferSize = 0x20000; // ~130K.', 'String foundCharset; if (meta.hasAttr("http-equiv")) { foundCharset = getCharsetFromContentType(meta.attr("content")); if (foundCharset == null && meta.hasAttr("charset")) { try { if (Charset.isSupported(meta.attr("charset"))) { foundCharset = meta.attr("charset"); } } catch (IllegalCharsetNameException e) { foundCharset = null; } } } else { foundCharset = meta.attr("charset"); } if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode foundCharset = foundCharset.trim().replaceAll("[\\"\']", ""); charsetName = foundCharset; byteData.rewind(); docData = Charset.forName(foundCharset).decode(byteData).toString();', 'Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); charset = charset.replace("charset=", ""); if (charset.isEmpty()) return null; try { if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset; } catch (IllegalCharsetNameException e) { // if our advanced charset matching fails.... we just take the default return null; } } return null; }'], ['', 'private static final Pattern charsetPattern = Pattern.compile("(?i)\\\\bcharset=\\\\s*\\"?([^\\\\s;\\"]*)");', '', ''], ['import java.nio.charset.IllegalCharsetNameException;', 'private static final Pattern charsetPattern = Pattern.compile("(?i)\\\\bcharset=\\\\s*(?:\\"|\')?([^\\\\s,;\\"\']*)");', 'if (foundCharset == null && meta.hasAttr("charset")) { try { if (Charset.isSupported(meta.attr("charset"))) { foundCharset = meta.attr("charset"); } } catch (IllegalCharsetNameException e) { foundCharset = null; } } foundCharset = foundCharset.trim().replaceAll("[\\"\']", "");', 'charset = charset.replace("charset=", ""); if (charset.isEmpty()) return null; try { } catch (IllegalCharsetNameException e) { return null; }'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-37', 1, 1, 1, 1, ['public String html() { StringBuilder accum = new StringBuilder(); html(accum); return accum.toString().trim(); } private void html(StringBuilder accum) {'], ['public String html() { StringBuilder accum = new StringBuilder(); html(accum); return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString(); } private void html(StringBuilder accum) {'], ['return accum.toString().trim();'], ['return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-38', 1, 1, 1, 1, ['tb.insertEmpty(startTag); tb.framesetOk(false); } else if (name.equals("image")) { return tb.process(startTag.name("img")); // change <image> to <img>, unless in svg } else if (name.equals("isindex")) { // how much do we care about the early 90s? tb.error(this);'], ['tb.insertEmpty(startTag); tb.framesetOk(false); } else if (name.equals("image")) { if (tb.getFromStack("svg") == null) return tb.process(startTag.name("img")); // change <image> to <img>, unless in svg else tb.insert(startTag); } else if (name.equals("isindex")) { // how much do we care about the early 90s? tb.error(this);'], [''], ['if (tb.getFromStack("svg") == null) else tb.insert(startTag);'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-39', 1, 1, 1, 1, ['docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; } if (doc == null) { doc = parser.parseInput(docData, baseUri);'], ['docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; doc = null; } if (doc == null) { doc = parser.parseInput(docData, baseUri);'], [''], ['doc = null;'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-40', 1, 1, 1, 1, ['public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); Validate.notEmpty(name); attr("name", name); attr("publicId", publicId); attr("systemId", systemId);'], ['public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); attr("name", name); attr("publicId", publicId); attr("systemId", systemId);'], ['Validate.notEmpty(name);'], [''], 'a/src/main/java/org/jsoup/nodes/DocumentType.java', 'b/src/main/java/org/jsoup/nodes/DocumentType.java']
['Jsoup-41', 1, 1, 1, 1, [' Element element = (Element) o; return this == o; } @Override'], [' Element element = (Element) o; return tag.equals(element.tag); } @Override'], ['return this == o;'], ['return tag.equals(element.tag);'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-42', 2, 2, 2, 2, ['// iterate the form control elements and accumulate their values for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable String name = el.attr("name"); if (name.length() == 0) continue; String type = el.attr("type");', '} else if ("checkbox".equalsIgnoreCase(type) || "radio".equalsIgnoreCase(type)) { // only add checkbox or radio if they have the checked attribute if (el.hasAttr("checked")) { final String val = el.val(); data.add(HttpConnection.KeyVal.create(name, val)); } } else {'], ['// iterate the form control elements and accumulate their values for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable if (el.hasAttr("disabled")) continue; // skip disabled form inputs String name = el.attr("name"); if (name.length() == 0) continue; String type = el.attr("type");', '} else if ("checkbox".equalsIgnoreCase(type) || "radio".equalsIgnoreCase(type)) { // only add checkbox or radio if they have the checked attribute if (el.hasAttr("checked")) { final String val = el.val().length() > 0 ? el.val() : "on"; data.add(HttpConnection.KeyVal.create(name, val)); } } else {'], ['', 'final String val = el.val();'], ['if (el.hasAttr("disabled")) continue; // skip disabled form inputs', 'final String val = el.val().length() > 0 ? el.val() : "on";'], 'a/src/main/java/org/jsoup/nodes/FormElement.java', 'b/src/main/java/org/jsoup/nodes/FormElement.java']
['Jsoup-43', 1, 1, 1, 1, [' for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); if (element.equals(search)) return i; } return null;'], [' for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); if (element == search) return i; } return null;'], ['if (element.equals(search))'], ['if (element == search)'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-44', 1, 1, 1, 1, ['protected abstract boolean process(Token token); protected boolean processStartTag(String name) { return process(start.reset().name(name)); } public boolean processStartTag(String name, Attributes attrs) { start.reset(); start.nameAttr(name, attrs); return process(start); } protected boolean processEndTag(String name) { return process(end.reset().name(name)); }'], ["protected abstract boolean process(Token token); protected boolean processStartTag(String name) { if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().name(name)); } return process(start.reset().name(name)); } public boolean processStartTag(String name, Attributes attrs) { if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().nameAttr(name, attrs)); } start.reset(); start.nameAttr(name, attrs); return process(start); } protected boolean processEndTag(String name) { if (currentToken == end) { // don't recycle an in-use token return process(new Token.EndTag().name(name)); } return process(end.reset().name(name)); }"], [''], ["if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().name(name)); } if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().nameAttr(name, attrs)); } if (currentToken == end) { // don't recycle an in-use token return process(new Token.EndTag().name(name)); }"], 'a/src/main/java/org/jsoup/parser/TreeBuilder.java', 'b/src/main/java/org/jsoup/parser/TreeBuilder.java']
['Jsoup-45', 1, 1, 1, 1, ['if ("select".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; // frag } else if (("td".equals(name) || "td".equals(name) && !last)) { transition(HtmlTreeBuilderState.InCell); break; } else if ("tr".equals(name)) {'], ['if ("select".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; // frag } else if (("td".equals(name) || "th".equals(name) && !last)) { transition(HtmlTreeBuilderState.InCell); break; } else if ("tr".equals(name)) {'], ['} else if (("td".equals(name) || "td".equals(name) && !last)) {'], ['} else if (("td".equals(name) || "th".equals(name) && !last)) {'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java']
['Jsoup-46', 1, 1, 1, 1, ['if (escapeMode != EscapeMode.xhtml) accum.append("&nbsp;"); else accum.append(c); break; case \'<\': if (!inAttribute)'], ['if (escapeMode != EscapeMode.xhtml) accum.append("&nbsp;"); else accum.append("&#xa0;"); break; case \'<\': if (!inAttribute)'], ['accum.append(c);'], ['accum.append("&#xa0;");'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-47', 1, 1, 1, 1, ['break; case \'<\': // escape when in character data or when in a xml attribue val; not needed in html attr val if (!inAttribute) accum.append("&lt;"); else accum.append(c);'], ['break; case \'<\': // escape when in character data or when in a xml attribue val; not needed in html attr val if (!inAttribute || escapeMode == EscapeMode.xhtml) accum.append("&lt;"); else accum.append(c);'], ['if (!inAttribute)'], ['if (!inAttribute || escapeMode == EscapeMode.xhtml)'], 'a/src/main/java/org/jsoup/nodes/Entities.java', 'b/src/main/java/org/jsoup/nodes/Entities.java']
['Jsoup-48', 1, 1, 1, 1, ['cookie(cookieName, cookieVal); } } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 if (!values.isEmpty()) header(name, values.get(0)); } } }'], ['cookie(cookieName, cookieVal); } } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 if (values.size() == 1) header(name, values.get(0)); else if (values.size() > 1) { StringBuilder accum = new StringBuilder(); for (int i = 0; i < values.size(); i++) { final String val = values.get(i); if (i != 0) accum.append(", "); accum.append(val); } header(name, accum.toString()); } } } }'], ['if (!values.isEmpty())'], ['if (values.size() == 1) else if (values.size() > 1) { StringBuilder accum = new StringBuilder(); for (int i = 0; i < values.size(); i++) { final String val = values.get(i); if (i != 0) accum.append(", "); accum.append(val); } header(name, accum.toString()); }'], 'a/src/main/java/org/jsoup/helper/HttpConnection.java', 'b/src/main/java/org/jsoup/helper/HttpConnection.java']
['Jsoup-49', 1, 1, 1, 1, ['Node in = children[i]; reparentChild(in); childNodes.add(index, in); } reindexChildren(index); } protected void ensureChildNodes() {'], ['Node in = children[i]; reparentChild(in); childNodes.add(index, in); reindexChildren(index); } } protected void ensureChildNodes() {'], ['reindexChildren(index);'], ['reindexChildren(index);'], 'a/src/main/java/org/jsoup/nodes/Node.java', 'b/src/main/java/org/jsoup/nodes/Node.java']
['Jsoup-50', 2, 2, 2, 2, ['Document doc = null; // look for BOM - overrides any other header or input if (charsetName == null) { // determine from meta. safe parse as UTF-8 // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">', 'Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"); docData = Charset.forName(charsetName).decode(byteData).toString(); } if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) { byteData.rewind(); docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; doc = null; } if (doc == null) { doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName);'], ['Document doc = null; // look for BOM - overrides any other header or input byteData.mark(); byte[] bom = new byte[4]; byteData.get(bom); byteData.rewind(); if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE charsetName = "UTF-32"; // and I hope it\'s on your system } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) { charsetName = "UTF-16"; // in all Javas } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) { charsetName = "UTF-8"; // in all Javas byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed } if (charsetName == null) { // determine from meta. safe parse as UTF-8 // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">', 'Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"); docData = Charset.forName(charsetName).decode(byteData).toString(); } if (doc == null) { doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName);'], ['', 'if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) { byteData.rewind(); docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; doc = null; }'], ['byteData.mark(); byte[] bom = new byte[4]; byteData.get(bom); byteData.rewind(); if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE charsetName = "UTF-32"; // and I hope it\'s on your system } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) { charsetName = "UTF-16"; // in all Javas } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) { charsetName = "UTF-8"; // in all Javas byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed }', ''], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-51', 1, 1, 1, 1, ["if (isEmpty()) return false; char c = input[pos]; return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); } boolean matchesDigit() {"], ["if (isEmpty()) return false; char c = input[pos]; return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c); } boolean matchesDigit() {"], ["return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');"], ["return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);"], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-52', 4, 4, 4, 4, ['foundCharset = getCharsetFromContentType(meta.attr("content")); } if (foundCharset == null && meta.hasAttr("charset")) { try { if (Charset.isSupported(meta.attr("charset"))) { foundCharset = meta.attr("charset"); } } catch (IllegalCharsetNameException e) { foundCharset = null; } } } // look for <?xml encoding=\'ISO-8859-1\'?>', '@return XML declaration */ public String getWholeDeclaration() { final String decl = this.name; if(decl.equals("xml") && attributes.size() > 1 ) { StringBuilder sb = new StringBuilder(decl); final String version = attributes.get("version"); if( version != null ) { sb.append(" version=\\"").append(version).append("\\""); } final String encoding = attributes.get("encoding"); if( encoding != null ) { sb.append(" encoding=\\"").append(encoding).append("\\""); } return sb.toString(); } else { return this.name; } } void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { accum .append("<") .append(isProcessingInstruction ? "!" : "?") .append(getWholeDeclaration()) .append(">"); }', 'package org.jsoup.parser; import org.jsoup.helper.Validate; import org.jsoup.nodes.*;', '// so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { String declaration = data.substring(1); insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!")); } } insertNode(insert);'], ['foundCharset = getCharsetFromContentType(meta.attr("content")); } if (foundCharset == null && meta.hasAttr("charset")) { foundCharset = meta.attr("charset"); } } // look for <?xml encoding=\'ISO-8859-1\'?>', '@return XML declaration */ public String getWholeDeclaration() { return attributes.html().trim(); // attr html starts with a " " } void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { accum .append("<") .append(isProcessingInstruction ? "!" : "?") .append(name); attributes.html(accum, out); accum .append(isProcessingInstruction ? "!" : "?") .append(">"); }', 'package org.jsoup.parser; import org.jsoup.Jsoup; import org.jsoup.helper.Validate; import org.jsoup.nodes.*;', '// so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser()); Element el = doc.child(0); insert = new XmlDeclaration(el.tagName(), comment.baseUri(), data.startsWith("!")); insert.attributes().addAll(el.attributes()); } } insertNode(insert);'], ['try { if (Charset.isSupported(meta.attr("charset"))) { } } catch (IllegalCharsetNameException e) { foundCharset = null; }', 'final String decl = this.name; if(decl.equals("xml") && attributes.size() > 1 ) { StringBuilder sb = new StringBuilder(decl); final String version = attributes.get("version"); if( version != null ) { sb.append(" version=\\"").append(version).append("\\""); } final String encoding = attributes.get("encoding"); if( encoding != null ) { sb.append(" encoding=\\"").append(encoding).append("\\""); } return sb.toString(); } else { return this.name; } .append(getWholeDeclaration())', '', 'String declaration = data.substring(1); insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!"));'], ['', 'return attributes.html().trim(); // attr html starts with a " " .append(name); attributes.html(accum, out); accum .append(isProcessingInstruction ? "!" : "?")', 'import org.jsoup.Jsoup;', 'Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser()); Element el = doc.child(0); insert = new XmlDeclaration(el.tagName(), comment.baseUri(), data.startsWith("!")); insert.attributes().addAll(el.attributes());'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-53', 1, 1, 1, 1, ['int end = -1; int depth = 0; char last = 0; do { if (isEmpty()) break; Character c = consume(); if (last == 0 || last != ESC) { if (c.equals(open)) { depth++; if (start == -1)'], ['int end = -1; int depth = 0; char last = 0; boolean inQuote = false; do { if (isEmpty()) break; Character c = consume(); if (last == 0 || last != ESC) { if (c.equals(\'\\\'\') || c.equals(\'"\') && c != open) inQuote = !inQuote; if (inQuote) continue; if (c.equals(open)) { depth++; if (start == -1)'], [''], ['boolean inQuote = false; if (c.equals(\'\\\'\') || c.equals(\'"\') && c != open) inQuote = !inQuote; if (inQuote) continue;'], 'a/src/main/java/org/jsoup/parser/TokenQueue.java', 'b/src/main/java/org/jsoup/parser/TokenQueue.java']
['Jsoup-54', 1, 1, 1, 1, ['for (Attribute attribute : source.attributes()) { // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.] String key = attribute.getKey().replaceAll("[^-a-zA-Z0-9_:.]", ""); el.setAttribute(key, attribute.getValue()); } }'], ['for (Attribute attribute : source.attributes()) { // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.] String key = attribute.getKey().replaceAll("[^-a-zA-Z0-9_:.]", ""); if (key.matches("[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*")) el.setAttribute(key, attribute.getValue()); } }'], [''], ['if (key.matches("[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*"))'], 'a/src/main/java/org/jsoup/helper/W3CDom.java', 'b/src/main/java/org/jsoup/helper/W3CDom.java']
['Jsoup-55', 1, 1, 1, 1, ['break; default: t.error(this); t.transition(BeforeAttributeName); } }'], ['break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } }'], [''], ['r.unconsume();'], 'a/src/main/java/org/jsoup/parser/TokeniserState.java', 'b/src/main/java/org/jsoup/parser/TokeniserState.java']
['Jsoup-56', 10, 10, 10, 10, ['public static final String PUBLIC_KEY = "PUBLIC"; public static final String SYSTEM_KEY = "SYSTEM"; private static final String NAME = "name"; private static final String PUBLIC_ID = "publicId"; private static final String SYSTEM_ID = "systemId"; // todo: quirk mode from publicId and systemId', ' attr(NAME, name); attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); }', "* @param systemId the doctype's system ID * @param baseUri the doctype's base URI */ @Override public String nodeName() {", '} if (has(NAME)) accum.append(" ").append(attr(NAME)); if (has(PUBLIC_ID)) accum.append(" PUBLIC \\"").append(attr(PUBLIC_ID)).append(\'"\'); if (has(SYSTEM_ID)) accum.append(" \\"").append(attr(SYSTEM_ID)).append(\'"\'); accum.append(\'>\');', '// todo: quirk state check on doctype ids Token.Doctype d = t.asDoctype(); DocumentType doctype = new DocumentType( tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri()); tb.getDocument().appendChild(doctype); if (d.isForceQuirks()) tb.getDocument().quirksMode(Document.QuirksMode.quirks);', ' static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false;', '@Override Token reset() { reset(name); reset(publicIdentifier); reset(systemIdentifier); forceQuirks = false;', 'return name.toString(); } String getPublicIdentifier() { return publicIdentifier.toString();', 't.emitDoctypePending(); t.advanceTransition(Data); } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) { t.transition(AfterDoctypePublicKeyword); } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) { t.transition(AfterDoctypeSystemKeyword); } else { t.error(this);', '} void insert(Token.Doctype d) { DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri); insertNode(doctypeNode); }'], ['public static final String PUBLIC_KEY = "PUBLIC"; public static final String SYSTEM_KEY = "SYSTEM"; private static final String NAME = "name"; private static final String PUB_SYS_KEY = "pubSysKey"; // PUBLIC or SYSTEM private static final String PUBLIC_ID = "publicId"; private static final String SYSTEM_ID = "systemId"; // todo: quirk mode from publicId and systemId', ' attr(NAME, name); attr(PUBLIC_ID, publicId); if (has(PUBLIC_ID)) { attr(PUB_SYS_KEY, PUBLIC_KEY); } attr(SYSTEM_ID, systemId); }', "* @param systemId the doctype's system ID * @param baseUri the doctype's base URI */ public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name); if (pubSysKey != null) { attr(PUB_SYS_KEY, pubSysKey); } attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); } @Override public String nodeName() {", '} if (has(NAME)) accum.append(" ").append(attr(NAME)); if (has(PUB_SYS_KEY)) accum.append(" ").append(attr(PUB_SYS_KEY)); if (has(PUBLIC_ID)) accum.append(" \\"").append(attr(PUBLIC_ID)).append(\'"\'); if (has(SYSTEM_ID)) accum.append(" \\"").append(attr(SYSTEM_ID)).append(\'"\'); accum.append(\'>\');', '// todo: quirk state check on doctype ids Token.Doctype d = t.asDoctype(); DocumentType doctype = new DocumentType( tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri()); tb.getDocument().appendChild(doctype); if (d.isForceQuirks()) tb.getDocument().quirksMode(Document.QuirksMode.quirks);', ' static final class Doctype extends Token { final StringBuilder name = new StringBuilder(); String pubSysKey = null; final StringBuilder publicIdentifier = new StringBuilder(); final StringBuilder systemIdentifier = new StringBuilder(); boolean forceQuirks = false;', '@Override Token reset() { reset(name); pubSysKey = null; reset(publicIdentifier); reset(systemIdentifier); forceQuirks = false;', 'return name.toString(); } String getPubSysKey() { return pubSysKey; } String getPublicIdentifier() { return publicIdentifier.toString();', 't.emitDoctypePending(); t.advanceTransition(Data); } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) { t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY; t.transition(AfterDoctypePublicKeyword); } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) { t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY; t.transition(AfterDoctypeSystemKeyword); } else { t.error(this);', '} void insert(Token.Doctype d) { DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri); insertNode(doctypeNode); }'], ['', '', '', 'accum.append(" PUBLIC \\"").append(attr(PUBLIC_ID)).append(\'"\');', 'tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());', '', '', '', '', 'DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);'], ['private static final String PUB_SYS_KEY = "pubSysKey"; // PUBLIC or SYSTEM', 'if (has(PUBLIC_ID)) { attr(PUB_SYS_KEY, PUBLIC_KEY); }', 'public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) { super(baseUri); attr(NAME, name); if (pubSysKey != null) { attr(PUB_SYS_KEY, pubSysKey); } attr(PUBLIC_ID, publicId); attr(SYSTEM_ID, systemId); }', 'if (has(PUB_SYS_KEY)) accum.append(" ").append(attr(PUB_SYS_KEY)); accum.append(" \\"").append(attr(PUBLIC_ID)).append(\'"\');', 'tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());', 'String pubSysKey = null;', 'pubSysKey = null;', 'String getPubSysKey() { return pubSysKey; }', 't.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY; t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;', 'DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-57', 1, 1, 1, 1, ['for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) attributes.remove(attrKey); } }'], ['for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) it.remove(); } }'], ['attributes.remove(attrKey);'], ['it.remove();'], 'a/src/main/java/org/jsoup/nodes/Attributes.java', 'b/src/main/java/org/jsoup/nodes/Attributes.java']
['Jsoup-58', 4, 4, 4, 4, ['@see #clean(String, org.jsoup.safety.Whitelist) */ public static boolean isValid(String bodyHtml, Whitelist whitelist) { return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, "")); } }', '* * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified. */ /** * Parse a fragment of XML into a list of nodes.', 'import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; /**', ' Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0; } /** Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.'], ['@see #clean(String, org.jsoup.safety.Whitelist) */ public static boolean isValid(String bodyHtml, Whitelist whitelist) { return new Cleaner(whitelist).isValidBodyHtml(bodyHtml); } }', '* * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified. */ public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder(); return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings()); } /** * Parse a fragment of XML into a list of nodes.', 'import org.jsoup.select.NodeTraversor; import org.jsoup.select.NodeVisitor; import java.util.List; /**', ' Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0 && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there\'s nothing in the head } public boolean isValidBodyHtml(String bodyHtml) { Document clean = Document.createShell(""); Document dirty = Document.createShell(""); ParseErrorList errorList = ParseErrorList.tracking(1); List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), "", errorList); dirty.body().insertChildren(0, nodes); int numDiscarded = copySafeNodes(dirty.body(), clean.body()); return numDiscarded == 0 && errorList.size() == 0; } /** Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.'], ['return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, ""));', '', '', 'return numDiscarded == 0;'], ['return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);', 'public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder(); return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings()); }', 'import java.util.List;', 'return numDiscarded == 0 && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there\'s nothing in the head public boolean isValidBodyHtml(String bodyHtml) { Document clean = Document.createShell(""); Document dirty = Document.createShell(""); ParseErrorList errorList = ParseErrorList.tracking(1); List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), "", errorList); dirty.body().insertChildren(0, nodes); int numDiscarded = copySafeNodes(dirty.body(), clean.body()); return numDiscarded == 0 && errorList.size() == 0; }'], 'a/src/main/java/org/jsoup/safety/Cleaner.java', 'b/src/main/java/org/jsoup/safety/Cleaner.java']
['Jsoup-59', 2, 2, 2, 2, ['if (pendingAttributeName != null) { // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here pendingAttributeName = pendingAttributeName.trim(); Attribute attribute; if (hasPendingAttributeValue) attribute = new Attribute(pendingAttributeName,', 'else attribute = new BooleanAttribute(pendingAttributeName); attributes.put(attribute); } pendingAttributeName = null; hasEmptyAttributeValue = false;'], ['if (pendingAttributeName != null) { // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here pendingAttributeName = pendingAttributeName.trim(); if (pendingAttributeName.length() > 0) { Attribute attribute; if (hasPendingAttributeValue) attribute = new Attribute(pendingAttributeName,', 'else attribute = new BooleanAttribute(pendingAttributeName); attributes.put(attribute); } } pendingAttributeName = null; hasEmptyAttributeValue = false;'], ['', ''], ['if (pendingAttributeName.length() > 0) {', '}'], 'a/src/main/java/org/jsoup/parser/Token.java', 'b/src/main/java/org/jsoup/parser/Token.java']
['Jsoup-60', 2, 2, 2, 2, ['last = c; } while (depth > 0); final String out = (end >= 0) ? queue.substring(start, end) : ""; return out; }', '* @return Evaluator */ public static Evaluator parse(String query) { QueryParser p = new QueryParser(query); return p.parse(); } /**'], ['last = c; } while (depth > 0); final String out = (end >= 0) ? queue.substring(start, end) : ""; if (depth > 0) {// ran out of queue before seeing enough ) Validate.fail("Did not find balanced maker at " + out); } return out; }', '* @return Evaluator */ public static Evaluator parse(String query) { try { QueryParser p = new QueryParser(query); return p.parse(); } catch (IllegalArgumentException e) { throw new Selector.SelectorParseException(e.getMessage()); } } /**'], ['', ''], ['if (depth > 0) {// ran out of queue before seeing enough ) Validate.fail("Did not find balanced maker at " + out); }', 'try { } catch (IllegalArgumentException e) { throw new Selector.SelectorParseException(e.getMessage()); }'], 'a/src/main/java/org/jsoup/select/QueryParser.java', 'b/src/main/java/org/jsoup/select/QueryParser.java']
['Jsoup-61', 1, 1, 1, 1, ['*/ // performance sensitive public boolean hasClass(String className) { final String classAttr = attributes.get("class"); final int len = classAttr.length(); final int wantLen = className.length();'], ['*/ // performance sensitive public boolean hasClass(String className) { final String classAttr = attributes.getIgnoreCase("class"); final int len = classAttr.length(); final int wantLen = className.length();'], ['final String classAttr = attributes.get("class");'], ['final String classAttr = attributes.getIgnoreCase("class");'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-62', 1, 1, 1, 1, ['} boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = t.asEndTag().normalName(); ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos);'], ['} boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = t.asEndTag().name(); // matches with case sensitivity if enabled ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos);'], ['String name = t.asEndTag().normalName();'], ['String name = t.asEndTag().name(); // matches with case sensitivity if enabled'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-63', 5, 5, 5, 5, ['insertNode(el); if (startTag.isSelfClosing()) { if (tag.isKnownTag()) { if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); } else { tag.setSelfClosing(); tokeniser.acknowledgeSelfClosingFlag(); } } return el; }', 'Token.Doctype doctypePending = new Token.Doctype(); // doctype building up Token.Comment commentPending = new Token.Comment(); // comment building up private String lastStartTag; // the last start tag emitted, to test appropriate end tag private boolean selfClosingFlagAcknowledged = true; Tokeniser(CharacterReader reader, ParseErrorList errors) { this.reader = reader;', '} Token read() { if (!selfClosingFlagAcknowledged) { error("Self closing flag not acknowledged"); selfClosingFlagAcknowledged = true; } while (!isEmitPending) state.read(this, reader);', 'if (token.type == Token.TokenType.StartTag) { Token.StartTag startTag = (Token.StartTag) token; lastStartTag = startTag.tagName; if (startTag.selfClosing) selfClosingFlagAcknowledged = false; } else if (token.type == Token.TokenType.EndTag) { Token.EndTag endTag = (Token.EndTag) token; if (endTag.attributes != null)', 'this.state = state; } void acknowledgeSelfClosingFlag() { selfClosingFlagAcknowledged = true; } final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays final private int[] multipointHolder = new int[2]; int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {'], ['insertNode(el); if (startTag.isSelfClosing()) { if (tag.isKnownTag()) { if (!tag.isEmpty()) tokeniser.error("Tag cannot be self closing; not a void tag"); } else // unknown tag, remember this is self closing for output tag.setSelfClosing(); } return el; }', 'Token.Doctype doctypePending = new Token.Doctype(); // doctype building up Token.Comment commentPending = new Token.Comment(); // comment building up private String lastStartTag; // the last start tag emitted, to test appropriate end tag Tokeniser(CharacterReader reader, ParseErrorList errors) { this.reader = reader;', '} Token read() { while (!isEmitPending) state.read(this, reader);', 'if (token.type == Token.TokenType.StartTag) { Token.StartTag startTag = (Token.StartTag) token; lastStartTag = startTag.tagName; } else if (token.type == Token.TokenType.EndTag) { Token.EndTag endTag = (Token.EndTag) token; if (endTag.attributes != null)', 'this.state = state; } final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays final private int[] multipointHolder = new int[2]; int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {'], ['if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); else { tokeniser.acknowledgeSelfClosingFlag(); }', 'private boolean selfClosingFlagAcknowledged = true;', 'if (!selfClosingFlagAcknowledged) { error("Self closing flag not acknowledged"); selfClosingFlagAcknowledged = true; }', 'if (startTag.selfClosing) selfClosingFlagAcknowledged = false;', 'void acknowledgeSelfClosingFlag() { selfClosingFlagAcknowledged = true; }'], ['if (!tag.isEmpty()) tokeniser.error("Tag cannot be self closing; not a void tag"); else // unknown tag, remember this is self closing for output', '', '', '', ''], 'a/src/main/java/org/jsoup/parser/Tokeniser.java', 'b/src/main/java/org/jsoup/parser/Tokeniser.java']
['Jsoup-64', 1, 1, 1, 1, ['} private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) { tb.insert(startTag); tb.tokeniser.transition(TokeniserState.Rawtext); tb.markInsertionMode(); tb.transition(Text); } // lists of tags to search through. A little harder to read here, but causes less GC than dynamic varargs.'], ['} private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) { tb.tokeniser.transition(TokeniserState.Rawtext); tb.markInsertionMode(); tb.transition(Text); tb.insert(startTag); } // lists of tags to search through. A little harder to read here, but causes less GC than dynamic varargs.'], ['tb.insert(startTag);'], ['tb.insert(startTag);'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-65', 3, 3, 3, 3, ['} void clearStackToTableBodyContext() { clearStackToContext("tbody", "tfoot", "thead"); } void clearStackToTableRowContext() { clearStackToContext("tr"); } private void clearStackToContext(String... nodeNames) {', 'case StartTag: Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals("tr")) { tb.clearStackToTableBodyContext(); tb.insert(startTag); tb.transition(InRow);', 'Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (StringUtil.in(name, "th", "td")) { tb.clearStackToTableRowContext(); tb.insert(startTag); tb.transition(InCell);'], ['} void clearStackToTableBodyContext() { clearStackToContext("tbody", "tfoot", "thead", "template"); } void clearStackToTableRowContext() { clearStackToContext("tr", "template"); } private void clearStackToContext(String... nodeNames) {', 'case StartTag: Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals("template")) { tb.insert(startTag); } else if (name.equals("tr")) { tb.clearStackToTableBodyContext(); tb.insert(startTag); tb.transition(InRow);', 'Token.StartTag startTag = t.asStartTag(); String name = startTag.normalName(); if (name.equals("template")) { tb.insert(startTag); } else if (StringUtil.in(name, "th", "td")) { tb.clearStackToTableRowContext(); tb.insert(startTag); tb.transition(InCell);'], ['clearStackToContext("tbody", "tfoot", "thead"); clearStackToContext("tr");', 'if (name.equals("tr")) {', 'if (StringUtil.in(name, "th", "td")) {'], ['clearStackToContext("tbody", "tfoot", "thead", "template"); clearStackToContext("tr", "template");', 'if (name.equals("template")) { tb.insert(startTag); } else if (name.equals("tr")) {', 'if (name.equals("template")) { tb.insert(startTag); } else if (StringUtil.in(name, "th", "td")) {'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-66', 2, 2, 2, 2, [' protected List<Node> ensureChildNodes() { if (childNodes == EMPTY_NODES) { childNodes = new NodeList(4); } return childNodes; }', 'Element clone = (Element) super.doClone(parent); clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri; clone.childNodes = new NodeList(childNodes.size()); clone.childNodes.addAll(childNodes); return clone; } private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) { super(initialCapacity); } public void onContentsChanged() { nodelistChanged(); } } }'], [' protected List<Node> ensureChildNodes() { if (childNodes == EMPTY_NODES) { childNodes = new NodeList(this, 4); } return childNodes; }', 'Element clone = (Element) super.doClone(parent); clone.attributes = attributes != null ? attributes.clone() : null; clone.baseUri = baseUri; clone.childNodes = new NodeList(clone, childNodes.size()); clone.childNodes.addAll(childNodes); return clone; } private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity) { super(initialCapacity); this.owner = owner; } public void onContentsChanged() { owner.nodelistChanged(); } } }'], ['childNodes = new NodeList(4);', 'clone.childNodes = new NodeList(childNodes.size()); private final class NodeList extends ChangeNotifyingArrayList<Node> { NodeList(int initialCapacity) { nodelistChanged();'], ['childNodes = new NodeList(this, 4);', 'clone.childNodes = new NodeList(clone, childNodes.size()); private static final class NodeList extends ChangeNotifyingArrayList<Node> { private final Element owner; NodeList(Element owner, int initialCapacity) { this.owner = owner; owner.nodelistChanged();'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-67', 2, 2, 2, 2, ['"section", "select", "style", "summary", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "title", "tr", "ul", "wbr", "xmp"}); private HtmlTreeBuilderState state; // the current state private HtmlTreeBuilderState originalState; // original / marked state', ' private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { int depth = stack.size() -1; for (int pos = depth; pos >= 0; pos--) { Element el = stack.get(pos); String elName = el.nodeName();'], ['"section", "select", "style", "summary", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "title", "tr", "ul", "wbr", "xmp"}); public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages private HtmlTreeBuilderState state; // the current state private HtmlTreeBuilderState originalState; // original / marked state', ' private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { int depth = stack.size() -1; if (depth > MaxScopeSearchDepth) { depth = MaxScopeSearchDepth; } for (int pos = depth; pos >= 0; pos--) { Element el = stack.get(pos); String elName = el.nodeName();'], ['', ''], ['public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages', 'if (depth > MaxScopeSearchDepth) { depth = MaxScopeSearchDepth; }'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java']
['Jsoup-68', 1, 1, 1, 1, [" private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; // don't walk too far up the tree"], [" private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope final int bottom = stack.size() -1; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; // don't walk too far up the tree"], ['int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; }'], ['final int bottom = stack.size() -1;'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java']
['Jsoup-69', 1, 1, 1, 1, ['return this; } /** * Prepare to submit this form. A Connection object is created with the request set up from the form values. You'], ['return this; } @Override protected void removeChild(Node out) { super.removeChild(out); elements.remove(out); } /** * Prepare to submit this form. A Connection object is created with the request set up from the form values. You'], [''], ['@Override protected void removeChild(Node out) { super.removeChild(out); elements.remove(out); }'], 'a/src/main/java/org/jsoup/nodes/FormElement.java', 'b/src/main/java/org/jsoup/nodes/FormElement.java']
['Jsoup-70', 1, 1, 1, 1, ['// looks only at this element and five levels up, to prevent recursion & needless stack searches if (node != null && node instanceof Element) { Element el = (Element) node; if (el.tag.preserveWhitespace()) return true; else return el.parent() != null && el.parent().tag.preserveWhitespace(); } return false; }'], ['// looks only at this element and five levels up, to prevent recursion & needless stack searches if (node != null && node instanceof Element) { Element el = (Element) node; int i = 0; do { if (el.tag.preserveWhitespace()) return true; el = el.parent(); i++; } while (i < 6 && el != null); } return false; }'], ['else return el.parent() != null && el.parent().tag.preserveWhitespace();'], ['int i = 0; do { el = el.parent(); i++; } while (i < 6 && el != null);'], 'a/src/main/java/org/jsoup/nodes/Element.java', 'b/src/main/java/org/jsoup/nodes/Element.java']
['Jsoup-71', 2, 4, 4, 4, ['import org.jsoup.nodes.DocumentType; import org.jsoup.nodes.Element; import org.jsoup.nodes.Node; import org.jsoup.nodes.XmlDeclaration; import java.util.List;', 'evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else // unhandled throw new Selector.SelectorParseException("Could not parse query \'%s\': unexpected token at \'%s\'", query, tq.remainder());'], ['package org.jsoup.nodes; import org.jsoup.parser.Tag; import java.io.IOException; /** * Represents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with * the {@link org.jsoup.select.Selector} {@code :matchText} syntax. */ public class PseudoTextElement extends Element { public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) { super(tag, baseUri, attributes); } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException { } }', 'import org.jsoup.nodes.DocumentType; import org.jsoup.nodes.Element; import org.jsoup.nodes.Node; import org.jsoup.nodes.PseudoTextElement; import org.jsoup.nodes.TextNode; import org.jsoup.nodes.XmlDeclaration; import java.util.List;', '} } public static final class MatchText extends Evaluator { @Override public boolean matches(Element root, Element element) { if (element instanceof PseudoTextElement) return true; List<TextNode> textNodes = element.textNodes(); for (TextNode textNode : textNodes) { PseudoTextElement pel = new PseudoTextElement( org.jsoup.parser.Tag.valueOf(element.tagName()), element.baseUri(), element.attributes()); textNode.replaceWith(pel); pel.appendChild(textNode); } return false; } @Override public String toString() { return ":matchText"; } } }', 'evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else if (tq.matchChomp(":matchText")) evals.add(new Evaluator.MatchText()); else // unhandled throw new Selector.SelectorParseException("Could not parse query \'%s\': unexpected token at \'%s\'", query, tq.remainder());'], ['', '', '', ''], ['package org.jsoup.nodes; import org.jsoup.parser.Tag; import java.io.IOException; /** * Represents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with * the {@link org.jsoup.select.Selector} {@code :matchText} syntax. */ public class PseudoTextElement extends Element { public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) { super(tag, baseUri, attributes); } @Override void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException { } @Override void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException { } }', 'import org.jsoup.nodes.PseudoTextElement; import org.jsoup.nodes.TextNode;', 'public static final class MatchText extends Evaluator { @Override public boolean matches(Element root, Element element) { if (element instanceof PseudoTextElement) return true; List<TextNode> textNodes = element.textNodes(); for (TextNode textNode : textNodes) { PseudoTextElement pel = new PseudoTextElement( org.jsoup.parser.Tag.valueOf(element.tagName()), element.baseUri(), element.attributes()); textNode.replaceWith(pel); pel.appendChild(textNode); } return false; } @Override public String toString() { return ":matchText"; } }', 'else if (tq.matchChomp(":matchText")) evals.add(new Evaluator.MatchText());'], 'a/src/main/java/org/jsoup/select/QueryParser.java', 'b/src/main/java/org/jsoup/select/QueryParser.java']
['Jsoup-72', 1, 1, 1, 1, ['// limit (no cache): if (count > maxStringCacheLen) return new String(charBuf, start, count); // calculate hash: int hash = 0;'], ['// limit (no cache): if (count > maxStringCacheLen) return new String(charBuf, start, count); if (count < 1) return ""; // calculate hash: int hash = 0;'], [''], ['if (count < 1) return "";'], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-73', 4, 4, 4, 4, ['import javax.xml.transform.stream.StreamResult; import java.io.StringWriter; import java.util.HashMap; /** * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},', 'private static final String xmlnsPrefix = "xmlns:"; private final Document doc; private final HashMap<String, String> namespaces = new HashMap<>(); private Element dest; public W3CBuilder(Document doc) { this.doc = doc; } public void head(org.jsoup.nodes.Node source, int depth) { if (source instanceof org.jsoup.nodes.Element) { org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source; String prefix = updateNamespaces(sourceEl); String namespace = namespaces.get(prefix); Element el = doc.createElementNS(namespace, sourceEl.tagName()); copyAttributes(sourceEl, el);', 'if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) { dest = (Element) dest.getParentNode(); // undescend. cromulent. } } private void copyAttributes(org.jsoup.nodes.Node source, Element el) {', '} else { continue; } namespaces.put(prefix, attr.getValue()); } // get the element prefix if any'], ['import javax.xml.transform.stream.StreamResult; import java.io.StringWriter; import java.util.HashMap; import java.util.Stack; /** * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},', 'private static final String xmlnsPrefix = "xmlns:"; private final Document doc; private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn private Element dest; public W3CBuilder(Document doc) { this.doc = doc; this.namespacesStack.push(new HashMap<String, String>()); } public void head(org.jsoup.nodes.Node source, int depth) { namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack if (source instanceof org.jsoup.nodes.Element) { org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source; String prefix = updateNamespaces(sourceEl); String namespace = namespacesStack.peek().get(prefix); Element el = doc.createElementNS(namespace, sourceEl.tagName()); copyAttributes(sourceEl, el);', 'if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) { dest = (Element) dest.getParentNode(); // undescend. cromulent. } namespacesStack.pop(); } private void copyAttributes(org.jsoup.nodes.Node source, Element el) {', '} else { continue; } namespacesStack.peek().put(prefix, attr.getValue()); } // get the element prefix if any'], ['', 'private final HashMap<String, String> namespaces = new HashMap<>(); String namespace = namespaces.get(prefix);', '', 'namespaces.put(prefix, attr.getValue());'], ['import java.util.Stack;', 'private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn this.namespacesStack.push(new HashMap<String, String>()); namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack String namespace = namespacesStack.peek().get(prefix);', 'namespacesStack.pop();', 'namespacesStack.peek().put(prefix, attr.getValue());'], 'a/src/main/java/org/jsoup/helper/W3CDom.java', 'b/src/main/java/org/jsoup/helper/W3CDom.java']
['Jsoup-74', 2, 2, 2, 2, ['// 160 is &nbsp; (non-breaking space). Not in the spec but expected. } // zero width sp, zw non join, zw join, soft hyphen /** * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters', "accum.append(' '); lastWasWhite = true; } else { accum.appendCodePoint(c); lastWasWhite = false; reachedNonWhite = true;"], ['// 160 is &nbsp; (non-breaking space). Not in the spec but expected. } public static boolean isInvisibleChar(int c) { return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173); // zero width sp, zw non join, zw join, soft hyphen } /** * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters', "accum.append(' '); lastWasWhite = true; } else if (!isInvisibleChar(c)) { accum.appendCodePoint(c); lastWasWhite = false; reachedNonWhite = true;"], ['', 'else {'], ['public static boolean isInvisibleChar(int c) { return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173); }', 'else if (!isInvisibleChar(c)) {'], 'a/src/main/java/org/jsoup/helper/StringUtil.java', 'b/src/main/java/org/jsoup/helper/StringUtil.java']
['Jsoup-75', 1, 1, 1, 1, ['accum.append(\' \').append(key); // collapse checked=null, checked="", checked=checked; write out others if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { accum.append("=\\""); Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false); accum.append(\'"\');'], ['accum.append(\' \').append(key); // collapse checked=null, checked="", checked=checked; write out others if (!Attribute.shouldCollapseAttribute(key, val, out)) { accum.append("=\\""); Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false); accum.append(\'"\');'], ['if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {'], ['if (!Attribute.shouldCollapseAttribute(key, val, out)) {'], 'a/src/main/java/org/jsoup/nodes/Attributes.java', 'b/src/main/java/org/jsoup/nodes/Attributes.java']
['Jsoup-76', 1, 1, 1, 1, ['tb.processEndTag("p"); } tb.insert(startTag); tb.framesetOk(false); } else if (name.equals("form")) { if (tb.getFormElement() != null) {'], ['tb.processEndTag("p"); } tb.insert(startTag); tb.reader.matchConsume("\\n"); // ignore LF if next token tb.framesetOk(false); } else if (name.equals("form")) { if (tb.getFormElement() != null) {'], [''], ['tb.reader.matchConsume("\\n"); // ignore LF if next token'], 'a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java', 'b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java']
['Jsoup-77', 1, 1, 1, 1, ['* @param endTag tag to close */ private void popStackToClose(Token.EndTag endTag) { String elName = endTag.name(); Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) {'], ['* @param endTag tag to close */ private void popStackToClose(Token.EndTag endTag) { String elName = endTag.normalName(); Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) {'], ['String elName = endTag.name();'], ['String elName = endTag.normalName();'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-78', 2, 2, 2, 2, ['package org.jsoup.helper; import org.jsoup.internal.ConstrainableInputStream; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element;', 'if (charsetName == null) charsetName = defaultCharset; BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize); doc = parser.parseInput(reader, baseUri); // io exception when parsing (not seen before because reading the stream as we go) doc.outputSettings().charset(charsetName); } input.close();'], ['package org.jsoup.helper; import org.jsoup.UncheckedIOException; import org.jsoup.internal.ConstrainableInputStream; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element;', 'if (charsetName == null) charsetName = defaultCharset; BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize); try { doc = parser.parseInput(reader, baseUri); } catch (UncheckedIOException e) { // io exception when parsing (not seen before because reading the stream as we go) throw e.ioException(); } doc.outputSettings().charset(charsetName); } input.close();'], ['', ''], ['import org.jsoup.UncheckedIOException;', 'try { } catch (UncheckedIOException e) { throw e.ioException(); }'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-79', 2, 2, 2, 2, [' import org.jsoup.helper.Validate; import java.util.List; abstract class LeafNode extends Node { Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)', ' @Override protected List<Node> ensureChildNodes() { throw new UnsupportedOperationException("Leaf Nodes do not have child nodes."); } }'], [' import org.jsoup.helper.Validate; import java.util.Collections; import java.util.List; abstract class LeafNode extends Node { private static final List<Node> EmptyNodes = Collections.emptyList(); Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)', ' @Override protected List<Node> ensureChildNodes() { return EmptyNodes; } }'], ['', 'throw new UnsupportedOperationException("Leaf Nodes do not have child nodes.");'], ['import java.util.Collections; private static final List<Node> EmptyNodes = Collections.emptyList();', 'return EmptyNodes;'], 'a/src/main/java/org/jsoup/nodes/LeafNode.java', 'b/src/main/java/org/jsoup/nodes/LeafNode.java']
['Jsoup-80', 1, 1, 1, 1, ['String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser()); Element el = doc.child(0); insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith("!")); insert.attributes().addAll(el.attributes()); } } insertNode(insert);'], ['String data = comment.getData(); if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) { Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser()); if (doc.childNodeSize() > 0) { Element el = doc.child(0); insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith("!")); insert.attributes().addAll(el.attributes()); } // else, we couldn\'t parse it as a decl, so leave as a comment } } insertNode(insert);'], [''], ["if (doc.childNodeSize() > 0) { } // else, we couldn't parse it as a decl, so leave as a comment"], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-81', 2, 2, 2, 2, [' import org.jsoup.UncheckedIOException; import org.jsoup.internal.ConstrainableInputStream; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element; import org.jsoup.nodes.Node;', 'XmlDeclaration decl = null; if (first instanceof XmlDeclaration) decl = (XmlDeclaration) first; if (decl != null) { if (decl.name().equalsIgnoreCase("xml")) foundCharset = decl.attr("encoding");'], [' import org.jsoup.UncheckedIOException; import org.jsoup.internal.ConstrainableInputStream; import org.jsoup.nodes.Comment; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element; import org.jsoup.nodes.Node;', 'XmlDeclaration decl = null; if (first instanceof XmlDeclaration) decl = (XmlDeclaration) first; else if (first instanceof Comment) { Comment comment = (Comment) first; if (comment.isXmlDeclaration()) decl = comment.asXmlDeclaration(); } if (decl != null) { if (decl.name().equalsIgnoreCase("xml")) foundCharset = decl.attr("encoding");'], ['', ''], ['import org.jsoup.nodes.Comment;', 'else if (first instanceof Comment) { Comment comment = (Comment) first; if (comment.isXmlDeclaration()) decl = comment.asXmlDeclaration(); }'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-82', 1, 1, 1, 1, ['} Charset charset = Charset.forName(charsetName); doc.outputSettings().charset(charset); // some charsets can read but not encode; switch to an encodable charset and update the meta el } input.close(); return doc;'], ['} Charset charset = Charset.forName(charsetName); doc.outputSettings().charset(charset); if (!charset.canEncode()) { // some charsets can read but not encode; switch to an encodable charset and update the meta el doc.charset(Charset.forName(defaultCharset)); } } input.close(); return doc;'], [''], ['if (!charset.canEncode()) { doc.charset(Charset.forName(defaultCharset)); }'], 'a/src/main/java/org/jsoup/helper/DataUtil.java', 'b/src/main/java/org/jsoup/helper/DataUtil.java']
['Jsoup-83', 4, 4, 4, 4, [" while (bufPos < remaining) { final char c = val[bufPos]; if (c == '\\t'|| c == '\\n'|| c == '\\r'|| c == '\\f'|| c == ' '|| c == '/'|| c == '>'|| c == TokeniserState.nullChar) break; bufPos++; }", "case '/': t.transition(SelfClosingStartTag); break; // intended fall through to next > case '>': t.emitTagPending();", "case '/': t.transition(SelfClosingStartTag); break; // intended fall through as if > case '>': t.emitTagPending();", 'break; case \'"\': case \'\\\'\': case \'<\': case \'=\': t.error(this); t.tagPending.newAttribute();'], [" while (bufPos < remaining) { final char c = val[bufPos]; if (c == '\\t'|| c == '\\n'|| c == '\\r'|| c == '\\f'|| c == ' '|| c == '/'|| c == '>'|| c == '<' || c == TokeniserState.nullChar) break; bufPos++; }", "case '/': t.transition(SelfClosingStartTag); break; case '<': // NOTE: out of spec, but clear author intent t.error(this); r.unconsume(); // intended fall through to next > case '>': t.emitTagPending();", "case '/': t.transition(SelfClosingStartTag); break; case '<': // NOTE: out of spec, but clear (spec has this as a part of the attribute name) t.error(this); r.unconsume(); // intended fall through as if > case '>': t.emitTagPending();", 'break; case \'"\': case \'\\\'\': case \'=\': t.error(this); t.tagPending.newAttribute();'], ["if (c == '\\t'|| c == '\\n'|| c == '\\r'|| c == '\\f'|| c == ' '|| c == '/'|| c == '>'|| c == TokeniserState.nullChar)", '', '', "case '<':"], ["if (c == '\\t'|| c == '\\n'|| c == '\\r'|| c == '\\f'|| c == ' '|| c == '/'|| c == '>'|| c == '<' || c == TokeniserState.nullChar)", "case '<': // NOTE: out of spec, but clear author intent t.error(this); r.unconsume();", "case '<': // NOTE: out of spec, but clear (spec has this as a part of the attribute name) t.error(this); r.unconsume();", ''], 'a/src/main/java/org/jsoup/parser/TokeniserState.java', 'b/src/main/java/org/jsoup/parser/TokeniserState.java']
['Jsoup-84', 1, 1, 1, 1, ['String namespace = namespacesStack.peek().get(prefix); String tagName = sourceEl.tagName(); Element el = doc.createElementNS(namespace, tagName); copyAttributes(sourceEl, el); if (dest == null) { // sets up the root'], ['String namespace = namespacesStack.peek().get(prefix); String tagName = sourceEl.tagName(); Element el = namespace == null && tagName.contains(":") ? doc.createElementNS("", tagName) : // doesn\'t have a real namespace defined doc.createElementNS(namespace, tagName); copyAttributes(sourceEl, el); if (dest == null) { // sets up the root'], ['Element el ='], ['Element el = namespace == null && tagName.contains(":") ? doc.createElementNS("", tagName) : // doesn\'t have a real namespace defined'], 'a/src/main/java/org/jsoup/helper/W3CDom.java', 'b/src/main/java/org/jsoup/helper/W3CDom.java']
['Jsoup-85', 1, 1, 1, 1, ['* @see #createFromEncoded*/ public Attribute(String key, String val, Attributes parent) { Validate.notNull(key); this.key = key.trim(); Validate.notEmpty(key); // trimming could potentially make empty, so validate here this.val = val; this.parent = parent; }'], ['* @see #createFromEncoded*/ public Attribute(String key, String val, Attributes parent) { Validate.notNull(key); key = key.trim(); Validate.notEmpty(key); // trimming could potentially make empty, so validate here this.key = key; this.val = val; this.parent = parent; }'], ['this.key = key.trim();'], ['key = key.trim(); this.key = key;'], 'a/src/main/java/org/jsoup/nodes/Attribute.java', 'b/src/main/java/org/jsoup/nodes/Attribute.java']
['Jsoup-86', 1, 1, 1, 1, ['String data = getData(); Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; if (doc.childNodeSize() > 0) { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith("!")); decl.attributes().addAll(el.attributes());'], ['String data = getData(); Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; if (doc.children().size() > 0) { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith("!")); decl.attributes().addAll(el.attributes());'], ['if (doc.childNodeSize() > 0) {'], ['if (doc.children().size() > 0) {'], 'a/src/main/java/org/jsoup/nodes/Comment.java', 'b/src/main/java/org/jsoup/nodes/Comment.java']
['Jsoup-87', 47, 47, 47, 47, ['* of the tag case preserving setting of the parser. * @return */ /** * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with', 'Element getFromStack(String elName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { return next; } }', 'for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next.nodeName().equals(elName)) break; } }', 'for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (inSorted(next.nodeName(), elNames)) break; } }', 'void popStackToBefore(String elName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { break; } else { stack.remove(pos);', 'private void clearStackToContext(String... nodeNames) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals("html")) break; else stack.remove(pos);', 'last = true; node = contextElement; } String name = node.nodeName(); if ("select".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; // frag', "// don't walk too far up the tree for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes))", 'boolean inSelectScope(String targetName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element el = stack.get(pos); String elName = el.nodeName(); if (elName.equals(targetName)) return true; if (!inSorted(elName, TagSearchSelectScope)) // all elements except', 'process, then the UA must perform the above steps as if that element was not in the above list. */ void generateImpliedEndTags(String excludeTag) { while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) && inSorted(currentElement().nodeName(), TagSearchEndTags)) pop(); }', "boolean isSpecial(Element el) { // todo: mathml's mi, mo, mn // todo: svg's foreigObject, desc, title String name = el.nodeName(); return inSorted(name, TagSearchSpecial); }", ' private boolean isSameFormattingElement(Element a, Element b) { // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children return a.nodeName().equals(b.nodeName()) && // a.namespace().equals(b.namespace()) && a.attributes().equals(b.attributes()); // todo: namespaces', ' // 8. create new element from element, 9 insert into current node, onto stack skip = false; // can only skip increment from 4. Element newEl = insertStartTag(entry.nodeName()); // newEl.namespace(entry.namespace()); // todo: namespaces newEl.attributes().addAll(entry.attributes());', 'Element next = formattingElements.get(pos); if (next == null) // scope marker break; else if (next.nodeName().equals(nodeName)) return next; } return null;', 'ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (el.nodeName().equals("li")) { tb.processEndTag("li"); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope("p")) {', '} else if (name.equals("body")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) { // only in fragment case return false; // ignore } else {', '} else if (name.equals("frameset")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) { // only in fragment case return false; // ignore } else if (!tb.framesetOk()) {', 'if (tb.inButtonScope("p")) { tb.processEndTag("p"); } if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) { tb.error(this); tb.pop(); }', 'ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) { tb.processEndTag(el.nodeName()); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope("p")) {', 'else tb.transition(InSelect); } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) { if (tb.currentElement().nodeName().equals("option")) tb.processEndTag("option"); tb.reconstructFormattingElements(); tb.insert(startTag); } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) { if (tb.inScope("ruby")) { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals("ruby")) { tb.error(this); tb.popStackToBefore("ruby"); // i.e. close up to but not include name }', 'tb.error(this); tb.removeFromActiveFormattingElements(formatEl); return true; } else if (!tb.inScope(formatEl.nodeName())) { tb.error(this); return false; } else if (tb.currentElement() != formatEl)', '} } if (furthestBlock == null) { tb.popStackToClose(formatEl.nodeName()); tb.removeFromActiveFormattingElements(formatEl); return true; }', 'lastNode = node; } if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) { if (lastNode.parent() != null) lastNode.remove(); tb.insertInFosterParent(lastNode);', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); // remove currentForm from stack. will shift anything under up. tb.removeFromStack(currentForm);', 'return tb.process(endTag); } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(Constants.Headings); }', 'return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker();', '} boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = tb.settings.normalizeTag(t.asEndTag().name()); ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (node.nodeName().equals(name)) { tb.generateImpliedEndTags(name); if (!name.equals(tb.currentElement().nodeName())) tb.error(this); tb.popStackToClose(name); break;', '} return true; // todo: as above todo } else if (t.isEOF()) { if (tb.currentElement().nodeName().equals("html")) tb.error(this); return true; // stops parsing }', 'boolean anythingElse(Token t, HtmlTreeBuilder tb) { tb.error(this); boolean processed; if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) { tb.setFosterInserts(true); processed = tb.process(t, InBody); tb.setFosterInserts(false);', 'if (!isWhitespace(character)) { // InTable anything else section: tb.error(this); if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) { tb.setFosterInserts(true); tb.process(new Token.Character().data(character), InBody); tb.setFosterInserts(false);', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals("caption")) tb.error(this); tb.popStackToClose("caption"); tb.clearFormattingElementsToLastMarker();', 'case EndTag: Token.EndTag endTag = t.asEndTag(); if (endTag.normalName.equals("colgroup")) { if (tb.currentElement().nodeName().equals("html")) { tb.error(this); return false; } else {', 'return anythingElse(t, tb); break; case EOF: if (tb.currentElement().nodeName().equals("html")) return true; // stop parsing; frag case else return anythingElse(t, tb);', 'return false; } tb.clearStackToTableBodyContext(); tb.processEndTag(tb.currentElement().nodeName()); return tb.process(t); }', 'return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker();', 'if (name.equals("html")) return tb.process(start, InBody); else if (name.equals("option")) { if (tb.currentElement().nodeName().equals("option")) tb.processEndTag("option"); tb.insert(start); } else if (name.equals("optgroup")) { if (tb.currentElement().nodeName().equals("option")) tb.processEndTag("option"); else if (tb.currentElement().nodeName().equals("optgroup")) tb.processEndTag("optgroup"); tb.insert(start); } else if (name.equals("select")) {', 'name = end.normalName(); switch (name) { case "optgroup": if (tb.currentElement().nodeName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals("optgroup")) tb.processEndTag("option"); if (tb.currentElement().nodeName().equals("optgroup")) tb.pop(); else tb.error(this); break; case "option": if (tb.currentElement().nodeName().equals("option")) tb.pop(); else tb.error(this);', '} break; case EOF: if (!tb.currentElement().nodeName().equals("html")) tb.error(this); break; default:', 'return false; } } else if (t.isEndTag() && t.asEndTag().normalName().equals("frameset")) { if (tb.currentElement().nodeName().equals("html")) { tb.error(this); return false; } else { tb.pop(); if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals("frameset")) { tb.transition(AfterFrameset); } } } else if (t.isEOF()) { if (!tb.currentElement().nodeName().equals("html")) { tb.error(this); return true; }', 'package org.jsoup.parser; import org.jsoup.helper.Validate; import java.util.HashMap; import java.util.Map;', 'private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags private String tagName; private boolean isBlock = true; // block or inline private boolean formatAsBlock = true; // should be formatted as a block private boolean canContainInline = true; // only pcdata if not', ' private Tag(String tagName) { this.tagName = tagName; } /**', "* Get this tag's normalized (lowercased) name. * @return the tag's normal name. */ /** * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything."], ['* of the tag case preserving setting of the parser. * @return */ public String normalName() { return tag.normalName(); } /** * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with', 'Element getFromStack(String elName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.normalName().equals(elName)) { return next; } }', 'for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next.normalName().equals(elName)) break; } }', 'for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (inSorted(next.normalName(), elNames)) break; } }', 'void popStackToBefore(String elName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.normalName().equals(elName)) { break; } else { stack.remove(pos);', 'private void clearStackToContext(String... nodeNames) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals("html")) break; else stack.remove(pos);', 'last = true; node = contextElement; } String name = node.normalName(); if ("select".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; // frag', "// don't walk too far up the tree for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).normalName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes))", 'boolean inSelectScope(String targetName) { for (int pos = stack.size() -1; pos >= 0; pos--) { Element el = stack.get(pos); String elName = el.normalName(); if (elName.equals(targetName)) return true; if (!inSorted(elName, TagSearchSelectScope)) // all elements except', 'process, then the UA must perform the above steps as if that element was not in the above list. */ void generateImpliedEndTags(String excludeTag) { while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) && inSorted(currentElement().normalName(), TagSearchEndTags)) pop(); }', "boolean isSpecial(Element el) { // todo: mathml's mi, mo, mn // todo: svg's foreigObject, desc, title String name = el.normalName(); return inSorted(name, TagSearchSpecial); }", ' private boolean isSameFormattingElement(Element a, Element b) { // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children return a.normalName().equals(b.normalName()) && // a.namespace().equals(b.namespace()) && a.attributes().equals(b.attributes()); // todo: namespaces', ' // 8. create new element from element, 9 insert into current node, onto stack skip = false; // can only skip increment from 4. Element newEl = insertStartTag(entry.normalName()); // todo: avoid fostering here? // newEl.namespace(entry.namespace()); // todo: namespaces newEl.attributes().addAll(entry.attributes());', 'Element next = formattingElements.get(pos); if (next == null) // scope marker break; else if (next.normalName().equals(nodeName)) return next; } return null;', 'ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (el.normalName().equals("li")) { tb.processEndTag("li"); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope("p")) {', '} else if (name.equals("body")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) { // only in fragment case return false; // ignore } else {', '} else if (name.equals("frameset")) { tb.error(this); ArrayList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) { // only in fragment case return false; // ignore } else if (!tb.framesetOk()) {', 'if (tb.inButtonScope("p")) { tb.processEndTag("p"); } if (StringUtil.inSorted(tb.currentElement().normalName(), Constants.Headings)) { tb.error(this); tb.pop(); }', 'ArrayList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (StringUtil.inSorted(el.normalName(), Constants.DdDt)) { tb.processEndTag(el.normalName()); break; } if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers)) break; } if (tb.inButtonScope("p")) {', 'else tb.transition(InSelect); } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) { if (tb.currentElement().normalName().equals("option")) tb.processEndTag("option"); tb.reconstructFormattingElements(); tb.insert(startTag); } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) { if (tb.inScope("ruby")) { tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals("ruby")) { tb.error(this); tb.popStackToBefore("ruby"); // i.e. close up to but not include name }', 'tb.error(this); tb.removeFromActiveFormattingElements(formatEl); return true; } else if (!tb.inScope(formatEl.normalName())) { tb.error(this); return false; } else if (tb.currentElement() != formatEl)', '} } if (furthestBlock == null) { tb.popStackToClose(formatEl.normalName()); tb.removeFromActiveFormattingElements(formatEl); return true; }', 'lastNode = node; } if (StringUtil.inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) { if (lastNode.parent() != null) lastNode.remove(); tb.insertInFosterParent(lastNode);', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals(name)) tb.error(this); // remove currentForm from stack. will shift anything under up. tb.removeFromStack(currentForm);', 'return tb.process(endTag); } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); }', 'return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(Constants.Headings); }', 'return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker();', '} boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { String name = t.asEndTag().normalName; // case insensitive search - goal is to preserve output case, not for the parse to be case sensitive ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (node.normalName().equals(name)) { tb.generateImpliedEndTags(name); if (!name.equals(tb.currentElement().normalName())) tb.error(this); tb.popStackToClose(name); break;', '} return true; // todo: as above todo } else if (t.isEOF()) { if (tb.currentElement().normalName().equals("html")) tb.error(this); return true; // stops parsing }', 'boolean anythingElse(Token t, HtmlTreeBuilder tb) { tb.error(this); boolean processed; if (StringUtil.in(tb.currentElement().normalName(), "table", "tbody", "tfoot", "thead", "tr")) { tb.setFosterInserts(true); processed = tb.process(t, InBody); tb.setFosterInserts(false);', 'if (!isWhitespace(character)) { // InTable anything else section: tb.error(this); if (StringUtil.in(tb.currentElement().normalName(), "table", "tbody", "tfoot", "thead", "tr")) { tb.setFosterInserts(true); tb.process(new Token.Character().data(character), InBody); tb.setFosterInserts(false);', 'return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals("caption")) tb.error(this); tb.popStackToClose("caption"); tb.clearFormattingElementsToLastMarker();', 'case EndTag: Token.EndTag endTag = t.asEndTag(); if (endTag.normalName.equals("colgroup")) { if (tb.currentElement().normalName().equals("html")) { // frag case tb.error(this); return false; } else {', 'return anythingElse(t, tb); break; case EOF: if (tb.currentElement().normalName().equals("html")) return true; // stop parsing; frag case else return anythingElse(t, tb);', 'return false; } tb.clearStackToTableBodyContext(); tb.processEndTag(tb.currentElement().normalName()); // tbody, tfoot, thead return tb.process(t); }', 'return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().normalName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker();', 'if (name.equals("html")) return tb.process(start, InBody); else if (name.equals("option")) { if (tb.currentElement().normalName().equals("option")) tb.processEndTag("option"); tb.insert(start); } else if (name.equals("optgroup")) { if (tb.currentElement().normalName().equals("option")) tb.processEndTag("option"); else if (tb.currentElement().normalName().equals("optgroup")) tb.processEndTag("optgroup"); tb.insert(start); } else if (name.equals("select")) {', 'name = end.normalName(); switch (name) { case "optgroup": if (tb.currentElement().normalName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals("optgroup")) tb.processEndTag("option"); if (tb.currentElement().normalName().equals("optgroup")) tb.pop(); else tb.error(this); break; case "option": if (tb.currentElement().normalName().equals("option")) tb.pop(); else tb.error(this);', '} break; case EOF: if (!tb.currentElement().normalName().equals("html")) tb.error(this); break; default:', 'return false; } } else if (t.isEndTag() && t.asEndTag().normalName().equals("frameset")) { if (tb.currentElement().normalName().equals("html")) { // frag tb.error(this); return false; } else { tb.pop(); if (!tb.isFragmentParsing() && !tb.currentElement().normalName().equals("frameset")) { tb.transition(AfterFrameset); } } } else if (t.isEOF()) { if (!tb.currentElement().normalName().equals("html")) { tb.error(this); return true; }', 'package org.jsoup.parser; import org.jsoup.helper.Validate; import org.jsoup.internal.Normalizer; import java.util.HashMap; import java.util.Map;', 'private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags private String tagName; private String normalName; // always the lower case version of this tag, regardless of case preservation mode private boolean isBlock = true; // block or inline private boolean formatAsBlock = true; // should be formatted as a block private boolean canContainInline = true; // only pcdata if not', ' private Tag(String tagName) { this.tagName = tagName; normalName = Normalizer.lowerCase(tagName); } /**', "* Get this tag's normalized (lowercased) name. * @return the tag's normal name. */ public String normalName() { return normalName; } /** * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything."], ['', 'if (next.nodeName().equals(elName)) {', 'if (next.nodeName().equals(elName))', 'if (inSorted(next.nodeName(), elNames))', 'if (next.nodeName().equals(elName)) {', 'if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals("html"))', 'String name = node.nodeName();', 'final String elName = stack.get(pos).nodeName();', 'String elName = el.nodeName();', 'while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) && inSorted(currentElement().nodeName(), TagSearchEndTags))', 'String name = el.nodeName();', 'return a.nodeName().equals(b.nodeName()) &&', 'Element newEl = insertStartTag(entry.nodeName());', 'else if (next.nodeName().equals(nodeName))', 'if (el.nodeName().equals("li")) { if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))', 'if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {', 'if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {', 'if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {', 'if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) { tb.processEndTag(el.nodeName()); if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))', 'if (tb.currentElement().nodeName().equals("option")) if (!tb.currentElement().nodeName().equals("ruby")) {', '} else if (!tb.inScope(formatEl.nodeName())) {', 'tb.popStackToClose(formatEl.nodeName());', 'if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'if (!tb.currentElement().nodeName().equals(name))', 'String name = tb.settings.normalizeTag(t.asEndTag().name()); if (node.nodeName().equals(name)) { if (!name.equals(tb.currentElement().nodeName()))', 'if (tb.currentElement().nodeName().equals("html"))', 'if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {', 'if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {', 'if (!tb.currentElement().nodeName().equals("caption"))', 'if (tb.currentElement().nodeName().equals("html")) {', 'if (tb.currentElement().nodeName().equals("html"))', 'tb.processEndTag(tb.currentElement().nodeName());', 'if (!tb.currentElement().nodeName().equals(name))', 'if (tb.currentElement().nodeName().equals("option")) if (tb.currentElement().nodeName().equals("option")) else if (tb.currentElement().nodeName().equals("optgroup"))', 'if (tb.currentElement().nodeName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals("optgroup")) if (tb.currentElement().nodeName().equals("optgroup")) if (tb.currentElement().nodeName().equals("option"))', 'if (!tb.currentElement().nodeName().equals("html"))', 'if (tb.currentElement().nodeName().equals("html")) { if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals("frameset")) { if (!tb.currentElement().nodeName().equals("html")) {', '', '', '', ''], ['public String normalName() { return tag.normalName(); }', 'if (next.normalName().equals(elName)) {', 'if (next.normalName().equals(elName))', 'if (inSorted(next.normalName(), elNames))', 'if (next.normalName().equals(elName)) {', 'if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals("html"))', 'String name = node.normalName();', 'final String elName = stack.get(pos).normalName();', 'String elName = el.normalName();', 'while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) && inSorted(currentElement().normalName(), TagSearchEndTags))', 'String name = el.normalName();', 'return a.normalName().equals(b.normalName()) &&', 'Element newEl = insertStartTag(entry.normalName()); // todo: avoid fostering here?', 'else if (next.normalName().equals(nodeName))', 'if (el.normalName().equals("li")) { if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))', 'if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) {', 'if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) {', 'if (StringUtil.inSorted(tb.currentElement().normalName(), Constants.Headings)) {', 'if (StringUtil.inSorted(el.normalName(), Constants.DdDt)) { tb.processEndTag(el.normalName()); if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))', 'if (tb.currentElement().normalName().equals("option")) if (!tb.currentElement().normalName().equals("ruby")) {', '} else if (!tb.inScope(formatEl.normalName())) {', 'tb.popStackToClose(formatEl.normalName());', 'if (StringUtil.inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) {', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'if (!tb.currentElement().normalName().equals(name))', 'String name = t.asEndTag().normalName; // case insensitive search - goal is to preserve output case, not for the parse to be case sensitive if (node.normalName().equals(name)) { if (!name.equals(tb.currentElement().normalName()))', 'if (tb.currentElement().normalName().equals("html"))', 'if (StringUtil.in(tb.currentElement().normalName(), "table", "tbody", "tfoot", "thead", "tr")) {', 'if (StringUtil.in(tb.currentElement().normalName(), "table", "tbody", "tfoot", "thead", "tr")) {', 'if (!tb.currentElement().normalName().equals("caption"))', 'if (tb.currentElement().normalName().equals("html")) { // frag case', 'if (tb.currentElement().normalName().equals("html"))', 'tb.processEndTag(tb.currentElement().normalName()); // tbody, tfoot, thead', 'if (!tb.currentElement().normalName().equals(name))', 'if (tb.currentElement().normalName().equals("option")) if (tb.currentElement().normalName().equals("option")) else if (tb.currentElement().normalName().equals("optgroup"))', 'if (tb.currentElement().normalName().equals("option") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals("optgroup")) if (tb.currentElement().normalName().equals("optgroup")) if (tb.currentElement().normalName().equals("option"))', 'if (!tb.currentElement().normalName().equals("html"))', 'if (tb.currentElement().normalName().equals("html")) { // frag if (!tb.isFragmentParsing() && !tb.currentElement().normalName().equals("frameset")) { if (!tb.currentElement().normalName().equals("html")) {', 'import org.jsoup.internal.Normalizer;', 'private String normalName; // always the lower case version of this tag, regardless of case preservation mode', 'normalName = Normalizer.lowerCase(tagName);', 'public String normalName() { return normalName; }'], 'a/src/main/java/org/jsoup/parser/Tag.java', 'b/src/main/java/org/jsoup/parser/Tag.java']
['Jsoup-88', 1, 1, 1, 1, ['@return the attribute value */ public String getValue() { return val; } /**'], ['@return the attribute value */ public String getValue() { return Attributes.checkNotNull(val); } /**'], ['return val;'], ['return Attributes.checkNotNull(val);'], 'a/src/main/java/org/jsoup/nodes/Attribute.java', 'b/src/main/java/org/jsoup/nodes/Attribute.java']
['Jsoup-89', 1, 1, 1, 1, ['@param val the new attribute value; must not be null */ public String setValue(String val) { String oldVal = parent.get(this.key); if (parent != null) { int i = parent.indexOfKey(this.key); if (i != Attributes.NotFound) parent.vals[i] = val;'], ['@param val the new attribute value; must not be null */ public String setValue(String val) { String oldVal = this.val; if (parent != null) { oldVal = parent.get(this.key); // trust the container more int i = parent.indexOfKey(this.key); if (i != Attributes.NotFound) parent.vals[i] = val;'], ['String oldVal = parent.get(this.key);'], ['String oldVal = this.val; oldVal = parent.get(this.key); // trust the container more'], 'a/src/main/java/org/jsoup/nodes/Attribute.java', 'b/src/main/java/org/jsoup/nodes/Attribute.java']
['Jsoup-90', 1, 1, 1, 1, ['return false; } while (i < end) { i++;'], ['return false; } if (end >= input.length) return false; while (i < end) { i++;'], [''], ['if (end >= input.length) return false;'], 'a/src/main/java/org/jsoup/helper/HttpConnection.java', 'b/src/main/java/org/jsoup/helper/HttpConnection.java']
['Jsoup-91', 3, 3, 3, 3, ['super(cause); } public IOException ioException() { return (IOException) getCause();', 'charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz]; bufferUp(); } public CharacterReader(Reader input) {', 'return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1); } /** * Heuristic to determine if the current buffer looks like binary content. Reader will already hopefully be * decoded correctly, so a bunch of NULLs indicates a binary file */ @Override public String toString() {'], ['super(cause); } public UncheckedIOException(String message) { super(new IOException(message)); } public IOException ioException() { return (IOException) getCause();', 'charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz]; bufferUp(); if (isBinary()) { throw new UncheckedIOException("Input is binary and unsupported"); } } public CharacterReader(Reader input) {', "return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1); } private static final int numNullsConsideredBinary = 10; // conservative /** * Heuristic to determine if the current buffer looks like binary content. Reader will already hopefully be * decoded correctly, so a bunch of NULLs indicates a binary file */ boolean isBinary() { int nullsSeen = 0; for (int i = bufPos; i < bufLength; i++) { if (charBuf[i] == '\\0') nullsSeen++; } return nullsSeen >= numNullsConsideredBinary; } @Override public String toString() {"], ['', '', ''], ['public UncheckedIOException(String message) { super(new IOException(message)); }', 'if (isBinary()) { throw new UncheckedIOException("Input is binary and unsupported"); }', "private static final int numNullsConsideredBinary = 10; // conservative boolean isBinary() { int nullsSeen = 0; for (int i = bufPos; i < bufLength; i++) { if (charBuf[i] == '\\0') nullsSeen++; } return nullsSeen >= numNullsConsideredBinary; }"], 'a/src/main/java/org/jsoup/parser/CharacterReader.java', 'b/src/main/java/org/jsoup/parser/CharacterReader.java']
['Jsoup-92', 8, 8, 8, 8, ['import org.jsoup.SerializationException; import org.jsoup.helper.Validate; import org.jsoup.internal.StringUtil; import java.io.IOException; import java.util.AbstractMap;', '* Adds a new attribute. Will produce duplicates if the key already exists. * @see Attributes#put(String, String) */ private void add(String key, String value) { checkCapacity(size + 1); keys[size] = key; vals[size] = value; size++; } /**', '/** * Test if this Attributes list is empty (size==0). */ /** Add all the attributes from the incoming set to this set.', '* @param settings case sensitivity * @return number of removed dupes */ private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes;', " Element insert(final Token.StartTag startTag) { // cleanup duplicate attributes: // handle empty unknown tags // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.", '/** * Returns true if preserving attribute case. */ /** * Define parse settings.', 'else value = null; // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder). attributes.put(pendingAttributeName, value); } } pendingAttributeName = null;', "Element insert(Token.StartTag startTag) { Tag tag = Tag.valueOf(startTag.name(), settings); // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html. Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes)); insertNode(el);"], ['import org.jsoup.SerializationException; import org.jsoup.helper.Validate; import org.jsoup.internal.StringUtil; import org.jsoup.parser.ParseSettings; import java.io.IOException; import java.util.AbstractMap;', '* Adds a new attribute. Will produce duplicates if the key already exists. * @see Attributes#put(String, String) */ public Attributes add(String key, String value) { checkCapacity(size + 1); keys[size] = key; vals[size] = value; size++; return this; } /**', '/** * Test if this Attributes list is empty (size==0). */ public boolean isEmpty() { return size == 0; } /** Add all the attributes from the incoming set to this set.', "* @param settings case sensitivity * @return number of removed dupes */ public int deduplicate(ParseSettings settings) { if (isEmpty()) return 0; boolean preserve = settings.preserveAttributeCase(); int dupes = 0; OUTER: for (int i = 0; i < keys.length; i++) { for (int j = i + 1; j < keys.length; j++) { if (keys[j] == null) continue OUTER; // keys.length doesn't shrink when removing, so re-test if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) { dupes++; remove(j); j--; } } } return dupes; } private static class Dataset extends AbstractMap<String, String> { private final Attributes attributes;", ' Element insert(final Token.StartTag startTag) { // cleanup duplicate attributes: if (!startTag.attributes.isEmpty()) { int dupes = startTag.attributes.deduplicate(settings); if (dupes > 0) { error("Duplicate attribute"); } } // handle empty unknown tags // when the spec expects an empty tag, will directly hit insertEmpty, so won\'t generate this fake end tag.', '/** * Returns true if preserving attribute case. */ public boolean preserveAttributeCase() { return preserveAttributeCase; } /** * Define parse settings.', 'else value = null; // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder). attributes.add(pendingAttributeName, value); } } pendingAttributeName = null;', "Element insert(Token.StartTag startTag) { Tag tag = Tag.valueOf(startTag.name(), settings); // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html. startTag.attributes.deduplicate(settings); Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes)); insertNode(el);"], ['', 'private void add(String key, String value) {', '', '', '', '', 'attributes.put(pendingAttributeName, value);', ''], ['import org.jsoup.parser.ParseSettings;', 'public Attributes add(String key, String value) { return this;', 'public boolean isEmpty() { return size == 0; }', "public int deduplicate(ParseSettings settings) { if (isEmpty()) return 0; boolean preserve = settings.preserveAttributeCase(); int dupes = 0; OUTER: for (int i = 0; i < keys.length; i++) { for (int j = i + 1; j < keys.length; j++) { if (keys[j] == null) continue OUTER; // keys.length doesn't shrink when removing, so re-test if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) { dupes++; remove(j); j--; } } } return dupes; }", 'if (!startTag.attributes.isEmpty()) { int dupes = startTag.attributes.deduplicate(settings); if (dupes > 0) { error("Duplicate attribute"); } }', 'public boolean preserveAttributeCase() { return preserveAttributeCase; }', 'attributes.add(pendingAttributeName, value);', 'startTag.attributes.deduplicate(settings);'], 'a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java', 'b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java']
['Jsoup-93', 1, 1, 1, 1, ['if (name.length() == 0) continue; String type = el.attr("type"); if ("select".equals(el.normalName())) { Elements options = el.select("option[selected]");'], ['if (name.length() == 0) continue; String type = el.attr("type"); if (type.equalsIgnoreCase("button")) continue; // browsers don\'t submit these if ("select".equals(el.normalName())) { Elements options = el.select("option[selected]");'], [''], ['if (type.equalsIgnoreCase("button")) continue; // browsers don\'t submit these'], 'a/src/main/java/org/jsoup/nodes/FormElement.java', 'b/src/main/java/org/jsoup/nodes/FormElement.java']
